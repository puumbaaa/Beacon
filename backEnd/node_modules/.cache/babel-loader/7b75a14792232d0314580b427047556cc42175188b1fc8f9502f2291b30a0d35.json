{"ast":null,"code":"// PostgreSQL\n// -------\nconst extend = require('lodash/extend');\nconst map = require('lodash/map');\nconst {\n  promisify\n} = require('util');\nconst Client = require('../../client');\nconst Transaction = require('./execution/pg-transaction');\nconst QueryCompiler = require('./query/pg-querycompiler');\nconst QueryBuilder = require('./query/pg-querybuilder');\nconst ColumnCompiler = require('./schema/pg-columncompiler');\nconst TableCompiler = require('./schema/pg-tablecompiler');\nconst ViewCompiler = require('./schema/pg-viewcompiler');\nconst ViewBuilder = require('./schema/pg-viewbuilder');\nconst SchemaCompiler = require('./schema/pg-compiler');\nconst {\n  makeEscape\n} = require('../../util/string');\nconst {\n  isString\n} = require('../../util/is');\nclass Client_PG extends Client {\n  constructor(config) {\n    super(config);\n    if (config.returning) {\n      this.defaultReturning = config.returning;\n    }\n    if (config.searchPath) {\n      this.searchPath = config.searchPath;\n    }\n  }\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n  queryBuilder() {\n    return new QueryBuilder(this);\n  }\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n  viewCompiler() {\n    return new ViewCompiler(this, ...arguments);\n  }\n  viewBuilder() {\n    return new ViewBuilder(this, ...arguments);\n  }\n  _driver() {\n    return require('pg');\n  }\n  wrapIdentifierImpl(value) {\n    if (value === '*') return value;\n    let arrayAccessor = '';\n    const arrayAccessorMatch = value.match(/(.*?)(\\[[0-9]+\\])/);\n    if (arrayAccessorMatch) {\n      value = arrayAccessorMatch[1];\n      arrayAccessor = arrayAccessorMatch[2];\n    }\n    return `\"${value.replace(/\"/g, '\"\"')}\"${arrayAccessor}`;\n  }\n  _acquireOnlyConnection() {\n    const connection = new this.driver.Client(this.connectionSettings);\n    connection.on('error', err => {\n      connection.__knex__disposed = err;\n    });\n    connection.on('end', err => {\n      connection.__knex__disposed = err || 'Connection ended unexpectedly';\n    });\n    return connection.connect().then(() => connection);\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    const client = this;\n    return this._acquireOnlyConnection().then(function (connection) {\n      if (!client.version) {\n        return client.checkVersion(connection).then(function (version) {\n          client.version = version;\n          return connection;\n        });\n      }\n      return connection;\n    }).then(async function setSearchPath(connection) {\n      await client.setSchemaSearchPath(connection);\n      return connection;\n    });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  async destroyRawConnection(connection) {\n    const end = promisify(cb => connection.end(cb));\n    return end();\n  }\n\n  // In PostgreSQL, we need to do a version check to do some feature\n  // checking on the database.\n  checkVersion(connection) {\n    return new Promise((resolve, reject) => {\n      connection.query('select version();', (err, resp) => {\n        if (err) return reject(err);\n        resolve(this._parseVersion(resp.rows[0].version));\n      });\n    });\n  }\n  _parseVersion(versionString) {\n    return /^PostgreSQL (.*?)( |$)/.exec(versionString)[1];\n  }\n\n  // Position the bindings for the query. The escape sequence for question mark\n  // is \\? (e.g. knex.raw(\"\\\\?\") since javascript requires '\\' to be escaped too...)\n  positionBindings(sql) {\n    let questionCount = 0;\n    return sql.replace(/(\\\\*)(\\?)/g, function (match, escapes) {\n      if (escapes.length % 2) {\n        return '?';\n      } else {\n        questionCount++;\n        return `$${questionCount}`;\n      }\n    });\n  }\n  setSchemaSearchPath(connection, searchPath) {\n    let path = searchPath || this.searchPath;\n    if (!path) return Promise.resolve(true);\n    if (!Array.isArray(path) && !isString(path)) {\n      throw new TypeError(`knex: Expected searchPath to be Array/String, got: ${typeof path}`);\n    }\n    if (isString(path)) {\n      if (path.includes(',')) {\n        const parts = path.split(',');\n        const arraySyntax = `[${parts.map(searchPath => `'${searchPath}'`).join(', ')}]`;\n        this.logger.warn(`Detected comma in searchPath \"${path}\".` + `If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`);\n      }\n      path = [path];\n    }\n    path = path.map(schemaName => `\"${schemaName}\"`).join(',');\n    return new Promise(function (resolver, rejecter) {\n      connection.query(`set search_path to ${path}`, function (err) {\n        if (err) return rejecter(err);\n        resolver(true);\n      });\n    });\n  }\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n    const PGQueryStream = process.browser ? undefined : require('pg-query-stream');\n    const sql = obj.sql;\n    return new Promise(function (resolver, rejecter) {\n      const queryStream = connection.query(new PGQueryStream(sql, obj.bindings, options), err => {\n        rejecter(err);\n      });\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      });\n\n      // 'end' IS propagated by .pipe, by default\n      stream.on('end', resolver);\n      queryStream.pipe(stream);\n    });\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n    let queryConfig = {\n      text: obj.sql,\n      values: obj.bindings || []\n    };\n    if (obj.options) {\n      queryConfig = extend(queryConfig, obj.options);\n    }\n    return new Promise(function (resolver, rejecter) {\n      connection.query(queryConfig, function (err, response) {\n        if (err) return rejecter(err);\n        obj.response = response;\n        resolver(obj);\n      });\n    });\n  }\n\n  // Ensures the response is returned in the same format as other clients.\n  processResponse(obj, runner) {\n    const resp = obj.response;\n    if (obj.output) return obj.output.call(runner, resp);\n    if (obj.method === 'raw') return resp;\n    const {\n      returning\n    } = obj;\n    if (resp.command === 'SELECT') {\n      if (obj.method === 'first') return resp.rows[0];\n      if (obj.method === 'pluck') return map(resp.rows, obj.pluck);\n      return resp.rows;\n    }\n    if (returning) {\n      const returns = [];\n      for (let i = 0, l = resp.rows.length; i < l; i++) {\n        const row = resp.rows[i];\n        returns[i] = row;\n      }\n      return returns;\n    }\n    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {\n      return resp.rowCount;\n    }\n    return resp;\n  }\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n    try {\n      return await this._wrappedCancelQueryCall(conn, connectionToKill);\n    } finally {\n      await this.destroyRawConnection(conn).catch(err => {\n        this.logger.warn(`Connection Error: ${err}`);\n      });\n    }\n  }\n  _wrappedCancelQueryCall(conn, connectionToKill) {\n    return this._query(conn, {\n      sql: 'SELECT pg_cancel_backend($1);',\n      bindings: [connectionToKill.processID],\n      options: {}\n    });\n  }\n  toPathForJson(jsonPath) {\n    const PG_PATH_REGEX = /^{.*}$/;\n    if (jsonPath.match(PG_PATH_REGEX)) {\n      return jsonPath;\n    }\n    return '{' + jsonPath.replace(/^(\\$\\.)/, '') // remove the first dollar\n    .replace('.', ',').replace(/\\[([0-9]+)]/, ',$1') +\n    // transform [number] to ,number\n    '}';\n  }\n}\nObject.assign(Client_PG.prototype, {\n  dialect: 'postgresql',\n  driverName: 'pg',\n  canCancelQuery: true,\n  _escapeBinding: makeEscape({\n    escapeArray(val, esc) {\n      return esc(arrayString(val, esc));\n    },\n    escapeString(str) {\n      let hasBackslash = false;\n      let escaped = \"'\";\n      for (let i = 0; i < str.length; i++) {\n        const c = str[i];\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n      escaped += \"'\";\n      if (hasBackslash === true) {\n        escaped = 'E' + escaped;\n      }\n      return escaped;\n    },\n    escapeObject(val, prepareValue, timezone, seen = []) {\n      if (val && typeof val.toPostgres === 'function') {\n        seen = seen || [];\n        if (seen.indexOf(val) !== -1) {\n          throw new Error(`circular reference detected while preparing \"${val}\" for query`);\n        }\n        seen.push(val);\n        return prepareValue(val.toPostgres(prepareValue), seen);\n      }\n      return JSON.stringify(val);\n    }\n  })\n});\nfunction arrayString(arr, esc) {\n  let result = '{';\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) result += ',';\n    const val = arr[i];\n    if (val === null || typeof val === 'undefined') {\n      result += 'NULL';\n    } else if (Array.isArray(val)) {\n      result += arrayString(val, esc);\n    } else if (typeof val === 'number') {\n      result += val;\n    } else {\n      result += JSON.stringify(typeof val === 'string' ? val : esc(val));\n    }\n  }\n  return result + '}';\n}\nmodule.exports = Client_PG;","map":{"version":3,"names":["extend","require","map","promisify","Client","Transaction","QueryCompiler","QueryBuilder","ColumnCompiler","TableCompiler","ViewCompiler","ViewBuilder","SchemaCompiler","makeEscape","isString","Client_PG","constructor","config","returning","defaultReturning","searchPath","transaction","arguments","queryBuilder","queryCompiler","builder","formatter","columnCompiler","schemaCompiler","tableCompiler","viewCompiler","viewBuilder","_driver","wrapIdentifierImpl","value","arrayAccessor","arrayAccessorMatch","match","replace","_acquireOnlyConnection","connection","driver","connectionSettings","on","err","__knex__disposed","connect","then","acquireRawConnection","client","version","checkVersion","setSearchPath","setSchemaSearchPath","destroyRawConnection","end","cb","Promise","resolve","reject","query","resp","_parseVersion","rows","versionString","exec","positionBindings","sql","questionCount","escapes","length","path","Array","isArray","TypeError","includes","parts","split","arraySyntax","join","logger","warn","schemaName","resolver","rejecter","_stream","obj","stream","options","Error","PGQueryStream","process","browser","undefined","queryStream","bindings","error","emit","pipe","_query","queryConfig","text","values","response","processResponse","runner","output","call","method","command","pluck","returns","i","l","row","rowCount","cancelQuery","connectionToKill","conn","_wrappedCancelQueryCall","catch","processID","toPathForJson","jsonPath","PG_PATH_REGEX","Object","assign","prototype","dialect","driverName","canCancelQuery","_escapeBinding","escapeArray","val","esc","arrayString","escapeString","str","hasBackslash","escaped","c","escapeObject","prepareValue","timezone","seen","toPostgres","indexOf","push","JSON","stringify","arr","result","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/postgres/index.js"],"sourcesContent":["// PostgreSQL\n// -------\nconst extend = require('lodash/extend');\nconst map = require('lodash/map');\nconst { promisify } = require('util');\nconst Client = require('../../client');\n\nconst Transaction = require('./execution/pg-transaction');\nconst QueryCompiler = require('./query/pg-querycompiler');\nconst QueryBuilder = require('./query/pg-querybuilder');\nconst ColumnCompiler = require('./schema/pg-columncompiler');\nconst TableCompiler = require('./schema/pg-tablecompiler');\nconst ViewCompiler = require('./schema/pg-viewcompiler');\nconst ViewBuilder = require('./schema/pg-viewbuilder');\nconst SchemaCompiler = require('./schema/pg-compiler');\nconst { makeEscape } = require('../../util/string');\nconst { isString } = require('../../util/is');\n\nclass Client_PG extends Client {\n  constructor(config) {\n    super(config);\n    if (config.returning) {\n      this.defaultReturning = config.returning;\n    }\n\n    if (config.searchPath) {\n      this.searchPath = config.searchPath;\n    }\n  }\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  queryBuilder() {\n    return new QueryBuilder(this);\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  viewCompiler() {\n    return new ViewCompiler(this, ...arguments);\n  }\n\n  viewBuilder() {\n    return new ViewBuilder(this, ...arguments);\n  }\n\n  _driver() {\n    return require('pg');\n  }\n\n  wrapIdentifierImpl(value) {\n    if (value === '*') return value;\n\n    let arrayAccessor = '';\n    const arrayAccessorMatch = value.match(/(.*?)(\\[[0-9]+\\])/);\n\n    if (arrayAccessorMatch) {\n      value = arrayAccessorMatch[1];\n      arrayAccessor = arrayAccessorMatch[2];\n    }\n\n    return `\"${value.replace(/\"/g, '\"\"')}\"${arrayAccessor}`;\n  }\n\n  _acquireOnlyConnection() {\n    const connection = new this.driver.Client(this.connectionSettings);\n\n    connection.on('error', (err) => {\n      connection.__knex__disposed = err;\n    });\n\n    connection.on('end', (err) => {\n      connection.__knex__disposed = err || 'Connection ended unexpectedly';\n    });\n\n    return connection.connect().then(() => connection);\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    const client = this;\n\n    return this._acquireOnlyConnection()\n      .then(function (connection) {\n        if (!client.version) {\n          return client.checkVersion(connection).then(function (version) {\n            client.version = version;\n            return connection;\n          });\n        }\n\n        return connection;\n      })\n      .then(async function setSearchPath(connection) {\n        await client.setSchemaSearchPath(connection);\n        return connection;\n      });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  async destroyRawConnection(connection) {\n    const end = promisify((cb) => connection.end(cb));\n    return end();\n  }\n\n  // In PostgreSQL, we need to do a version check to do some feature\n  // checking on the database.\n  checkVersion(connection) {\n    return new Promise((resolve, reject) => {\n      connection.query('select version();', (err, resp) => {\n        if (err) return reject(err);\n        resolve(this._parseVersion(resp.rows[0].version));\n      });\n    });\n  }\n\n  _parseVersion(versionString) {\n    return /^PostgreSQL (.*?)( |$)/.exec(versionString)[1];\n  }\n\n  // Position the bindings for the query. The escape sequence for question mark\n  // is \\? (e.g. knex.raw(\"\\\\?\") since javascript requires '\\' to be escaped too...)\n  positionBindings(sql) {\n    let questionCount = 0;\n    return sql.replace(/(\\\\*)(\\?)/g, function (match, escapes) {\n      if (escapes.length % 2) {\n        return '?';\n      } else {\n        questionCount++;\n        return `$${questionCount}`;\n      }\n    });\n  }\n\n  setSchemaSearchPath(connection, searchPath) {\n    let path = searchPath || this.searchPath;\n\n    if (!path) return Promise.resolve(true);\n\n    if (!Array.isArray(path) && !isString(path)) {\n      throw new TypeError(\n        `knex: Expected searchPath to be Array/String, got: ${typeof path}`\n      );\n    }\n\n    if (isString(path)) {\n      if (path.includes(',')) {\n        const parts = path.split(',');\n        const arraySyntax = `[${parts\n          .map((searchPath) => `'${searchPath}'`)\n          .join(', ')}]`;\n        this.logger.warn(\n          `Detected comma in searchPath \"${path}\".` +\n            `If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`\n        );\n      }\n      path = [path];\n    }\n\n    path = path.map((schemaName) => `\"${schemaName}\"`).join(',');\n\n    return new Promise(function (resolver, rejecter) {\n      connection.query(`set search_path to ${path}`, function (err) {\n        if (err) return rejecter(err);\n        resolver(true);\n      });\n    });\n  }\n\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    const PGQueryStream = process.browser\n      ? undefined\n      : require('pg-query-stream');\n    const sql = obj.sql;\n\n    return new Promise(function (resolver, rejecter) {\n      const queryStream = connection.query(\n        new PGQueryStream(sql, obj.bindings, options),\n        (err) => {\n          rejecter(err);\n        }\n      );\n\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      });\n\n      // 'end' IS propagated by .pipe, by default\n      stream.on('end', resolver);\n      queryStream.pipe(stream);\n    });\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    let queryConfig = {\n      text: obj.sql,\n      values: obj.bindings || [],\n    };\n\n    if (obj.options) {\n      queryConfig = extend(queryConfig, obj.options);\n    }\n\n    return new Promise(function (resolver, rejecter) {\n      connection.query(queryConfig, function (err, response) {\n        if (err) return rejecter(err);\n        obj.response = response;\n        resolver(obj);\n      });\n    });\n  }\n\n  // Ensures the response is returned in the same format as other clients.\n  processResponse(obj, runner) {\n    const resp = obj.response;\n    if (obj.output) return obj.output.call(runner, resp);\n    if (obj.method === 'raw') return resp;\n    const { returning } = obj;\n    if (resp.command === 'SELECT') {\n      if (obj.method === 'first') return resp.rows[0];\n      if (obj.method === 'pluck') return map(resp.rows, obj.pluck);\n      return resp.rows;\n    }\n    if (returning) {\n      const returns = [];\n      for (let i = 0, l = resp.rows.length; i < l; i++) {\n        const row = resp.rows[i];\n        returns[i] = row;\n      }\n      return returns;\n    }\n    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {\n      return resp.rowCount;\n    }\n    return resp;\n  }\n\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n\n    try {\n      return await this._wrappedCancelQueryCall(conn, connectionToKill);\n    } finally {\n      await this.destroyRawConnection(conn).catch((err) => {\n        this.logger.warn(`Connection Error: ${err}`);\n      });\n    }\n  }\n  _wrappedCancelQueryCall(conn, connectionToKill) {\n    return this._query(conn, {\n      sql: 'SELECT pg_cancel_backend($1);',\n      bindings: [connectionToKill.processID],\n      options: {},\n    });\n  }\n\n  toPathForJson(jsonPath) {\n    const PG_PATH_REGEX = /^{.*}$/;\n    if (jsonPath.match(PG_PATH_REGEX)) {\n      return jsonPath;\n    }\n    return (\n      '{' +\n      jsonPath\n        .replace(/^(\\$\\.)/, '') // remove the first dollar\n        .replace('.', ',')\n        .replace(/\\[([0-9]+)]/, ',$1') + // transform [number] to ,number\n      '}'\n    );\n  }\n}\n\nObject.assign(Client_PG.prototype, {\n  dialect: 'postgresql',\n\n  driverName: 'pg',\n  canCancelQuery: true,\n\n  _escapeBinding: makeEscape({\n    escapeArray(val, esc) {\n      return esc(arrayString(val, esc));\n    },\n    escapeString(str) {\n      let hasBackslash = false;\n      let escaped = \"'\";\n      for (let i = 0; i < str.length; i++) {\n        const c = str[i];\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n      escaped += \"'\";\n      if (hasBackslash === true) {\n        escaped = 'E' + escaped;\n      }\n      return escaped;\n    },\n    escapeObject(val, prepareValue, timezone, seen = []) {\n      if (val && typeof val.toPostgres === 'function') {\n        seen = seen || [];\n        if (seen.indexOf(val) !== -1) {\n          throw new Error(\n            `circular reference detected while preparing \"${val}\" for query`\n          );\n        }\n        seen.push(val);\n        return prepareValue(val.toPostgres(prepareValue), seen);\n      }\n      return JSON.stringify(val);\n    },\n  }),\n});\n\nfunction arrayString(arr, esc) {\n  let result = '{';\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) result += ',';\n    const val = arr[i];\n    if (val === null || typeof val === 'undefined') {\n      result += 'NULL';\n    } else if (Array.isArray(val)) {\n      result += arrayString(val, esc);\n    } else if (typeof val === 'number') {\n      result += val;\n    } else {\n      result += JSON.stringify(typeof val === 'string' ? val : esc(val));\n    }\n  }\n  return result + '}';\n}\n\nmodule.exports = Client_PG;\n"],"mappings":"AAAA;AACA;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,eAAe,CAAC;AACvC,MAAMC,GAAG,GAAGD,OAAO,CAAC,YAAY,CAAC;AACjC,MAAM;EAAEE;AAAU,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AACrC,MAAMG,MAAM,GAAGH,OAAO,CAAC,cAAc,CAAC;AAEtC,MAAMI,WAAW,GAAGJ,OAAO,CAAC,4BAA4B,CAAC;AACzD,MAAMK,aAAa,GAAGL,OAAO,CAAC,0BAA0B,CAAC;AACzD,MAAMM,YAAY,GAAGN,OAAO,CAAC,yBAAyB,CAAC;AACvD,MAAMO,cAAc,GAAGP,OAAO,CAAC,4BAA4B,CAAC;AAC5D,MAAMQ,aAAa,GAAGR,OAAO,CAAC,2BAA2B,CAAC;AAC1D,MAAMS,YAAY,GAAGT,OAAO,CAAC,0BAA0B,CAAC;AACxD,MAAMU,WAAW,GAAGV,OAAO,CAAC,yBAAyB,CAAC;AACtD,MAAMW,cAAc,GAAGX,OAAO,CAAC,sBAAsB,CAAC;AACtD,MAAM;EAAEY;AAAW,CAAC,GAAGZ,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAM;EAAEa;AAAS,CAAC,GAAGb,OAAO,CAAC,eAAe,CAAC;AAE7C,MAAMc,SAAS,SAASX,MAAM,CAAC;EAC7BY,WAAWA,CAACC,MAAM,EAAE;IAClB,KAAK,CAACA,MAAM,CAAC;IACb,IAAIA,MAAM,CAACC,SAAS,EAAE;MACpB,IAAI,CAACC,gBAAgB,GAAGF,MAAM,CAACC,SAAS;IAC1C;IAEA,IAAID,MAAM,CAACG,UAAU,EAAE;MACrB,IAAI,CAACA,UAAU,GAAGH,MAAM,CAACG,UAAU;IACrC;EACF;EACAC,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAIhB,WAAW,CAAC,IAAI,EAAE,GAAGiB,SAAS,CAAC;EAC5C;EAEAC,YAAYA,CAAA,EAAG;IACb,OAAO,IAAIhB,YAAY,CAAC,IAAI,CAAC;EAC/B;EAEAiB,aAAaA,CAACC,OAAO,EAAEC,SAAS,EAAE;IAChC,OAAO,IAAIpB,aAAa,CAAC,IAAI,EAAEmB,OAAO,EAAEC,SAAS,CAAC;EACpD;EAEAC,cAAcA,CAAA,EAAG;IACf,OAAO,IAAInB,cAAc,CAAC,IAAI,EAAE,GAAGc,SAAS,CAAC;EAC/C;EAEAM,cAAcA,CAAA,EAAG;IACf,OAAO,IAAIhB,cAAc,CAAC,IAAI,EAAE,GAAGU,SAAS,CAAC;EAC/C;EAEAO,aAAaA,CAAA,EAAG;IACd,OAAO,IAAIpB,aAAa,CAAC,IAAI,EAAE,GAAGa,SAAS,CAAC;EAC9C;EAEAQ,YAAYA,CAAA,EAAG;IACb,OAAO,IAAIpB,YAAY,CAAC,IAAI,EAAE,GAAGY,SAAS,CAAC;EAC7C;EAEAS,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAIpB,WAAW,CAAC,IAAI,EAAE,GAAGW,SAAS,CAAC;EAC5C;EAEAU,OAAOA,CAAA,EAAG;IACR,OAAO/B,OAAO,CAAC,IAAI,CAAC;EACtB;EAEAgC,kBAAkBA,CAACC,KAAK,EAAE;IACxB,IAAIA,KAAK,KAAK,GAAG,EAAE,OAAOA,KAAK;IAE/B,IAAIC,aAAa,GAAG,EAAE;IACtB,MAAMC,kBAAkB,GAAGF,KAAK,CAACG,KAAK,CAAC,mBAAmB,CAAC;IAE3D,IAAID,kBAAkB,EAAE;MACtBF,KAAK,GAAGE,kBAAkB,CAAC,CAAC,CAAC;MAC7BD,aAAa,GAAGC,kBAAkB,CAAC,CAAC,CAAC;IACvC;IAEA,OAAO,IAAIF,KAAK,CAACI,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,IAAIH,aAAa,EAAE;EACzD;EAEAI,sBAAsBA,CAAA,EAAG;IACvB,MAAMC,UAAU,GAAG,IAAI,IAAI,CAACC,MAAM,CAACrC,MAAM,CAAC,IAAI,CAACsC,kBAAkB,CAAC;IAElEF,UAAU,CAACG,EAAE,CAAC,OAAO,EAAGC,GAAG,IAAK;MAC9BJ,UAAU,CAACK,gBAAgB,GAAGD,GAAG;IACnC,CAAC,CAAC;IAEFJ,UAAU,CAACG,EAAE,CAAC,KAAK,EAAGC,GAAG,IAAK;MAC5BJ,UAAU,CAACK,gBAAgB,GAAGD,GAAG,IAAI,+BAA+B;IACtE,CAAC,CAAC;IAEF,OAAOJ,UAAU,CAACM,OAAO,CAAC,CAAC,CAACC,IAAI,CAAC,MAAMP,UAAU,CAAC;EACpD;;EAEA;EACA;EACAQ,oBAAoBA,CAAA,EAAG;IACrB,MAAMC,MAAM,GAAG,IAAI;IAEnB,OAAO,IAAI,CAACV,sBAAsB,CAAC,CAAC,CACjCQ,IAAI,CAAC,UAAUP,UAAU,EAAE;MAC1B,IAAI,CAACS,MAAM,CAACC,OAAO,EAAE;QACnB,OAAOD,MAAM,CAACE,YAAY,CAACX,UAAU,CAAC,CAACO,IAAI,CAAC,UAAUG,OAAO,EAAE;UAC7DD,MAAM,CAACC,OAAO,GAAGA,OAAO;UACxB,OAAOV,UAAU;QACnB,CAAC,CAAC;MACJ;MAEA,OAAOA,UAAU;IACnB,CAAC,CAAC,CACDO,IAAI,CAAC,eAAeK,aAAaA,CAACZ,UAAU,EAAE;MAC7C,MAAMS,MAAM,CAACI,mBAAmB,CAACb,UAAU,CAAC;MAC5C,OAAOA,UAAU;IACnB,CAAC,CAAC;EACN;;EAEA;EACA;EACA,MAAMc,oBAAoBA,CAACd,UAAU,EAAE;IACrC,MAAMe,GAAG,GAAGpD,SAAS,CAAEqD,EAAE,IAAKhB,UAAU,CAACe,GAAG,CAACC,EAAE,CAAC,CAAC;IACjD,OAAOD,GAAG,CAAC,CAAC;EACd;;EAEA;EACA;EACAJ,YAAYA,CAACX,UAAU,EAAE;IACvB,OAAO,IAAIiB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCnB,UAAU,CAACoB,KAAK,CAAC,mBAAmB,EAAE,CAAChB,GAAG,EAAEiB,IAAI,KAAK;QACnD,IAAIjB,GAAG,EAAE,OAAOe,MAAM,CAACf,GAAG,CAAC;QAC3Bc,OAAO,CAAC,IAAI,CAACI,aAAa,CAACD,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC,CAACb,OAAO,CAAC,CAAC;MACnD,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAY,aAAaA,CAACE,aAAa,EAAE;IAC3B,OAAO,wBAAwB,CAACC,IAAI,CAACD,aAAa,CAAC,CAAC,CAAC,CAAC;EACxD;;EAEA;EACA;EACAE,gBAAgBA,CAACC,GAAG,EAAE;IACpB,IAAIC,aAAa,GAAG,CAAC;IACrB,OAAOD,GAAG,CAAC7B,OAAO,CAAC,YAAY,EAAE,UAAUD,KAAK,EAAEgC,OAAO,EAAE;MACzD,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;QACtB,OAAO,GAAG;MACZ,CAAC,MAAM;QACLF,aAAa,EAAE;QACf,OAAO,IAAIA,aAAa,EAAE;MAC5B;IACF,CAAC,CAAC;EACJ;EAEAf,mBAAmBA,CAACb,UAAU,EAAEpB,UAAU,EAAE;IAC1C,IAAImD,IAAI,GAAGnD,UAAU,IAAI,IAAI,CAACA,UAAU;IAExC,IAAI,CAACmD,IAAI,EAAE,OAAOd,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAEvC,IAAI,CAACc,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,IAAI,CAACzD,QAAQ,CAACyD,IAAI,CAAC,EAAE;MAC3C,MAAM,IAAIG,SAAS,CACjB,sDAAsD,OAAOH,IAAI,EACnE,CAAC;IACH;IAEA,IAAIzD,QAAQ,CAACyD,IAAI,CAAC,EAAE;MAClB,IAAIA,IAAI,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;QACtB,MAAMC,KAAK,GAAGL,IAAI,CAACM,KAAK,CAAC,GAAG,CAAC;QAC7B,MAAMC,WAAW,GAAG,IAAIF,KAAK,CAC1B1E,GAAG,CAAEkB,UAAU,IAAK,IAAIA,UAAU,GAAG,CAAC,CACtC2D,IAAI,CAAC,IAAI,CAAC,GAAG;QAChB,IAAI,CAACC,MAAM,CAACC,IAAI,CACd,iCAAiCV,IAAI,IAAI,GACvC,oEAAoEO,WAAW,EACnF,CAAC;MACH;MACAP,IAAI,GAAG,CAACA,IAAI,CAAC;IACf;IAEAA,IAAI,GAAGA,IAAI,CAACrE,GAAG,CAAEgF,UAAU,IAAK,IAAIA,UAAU,GAAG,CAAC,CAACH,IAAI,CAAC,GAAG,CAAC;IAE5D,OAAO,IAAItB,OAAO,CAAC,UAAU0B,QAAQ,EAAEC,QAAQ,EAAE;MAC/C5C,UAAU,CAACoB,KAAK,CAAC,sBAAsBW,IAAI,EAAE,EAAE,UAAU3B,GAAG,EAAE;QAC5D,IAAIA,GAAG,EAAE,OAAOwC,QAAQ,CAACxC,GAAG,CAAC;QAC7BuC,QAAQ,CAAC,IAAI,CAAC;MAChB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAE,OAAOA,CAAC7C,UAAU,EAAE8C,GAAG,EAAEC,MAAM,EAAEC,OAAO,EAAE;IACxC,IAAI,CAACF,GAAG,CAACnB,GAAG,EAAE,MAAM,IAAIsB,KAAK,CAAC,oBAAoB,CAAC;IAEnD,MAAMC,aAAa,GAAGC,OAAO,CAACC,OAAO,GACjCC,SAAS,GACT5F,OAAO,CAAC,iBAAiB,CAAC;IAC9B,MAAMkE,GAAG,GAAGmB,GAAG,CAACnB,GAAG;IAEnB,OAAO,IAAIV,OAAO,CAAC,UAAU0B,QAAQ,EAAEC,QAAQ,EAAE;MAC/C,MAAMU,WAAW,GAAGtD,UAAU,CAACoB,KAAK,CAClC,IAAI8B,aAAa,CAACvB,GAAG,EAAEmB,GAAG,CAACS,QAAQ,EAAEP,OAAO,CAAC,EAC5C5C,GAAG,IAAK;QACPwC,QAAQ,CAACxC,GAAG,CAAC;MACf,CACF,CAAC;MAEDkD,WAAW,CAACnD,EAAE,CAAC,OAAO,EAAE,UAAUqD,KAAK,EAAE;QACvCZ,QAAQ,CAACY,KAAK,CAAC;QACfT,MAAM,CAACU,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;MAC7B,CAAC,CAAC;;MAEF;MACAT,MAAM,CAAC5C,EAAE,CAAC,KAAK,EAAEwC,QAAQ,CAAC;MAC1BW,WAAW,CAACI,IAAI,CAACX,MAAM,CAAC;IAC1B,CAAC,CAAC;EACJ;;EAEA;EACA;EACAY,MAAMA,CAAC3D,UAAU,EAAE8C,GAAG,EAAE;IACtB,IAAI,CAACA,GAAG,CAACnB,GAAG,EAAE,MAAM,IAAIsB,KAAK,CAAC,oBAAoB,CAAC;IAEnD,IAAIW,WAAW,GAAG;MAChBC,IAAI,EAAEf,GAAG,CAACnB,GAAG;MACbmC,MAAM,EAAEhB,GAAG,CAACS,QAAQ,IAAI;IAC1B,CAAC;IAED,IAAIT,GAAG,CAACE,OAAO,EAAE;MACfY,WAAW,GAAGpG,MAAM,CAACoG,WAAW,EAAEd,GAAG,CAACE,OAAO,CAAC;IAChD;IAEA,OAAO,IAAI/B,OAAO,CAAC,UAAU0B,QAAQ,EAAEC,QAAQ,EAAE;MAC/C5C,UAAU,CAACoB,KAAK,CAACwC,WAAW,EAAE,UAAUxD,GAAG,EAAE2D,QAAQ,EAAE;QACrD,IAAI3D,GAAG,EAAE,OAAOwC,QAAQ,CAACxC,GAAG,CAAC;QAC7B0C,GAAG,CAACiB,QAAQ,GAAGA,QAAQ;QACvBpB,QAAQ,CAACG,GAAG,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;EACAkB,eAAeA,CAAClB,GAAG,EAAEmB,MAAM,EAAE;IAC3B,MAAM5C,IAAI,GAAGyB,GAAG,CAACiB,QAAQ;IACzB,IAAIjB,GAAG,CAACoB,MAAM,EAAE,OAAOpB,GAAG,CAACoB,MAAM,CAACC,IAAI,CAACF,MAAM,EAAE5C,IAAI,CAAC;IACpD,IAAIyB,GAAG,CAACsB,MAAM,KAAK,KAAK,EAAE,OAAO/C,IAAI;IACrC,MAAM;MAAE3C;IAAU,CAAC,GAAGoE,GAAG;IACzB,IAAIzB,IAAI,CAACgD,OAAO,KAAK,QAAQ,EAAE;MAC7B,IAAIvB,GAAG,CAACsB,MAAM,KAAK,OAAO,EAAE,OAAO/C,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC;MAC/C,IAAIuB,GAAG,CAACsB,MAAM,KAAK,OAAO,EAAE,OAAO1G,GAAG,CAAC2D,IAAI,CAACE,IAAI,EAAEuB,GAAG,CAACwB,KAAK,CAAC;MAC5D,OAAOjD,IAAI,CAACE,IAAI;IAClB;IACA,IAAI7C,SAAS,EAAE;MACb,MAAM6F,OAAO,GAAG,EAAE;MAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGpD,IAAI,CAACE,IAAI,CAACO,MAAM,EAAE0C,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAChD,MAAME,GAAG,GAAGrD,IAAI,CAACE,IAAI,CAACiD,CAAC,CAAC;QACxBD,OAAO,CAACC,CAAC,CAAC,GAAGE,GAAG;MAClB;MACA,OAAOH,OAAO;IAChB;IACA,IAAIlD,IAAI,CAACgD,OAAO,KAAK,QAAQ,IAAIhD,IAAI,CAACgD,OAAO,KAAK,QAAQ,EAAE;MAC1D,OAAOhD,IAAI,CAACsD,QAAQ;IACtB;IACA,OAAOtD,IAAI;EACb;EAEA,MAAMuD,WAAWA,CAACC,gBAAgB,EAAE;IAClC,MAAMC,IAAI,GAAG,MAAM,IAAI,CAACtE,oBAAoB,CAAC,CAAC;IAE9C,IAAI;MACF,OAAO,MAAM,IAAI,CAACuE,uBAAuB,CAACD,IAAI,EAAED,gBAAgB,CAAC;IACnE,CAAC,SAAS;MACR,MAAM,IAAI,CAAC/D,oBAAoB,CAACgE,IAAI,CAAC,CAACE,KAAK,CAAE5E,GAAG,IAAK;QACnD,IAAI,CAACoC,MAAM,CAACC,IAAI,CAAC,qBAAqBrC,GAAG,EAAE,CAAC;MAC9C,CAAC,CAAC;IACJ;EACF;EACA2E,uBAAuBA,CAACD,IAAI,EAAED,gBAAgB,EAAE;IAC9C,OAAO,IAAI,CAAClB,MAAM,CAACmB,IAAI,EAAE;MACvBnD,GAAG,EAAE,+BAA+B;MACpC4B,QAAQ,EAAE,CAACsB,gBAAgB,CAACI,SAAS,CAAC;MACtCjC,OAAO,EAAE,CAAC;IACZ,CAAC,CAAC;EACJ;EAEAkC,aAAaA,CAACC,QAAQ,EAAE;IACtB,MAAMC,aAAa,GAAG,QAAQ;IAC9B,IAAID,QAAQ,CAACtF,KAAK,CAACuF,aAAa,CAAC,EAAE;MACjC,OAAOD,QAAQ;IACjB;IACA,OACE,GAAG,GACHA,QAAQ,CACLrF,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;IAAA,CACvBA,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CACjBA,OAAO,CAAC,aAAa,EAAE,KAAK,CAAC;IAAG;IACnC,GAAG;EAEP;AACF;AAEAuF,MAAM,CAACC,MAAM,CAAC/G,SAAS,CAACgH,SAAS,EAAE;EACjCC,OAAO,EAAE,YAAY;EAErBC,UAAU,EAAE,IAAI;EAChBC,cAAc,EAAE,IAAI;EAEpBC,cAAc,EAAEtH,UAAU,CAAC;IACzBuH,WAAWA,CAACC,GAAG,EAAEC,GAAG,EAAE;MACpB,OAAOA,GAAG,CAACC,WAAW,CAACF,GAAG,EAAEC,GAAG,CAAC,CAAC;IACnC,CAAC;IACDE,YAAYA,CAACC,GAAG,EAAE;MAChB,IAAIC,YAAY,GAAG,KAAK;MACxB,IAAIC,OAAO,GAAG,GAAG;MACjB,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,GAAG,CAACnE,MAAM,EAAE0C,CAAC,EAAE,EAAE;QACnC,MAAM4B,CAAC,GAAGH,GAAG,CAACzB,CAAC,CAAC;QAChB,IAAI4B,CAAC,KAAK,GAAG,EAAE;UACbD,OAAO,IAAIC,CAAC,GAAGA,CAAC;QAClB,CAAC,MAAM,IAAIA,CAAC,KAAK,IAAI,EAAE;UACrBD,OAAO,IAAIC,CAAC,GAAGA,CAAC;UAChBF,YAAY,GAAG,IAAI;QACrB,CAAC,MAAM;UACLC,OAAO,IAAIC,CAAC;QACd;MACF;MACAD,OAAO,IAAI,GAAG;MACd,IAAID,YAAY,KAAK,IAAI,EAAE;QACzBC,OAAO,GAAG,GAAG,GAAGA,OAAO;MACzB;MACA,OAAOA,OAAO;IAChB,CAAC;IACDE,YAAYA,CAACR,GAAG,EAAES,YAAY,EAAEC,QAAQ,EAAEC,IAAI,GAAG,EAAE,EAAE;MACnD,IAAIX,GAAG,IAAI,OAAOA,GAAG,CAACY,UAAU,KAAK,UAAU,EAAE;QAC/CD,IAAI,GAAGA,IAAI,IAAI,EAAE;QACjB,IAAIA,IAAI,CAACE,OAAO,CAACb,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;UAC5B,MAAM,IAAI5C,KAAK,CACb,gDAAgD4C,GAAG,aACrD,CAAC;QACH;QACAW,IAAI,CAACG,IAAI,CAACd,GAAG,CAAC;QACd,OAAOS,YAAY,CAACT,GAAG,CAACY,UAAU,CAACH,YAAY,CAAC,EAAEE,IAAI,CAAC;MACzD;MACA,OAAOI,IAAI,CAACC,SAAS,CAAChB,GAAG,CAAC;IAC5B;EACF,CAAC;AACH,CAAC,CAAC;AAEF,SAASE,WAAWA,CAACe,GAAG,EAAEhB,GAAG,EAAE;EAC7B,IAAIiB,MAAM,GAAG,GAAG;EAChB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsC,GAAG,CAAChF,MAAM,EAAE0C,CAAC,EAAE,EAAE;IACnC,IAAIA,CAAC,GAAG,CAAC,EAAEuC,MAAM,IAAI,GAAG;IACxB,MAAMlB,GAAG,GAAGiB,GAAG,CAACtC,CAAC,CAAC;IAClB,IAAIqB,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,WAAW,EAAE;MAC9CkB,MAAM,IAAI,MAAM;IAClB,CAAC,MAAM,IAAI/E,KAAK,CAACC,OAAO,CAAC4D,GAAG,CAAC,EAAE;MAC7BkB,MAAM,IAAIhB,WAAW,CAACF,GAAG,EAAEC,GAAG,CAAC;IACjC,CAAC,MAAM,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;MAClCkB,MAAM,IAAIlB,GAAG;IACf,CAAC,MAAM;MACLkB,MAAM,IAAIH,IAAI,CAACC,SAAS,CAAC,OAAOhB,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGC,GAAG,CAACD,GAAG,CAAC,CAAC;IACpE;EACF;EACA,OAAOkB,MAAM,GAAG,GAAG;AACrB;AAEAC,MAAM,CAACC,OAAO,GAAG1I,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}