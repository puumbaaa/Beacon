{"ast":null,"code":"// PostgreSQL Query Builder & Compiler\n// ------\nconst identity = require('lodash/identity');\nconst reduce = require('lodash/reduce');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst {\n  wrapString,\n  columnize: columnize_,\n  operator: operator_,\n  wrap: wrap_\n} = require('../../../formatter/wrappingFormatter');\nclass QueryCompiler_PG extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    this._defaultInsertValue = 'default';\n  }\n\n  // Compiles a truncate query.\n  truncate() {\n    return `truncate ${this.tableName} restart identity`;\n  }\n\n  // is used if the an array with multiple empty values supplied\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n    const {\n      returning,\n      onConflict,\n      ignore,\n      merge,\n      insert\n    } = this.single;\n    if (onConflict && ignore) sql += this._ignore(onConflict);\n    if (onConflict && merge) {\n      sql += this._merge(merge.updates, onConflict, insert);\n      const wheres = this.where();\n      if (wheres) sql += ` ${wheres}`;\n    }\n    if (returning) sql += this._returning(returning);\n    return {\n      sql,\n      returning\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    const withSQL = this.with();\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    const {\n      returning,\n      updateFrom\n    } = this.single;\n    return {\n      sql: withSQL + `update ${this.single.only ? 'only ' : ''}${this.tableName} ` + `set ${updateData.join(', ')}` + this._updateFrom(updateFrom) + (wheres ? ` ${wheres}` : '') + this._returning(returning),\n      returning\n    };\n  }\n  using() {\n    const usingTables = this.single.using;\n    if (!usingTables) return;\n    let sql = 'using ';\n    if (Array.isArray(usingTables)) {\n      sql += usingTables.map(table => {\n        return this.formatter.wrap(table);\n      }).join(',');\n    } else {\n      sql += this.formatter.wrap(usingTables);\n    }\n    return sql;\n  }\n\n  // Compiles an `delete` query, allowing for a return value.\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const {\n      tableName\n    } = this;\n    const withSQL = this.with();\n    let wheres = this.where() || '';\n    let using = this.using() || '';\n    const joins = this.grouped.join;\n    const tableJoins = [];\n    if (Array.isArray(joins)) {\n      for (const join of joins) {\n        tableJoins.push(wrap_(this._joinTable(join), undefined, this.builder, this.client, this.bindingsHolder));\n        const joinWheres = [];\n        for (const clause of join.clauses) {\n          joinWheres.push(this.whereBasic({\n            column: clause.column,\n            operator: '=',\n            value: clause.value,\n            asColumn: true\n          }));\n        }\n        if (joinWheres.length > 0) {\n          wheres += (wheres ? ' and ' : 'where ') + joinWheres.join(' and ');\n        }\n      }\n      if (tableJoins.length > 0) {\n        using += (using ? ',' : 'using ') + tableJoins.join(',');\n      }\n    }\n\n    // With 'using' syntax, no tablename between DELETE and FROM.\n    const sql = withSQL + `delete from ${this.single.only ? 'only ' : ''}${tableName}` + (using ? ` ${using}` : '') + (wheres ? ` ${wheres}` : '');\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: sql + this._returning(returning),\n      returning\n    };\n  }\n  aggregate(stmt) {\n    return this._aggregate(stmt, {\n      distinctParentheses: true\n    });\n  }\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n  _updateFrom(name) {\n    return name ? ` from ${this.formatter.wrap(name)}` : '';\n  }\n  _ignore(columns) {\n    if (columns === true) {\n      return ' on conflict do nothing';\n    }\n    return ` on conflict ${this._onConflictClause(columns)} do nothing`;\n  }\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates.map(column => wrapString(column.split('.').pop(), this.formatter.builder, this.client, this.formatter)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error('If using merge with a raw insert query, then updates must be provided');\n      }\n      sql += insertData.columns.map(column => wrapString(column.split('.').pop(), this.builder, this.client)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    }\n  }\n\n  // Join array of table names and apply default schema.\n  _tableNames(tables) {\n    const schemaName = this.single.schema;\n    const sql = [];\n    for (let i = 0; i < tables.length; i++) {\n      let tableName = tables[i];\n      if (tableName) {\n        if (schemaName) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n        sql.push(this.formatter.wrap(tableName));\n      }\n    }\n    return sql.join(', ');\n  }\n  _lockingClause(lockMode) {\n    const tables = this.single.lockTables || [];\n    return lockMode + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  }\n  _groupOrder(item, type) {\n    return super._groupOrderNulls(item, type);\n  }\n  forUpdate() {\n    return this._lockingClause('for update');\n  }\n  forShare() {\n    return this._lockingClause('for share');\n  }\n  forNoKeyUpdate() {\n    return this._lockingClause('for no key update');\n  }\n  forKeyShare() {\n    return this._lockingClause('for key share');\n  }\n  skipLocked() {\n    return 'skip locked';\n  }\n  noWait() {\n    return 'nowait';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n    const sql = 'select * from information_schema.columns where table_name = ? and table_catalog = current_database()';\n    const bindings = [table];\n    return this._buildColumnInfoQuery(schema, sql, bindings, column);\n  }\n  _buildColumnInfoQuery(schema, sql, bindings, column) {\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n    return {\n      sql,\n      bindings,\n      output(resp) {\n        const out = reduce(resp.rows, function (columns, val) {\n          columns[val.column_name] = {\n            type: val.data_type,\n            maxLength: val.character_maximum_length,\n            nullable: val.is_nullable === 'YES',\n            defaultValue: val.column_default\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n  distinctOn(value) {\n    return 'distinct on (' + this.formatter.columnize(value) + ') ';\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract('jsonb_path_query', params);\n  }\n  jsonSet(params) {\n    return this._jsonSet('jsonb_set', Object.assign({}, params, {\n      path: this.client.toPathForJson(params.path)\n    }));\n  }\n  jsonInsert(params) {\n    return this._jsonSet('jsonb_insert', Object.assign({}, params, {\n      path: this.client.toPathForJson(params.path)\n    }));\n  }\n  jsonRemove(params) {\n    const jsonCol = `${columnize_(params.column, this.builder, this.client, this.bindingsHolder)} #- ${this.client.parameter(this.client.toPathForJson(params.path), this.builder, this.bindingsHolder)}`;\n    return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;\n  }\n  whereJsonPath(statement) {\n    let castValue = '';\n    if (!isNaN(statement.value) && parseInt(statement.value)) {\n      castValue = '::int';\n    } else if (!isNaN(statement.value) && parseFloat(statement.value)) {\n      castValue = '::float';\n    } else {\n      castValue = \" #>> '{}'\";\n    }\n    return `jsonb_path_query_first(${this._columnClause(statement)}, ${this.client.parameter(statement.jsonPath, this.builder, this.bindingsHolder)})${castValue} ${operator_(statement.operator, this.builder, this.client, this.bindingsHolder)} ${this._jsonValueClause(statement)}`;\n  }\n  whereJsonSupersetOf(statement) {\n    return this._not(statement, `${wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder)} @> ${this._jsonValueClause(statement)}`);\n  }\n  whereJsonSubsetOf(statement) {\n    return this._not(statement, `${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)} <@ ${this._jsonValueClause(statement)}`);\n  }\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('jsonb_path_query_first', clause);\n  }\n}\nmodule.exports = QueryCompiler_PG;","map":{"version":3,"names":["identity","require","reduce","QueryCompiler","wrapString","columnize","columnize_","operator","operator_","wrap","wrap_","QueryCompiler_PG","constructor","client","builder","formatter","_defaultInsertValue","truncate","tableName","insert","sql","returning","onConflict","ignore","merge","single","_ignore","_merge","updates","wheres","where","_returning","update","withSQL","with","updateData","_prepUpdate","updateFrom","only","join","_updateFrom","using","usingTables","Array","isArray","map","table","del","joins","grouped","tableJoins","push","_joinTable","undefined","bindingsHolder","joinWheres","clause","clauses","whereBasic","column","value","asColumn","length","aggregate","stmt","_aggregate","distinctParentheses","name","columns","_onConflictClause","split","pop","insertData","_prepInsert","Error","_tableNames","tables","schemaName","schema","i","_lockingClause","lockMode","lockTables","_groupOrder","item","type","_groupOrderNulls","forUpdate","forShare","forNoKeyUpdate","forKeyShare","skipLocked","noWait","columnInfo","customWrapIdentifier","bindings","_buildColumnInfoQuery","output","resp","out","rows","val","column_name","data_type","maxLength","character_maximum_length","nullable","is_nullable","defaultValue","column_default","distinctOn","jsonExtract","params","_jsonExtract","jsonSet","_jsonSet","Object","assign","path","toPathForJson","jsonInsert","jsonRemove","jsonCol","parameter","alias","whereJsonPath","statement","castValue","isNaN","parseInt","parseFloat","_columnClause","jsonPath","_jsonValueClause","whereJsonSupersetOf","_not","whereJsonSubsetOf","onJsonPathEquals","_onJsonPathEquals","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js"],"sourcesContent":["// PostgreSQL Query Builder & Compiler\n// ------\nconst identity = require('lodash/identity');\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\nconst {\n  wrapString,\n  columnize: columnize_,\n  operator: operator_,\n  wrap: wrap_,\n} = require('../../../formatter/wrappingFormatter');\n\nclass QueryCompiler_PG extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    this._defaultInsertValue = 'default';\n  }\n\n  // Compiles a truncate query.\n  truncate() {\n    return `truncate ${this.tableName} restart identity`;\n  }\n\n  // is used if the an array with multiple empty values supplied\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n\n    const { returning, onConflict, ignore, merge, insert } = this.single;\n    if (onConflict && ignore) sql += this._ignore(onConflict);\n    if (onConflict && merge) {\n      sql += this._merge(merge.updates, onConflict, insert);\n      const wheres = this.where();\n      if (wheres) sql += ` ${wheres}`;\n    }\n    if (returning) sql += this._returning(returning);\n\n    return {\n      sql,\n      returning,\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    const withSQL = this.with();\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    const { returning, updateFrom } = this.single;\n    return {\n      sql:\n        withSQL +\n        `update ${this.single.only ? 'only ' : ''}${this.tableName} ` +\n        `set ${updateData.join(', ')}` +\n        this._updateFrom(updateFrom) +\n        (wheres ? ` ${wheres}` : '') +\n        this._returning(returning),\n      returning,\n    };\n  }\n\n  using() {\n    const usingTables = this.single.using;\n    if (!usingTables) return;\n    let sql = 'using ';\n    if (Array.isArray(usingTables)) {\n      sql += usingTables\n        .map((table) => {\n          return this.formatter.wrap(table);\n        })\n        .join(',');\n    } else {\n      sql += this.formatter.wrap(usingTables);\n    }\n    return sql;\n  }\n\n  // Compiles an `delete` query, allowing for a return value.\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const { tableName } = this;\n    const withSQL = this.with();\n    let wheres = this.where() || '';\n    let using = this.using() || '';\n    const joins = this.grouped.join;\n\n    const tableJoins = [];\n    if (Array.isArray(joins)) {\n      for (const join of joins) {\n        tableJoins.push(\n          wrap_(\n            this._joinTable(join),\n            undefined,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )\n        );\n\n        const joinWheres = [];\n        for (const clause of join.clauses) {\n          joinWheres.push(\n            this.whereBasic({\n              column: clause.column,\n              operator: '=',\n              value: clause.value,\n              asColumn: true,\n            })\n          );\n        }\n        if (joinWheres.length > 0) {\n          wheres += (wheres ? ' and ' : 'where ') + joinWheres.join(' and ');\n        }\n      }\n      if (tableJoins.length > 0) {\n        using += (using ? ',' : 'using ') + tableJoins.join(',');\n      }\n    }\n\n    // With 'using' syntax, no tablename between DELETE and FROM.\n    const sql =\n      withSQL +\n      `delete from ${this.single.only ? 'only ' : ''}${tableName}` +\n      (using ? ` ${using}` : '') +\n      (wheres ? ` ${wheres}` : '');\n    const { returning } = this.single;\n    return {\n      sql: sql + this._returning(returning),\n      returning,\n    };\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, { distinctParentheses: true });\n  }\n\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n\n  _updateFrom(name) {\n    return name ? ` from ${this.formatter.wrap(name)}` : '';\n  }\n\n  _ignore(columns) {\n    if (columns === true) {\n      return ' on conflict do nothing';\n    }\n    return ` on conflict ${this._onConflictClause(columns)} do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates\n        .map((column) =>\n          wrapString(\n            column.split('.').pop(),\n            this.formatter.builder,\n            this.client,\n            this.formatter\n          )\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error(\n          'If using merge with a raw insert query, then updates must be provided'\n        );\n      }\n\n      sql += insertData.columns\n        .map((column) =>\n          wrapString(column.split('.').pop(), this.builder, this.client)\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    }\n  }\n\n  // Join array of table names and apply default schema.\n  _tableNames(tables) {\n    const schemaName = this.single.schema;\n    const sql = [];\n\n    for (let i = 0; i < tables.length; i++) {\n      let tableName = tables[i];\n\n      if (tableName) {\n        if (schemaName) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n        sql.push(this.formatter.wrap(tableName));\n      }\n    }\n\n    return sql.join(', ');\n  }\n\n  _lockingClause(lockMode) {\n    const tables = this.single.lockTables || [];\n\n    return lockMode + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  }\n\n  _groupOrder(item, type) {\n    return super._groupOrderNulls(item, type);\n  }\n\n  forUpdate() {\n    return this._lockingClause('for update');\n  }\n\n  forShare() {\n    return this._lockingClause('for share');\n  }\n\n  forNoKeyUpdate() {\n    return this._lockingClause('for no key update');\n  }\n\n  forKeyShare() {\n    return this._lockingClause('for key share');\n  }\n\n  skipLocked() {\n    return 'skip locked';\n  }\n\n  noWait() {\n    return 'nowait';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    const sql =\n      'select * from information_schema.columns where table_name = ? and table_catalog = current_database()';\n    const bindings = [table];\n\n    return this._buildColumnInfoQuery(schema, sql, bindings, column);\n  }\n\n  _buildColumnInfoQuery(schema, sql, bindings, column) {\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql,\n      bindings,\n      output(resp) {\n        const out = reduce(\n          resp.rows,\n          function (columns, val) {\n            columns[val.column_name] = {\n              type: val.data_type,\n              maxLength: val.character_maximum_length,\n              nullable: val.is_nullable === 'YES',\n              defaultValue: val.column_default,\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  distinctOn(value) {\n    return 'distinct on (' + this.formatter.columnize(value) + ') ';\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract('jsonb_path_query', params);\n  }\n\n  jsonSet(params) {\n    return this._jsonSet(\n      'jsonb_set',\n      Object.assign({}, params, {\n        path: this.client.toPathForJson(params.path),\n      })\n    );\n  }\n\n  jsonInsert(params) {\n    return this._jsonSet(\n      'jsonb_insert',\n      Object.assign({}, params, {\n        path: this.client.toPathForJson(params.path),\n      })\n    );\n  }\n\n  jsonRemove(params) {\n    const jsonCol = `${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )} #- ${this.client.parameter(\n      this.client.toPathForJson(params.path),\n      this.builder,\n      this.bindingsHolder\n    )}`;\n    return params.alias\n      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))\n      : jsonCol;\n  }\n\n  whereJsonPath(statement) {\n    let castValue = '';\n    if (!isNaN(statement.value) && parseInt(statement.value)) {\n      castValue = '::int';\n    } else if (!isNaN(statement.value) && parseFloat(statement.value)) {\n      castValue = '::float';\n    } else {\n      castValue = \" #>> '{}'\";\n    }\n    return `jsonb_path_query_first(${this._columnClause(\n      statement\n    )}, ${this.client.parameter(\n      statement.jsonPath,\n      this.builder,\n      this.bindingsHolder\n    )})${castValue} ${operator_(\n      statement.operator,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )} ${this._jsonValueClause(statement)}`;\n  }\n\n  whereJsonSupersetOf(statement) {\n    return this._not(\n      statement,\n      `${wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )} @> ${this._jsonValueClause(statement)}`\n    );\n  }\n\n  whereJsonSubsetOf(statement) {\n    return this._not(\n      statement,\n      `${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )} <@ ${this._jsonValueClause(statement)}`\n    );\n  }\n\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('jsonb_path_query_first', clause);\n  }\n}\n\nmodule.exports = QueryCompiler_PG;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}