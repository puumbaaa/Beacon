{"ast":null,"code":"// SQLite3 Query Builder & Compiler\n\nconst constant = require('lodash/constant');\nconst each = require('lodash/each');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst reduce = require('lodash/reduce');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst noop = require('../../../util/noop');\nconst {\n  isString\n} = require('../../../util/is');\nconst {\n  wrapString,\n  columnize: columnize_\n} = require('../../../formatter/wrappingFormatter');\nconst emptyStr = constant('');\nclass QueryCompiler_SQLite3 extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    // The locks are not applicable in SQLite3\n    this.forShare = emptyStr;\n    this.forKeyShare = emptyStr;\n    this.forUpdate = emptyStr;\n    this.forNoKeyUpdate = emptyStr;\n  }\n\n  // SQLite requires us to build the multi-row insert as a listing of select with\n  // unions joining them together. So we'll build out this list of columns and\n  // then join them all together with select unions to complete the queries.\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      } else if (insertValues.length === 1 && insertValues[0] && isEmpty(insertValues[0])) {\n        return {\n          sql: sql + this._emptyInsertValue\n        };\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + this._emptyInsertValue\n      };\n    }\n    const insertData = this._prepInsert(insertValues);\n    if (isString(insertData)) {\n      return {\n        sql: sql + insertData\n      };\n    }\n    if (insertData.columns.length === 0) {\n      return {\n        sql: ''\n      };\n    }\n    sql += `(${this.formatter.columnize(insertData.columns)})`;\n\n    // backwards compatible error\n    if (this.client.valueForUndefined !== null) {\n      insertData.values.forEach(bindings => {\n        each(bindings, binding => {\n          if (binding === undefined) throw new TypeError('`sqlite` does not support inserting default values. Specify ' + 'values explicitly or use the `useNullAsDefault` config flag. ' + '(see docs https://knexjs.org/guide/query-builder.html#insert).');\n        });\n      });\n    }\n    if (insertData.values.length === 1) {\n      const parameters = this.client.parameterize(insertData.values[0], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n      sql += ` values (${parameters})`;\n      const {\n        onConflict,\n        ignore,\n        merge\n      } = this.single;\n      if (onConflict && ignore) sql += this._ignore(onConflict);else if (onConflict && merge) {\n        sql += this._merge(merge.updates, onConflict, insertValues);\n        const wheres = this.where();\n        if (wheres) sql += ` ${wheres}`;\n      }\n      const {\n        returning\n      } = this.single;\n      if (returning) {\n        sql += this._returning(returning);\n      }\n      return {\n        sql,\n        returning\n      };\n    }\n    const blocks = [];\n    let i = -1;\n    while (++i < insertData.values.length) {\n      let i2 = -1;\n      const block = blocks[i] = [];\n      let current = insertData.values[i];\n      current = current === undefined ? this.client.valueForUndefined : current;\n      while (++i2 < insertData.columns.length) {\n        block.push(this.client.alias(this.client.parameter(current[i2], this.builder, this.bindingsHolder), this.formatter.wrap(insertData.columns[i2])));\n      }\n      blocks[i] = block.join(', ');\n    }\n    sql += ' select ' + blocks.join(' union all select ');\n    const {\n      onConflict,\n      ignore,\n      merge\n    } = this.single;\n    if (onConflict && ignore) sql += ' where true' + this._ignore(onConflict);else if (onConflict && merge) {\n      sql += ' where true' + this._merge(merge.updates, onConflict, insertValues);\n    }\n    const {\n      returning\n    } = this.single;\n    if (returning) sql += this._returning(returning);\n    return {\n      sql,\n      returning\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    const withSQL = this.with();\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `update ${this.single.only ? 'only ' : ''}${this.tableName} ` + `set ${updateData.join(', ')}` + (wheres ? ` ${wheres}` : '') + this._returning(returning),\n      returning\n    };\n  }\n  _ignore(columns) {\n    if (columns === true) {\n      return ' on conflict do nothing';\n    }\n    return ` on conflict ${this._onConflictClause(columns)} do nothing`;\n  }\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates.map(column => wrapString(column.split('.').pop(), this.formatter.builder, this.client, this.formatter)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error('If using merge with a raw insert query, then updates must be provided');\n      }\n      sql += insertData.columns.map(column => wrapString(column.split('.').pop(), this.builder, this.client)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    }\n  }\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n\n  // Compile a truncate table statement into SQL.\n  truncate() {\n    const {\n      table\n    } = this.single;\n    return {\n      sql: `delete from ${this.tableName}`,\n      output() {\n        return this.query({\n          sql: `delete from sqlite_sequence where name = '${table}'`\n        }).catch(noop);\n      }\n    };\n  }\n\n  // Compiles a `columnInfo` query\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    return {\n      sql: `PRAGMA table_info(\\`${table}\\`)`,\n      output(resp) {\n        const maxLengthRegex = /.*\\((\\d+)\\)/;\n        const out = reduce(resp, function (columns, val) {\n          let {\n            type\n          } = val;\n          let maxLength = type.match(maxLengthRegex);\n          if (maxLength) {\n            maxLength = maxLength[1];\n          }\n          type = maxLength ? type.split('(')[0] : type;\n          columns[val.name] = {\n            type: type.toLowerCase(),\n            maxLength,\n            nullable: !val.notnull,\n            defaultValue: val.dflt_value\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return '';\n\n    // Workaround for offset only,\n    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit\n    this.single.limit = noLimit ? -1 : this.single.limit;\n    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract('json_extract', params);\n  }\n  jsonSet(params) {\n    return this._jsonSet('json_set', params);\n  }\n  jsonInsert(params) {\n    return this._jsonSet('json_insert', params);\n  }\n  jsonRemove(params) {\n    const jsonCol = `json_remove(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)},${this.client.parameter(params.path, this.builder, this.bindingsHolder)})`;\n    return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;\n  }\n  whereJsonPath(statement) {\n    return this._whereJsonPath('json_extract', statement);\n  }\n  whereJsonSupersetOf(statement) {\n    throw new Error('Json superset where clause not actually supported by SQLite');\n  }\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset where clause not actually supported by SQLite');\n  }\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_extract', clause);\n  }\n}\nmodule.exports = QueryCompiler_SQLite3;","map":{"version":3,"names":["constant","require","each","identity","isEmpty","reduce","QueryCompiler","noop","isString","wrapString","columnize","columnize_","emptyStr","QueryCompiler_SQLite3","constructor","client","builder","formatter","forShare","forKeyShare","forUpdate","forNoKeyUpdate","insert","insertValues","single","sql","with","tableName","Array","isArray","length","_emptyInsertValue","insertData","_prepInsert","columns","valueForUndefined","values","forEach","bindings","binding","undefined","TypeError","parameters","parameterize","bindingsHolder","onConflict","ignore","merge","_ignore","_merge","updates","wheres","where","returning","_returning","blocks","i","i2","block","current","push","alias","parameter","wrap","join","update","withSQL","updateData","_prepUpdate","only","_onConflictClause","map","column","split","pop","Error","value","truncate","table","output","query","catch","columnInfo","customWrapIdentifier","resp","maxLengthRegex","out","val","type","maxLength","match","name","toLowerCase","nullable","notnull","defaultValue","dflt_value","limit","noLimit","offset","_getValueOrParameterFromAttribute","jsonExtract","params","_jsonExtract","jsonSet","_jsonSet","jsonInsert","jsonRemove","jsonCol","path","whereJsonPath","statement","_whereJsonPath","whereJsonSupersetOf","whereJsonSubsetOf","onJsonPathEquals","clause","_onJsonPathEquals","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js"],"sourcesContent":["// SQLite3 Query Builder & Compiler\n\nconst constant = require('lodash/constant');\nconst each = require('lodash/each');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\nconst noop = require('../../../util/noop');\nconst { isString } = require('../../../util/is');\nconst {\n  wrapString,\n  columnize: columnize_,\n} = require('../../../formatter/wrappingFormatter');\n\nconst emptyStr = constant('');\n\nclass QueryCompiler_SQLite3 extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    // The locks are not applicable in SQLite3\n    this.forShare = emptyStr;\n    this.forKeyShare = emptyStr;\n    this.forUpdate = emptyStr;\n    this.forNoKeyUpdate = emptyStr;\n  }\n\n  // SQLite requires us to build the multi-row insert as a listing of select with\n  // unions joining them together. So we'll build out this list of columns and\n  // then join them all together with select unions to complete the queries.\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      } else if (\n        insertValues.length === 1 &&\n        insertValues[0] &&\n        isEmpty(insertValues[0])\n      ) {\n        return {\n          sql: sql + this._emptyInsertValue,\n        };\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + this._emptyInsertValue,\n      };\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (isString(insertData)) {\n      return {\n        sql: sql + insertData,\n      };\n    }\n\n    if (insertData.columns.length === 0) {\n      return {\n        sql: '',\n      };\n    }\n\n    sql += `(${this.formatter.columnize(insertData.columns)})`;\n\n    // backwards compatible error\n    if (this.client.valueForUndefined !== null) {\n      insertData.values.forEach((bindings) => {\n        each(bindings, (binding) => {\n          if (binding === undefined)\n            throw new TypeError(\n              '`sqlite` does not support inserting default values. Specify ' +\n                'values explicitly or use the `useNullAsDefault` config flag. ' +\n                '(see docs https://knexjs.org/guide/query-builder.html#insert).'\n            );\n        });\n      });\n    }\n\n    if (insertData.values.length === 1) {\n      const parameters = this.client.parameterize(\n        insertData.values[0],\n        this.client.valueForUndefined,\n        this.builder,\n        this.bindingsHolder\n      );\n      sql += ` values (${parameters})`;\n\n      const { onConflict, ignore, merge } = this.single;\n      if (onConflict && ignore) sql += this._ignore(onConflict);\n      else if (onConflict && merge) {\n        sql += this._merge(merge.updates, onConflict, insertValues);\n        const wheres = this.where();\n        if (wheres) sql += ` ${wheres}`;\n      }\n\n      const { returning } = this.single;\n      if (returning) {\n        sql += this._returning(returning);\n      }\n\n      return {\n        sql,\n        returning,\n      };\n    }\n\n    const blocks = [];\n    let i = -1;\n    while (++i < insertData.values.length) {\n      let i2 = -1;\n      const block = (blocks[i] = []);\n      let current = insertData.values[i];\n      current = current === undefined ? this.client.valueForUndefined : current;\n      while (++i2 < insertData.columns.length) {\n        block.push(\n          this.client.alias(\n            this.client.parameter(\n              current[i2],\n              this.builder,\n              this.bindingsHolder\n            ),\n            this.formatter.wrap(insertData.columns[i2])\n          )\n        );\n      }\n      blocks[i] = block.join(', ');\n    }\n    sql += ' select ' + blocks.join(' union all select ');\n\n    const { onConflict, ignore, merge } = this.single;\n    if (onConflict && ignore) sql += ' where true' + this._ignore(onConflict);\n    else if (onConflict && merge) {\n      sql +=\n        ' where true' + this._merge(merge.updates, onConflict, insertValues);\n    }\n\n    const { returning } = this.single;\n    if (returning) sql += this._returning(returning);\n\n    return {\n      sql,\n      returning,\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    const withSQL = this.with();\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `update ${this.single.only ? 'only ' : ''}${this.tableName} ` +\n        `set ${updateData.join(', ')}` +\n        (wheres ? ` ${wheres}` : '') +\n        this._returning(returning),\n      returning,\n    };\n  }\n\n  _ignore(columns) {\n    if (columns === true) {\n      return ' on conflict do nothing';\n    }\n    return ` on conflict ${this._onConflictClause(columns)} do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict ${this._onConflictClause(columns)} do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates\n        .map((column) =>\n          wrapString(\n            column.split('.').pop(),\n            this.formatter.builder,\n            this.client,\n            this.formatter\n          )\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error(\n          'If using merge with a raw insert query, then updates must be provided'\n        );\n      }\n\n      sql += insertData.columns\n        .map((column) =>\n          wrapString(column.split('.').pop(), this.builder, this.client)\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    }\n  }\n\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n\n  // Compile a truncate table statement into SQL.\n  truncate() {\n    const { table } = this.single;\n    return {\n      sql: `delete from ${this.tableName}`,\n      output() {\n        return this.query({\n          sql: `delete from sqlite_sequence where name = '${table}'`,\n        }).catch(noop);\n      },\n    };\n  }\n\n  // Compiles a `columnInfo` query\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    return {\n      sql: `PRAGMA table_info(\\`${table}\\`)`,\n      output(resp) {\n        const maxLengthRegex = /.*\\((\\d+)\\)/;\n        const out = reduce(\n          resp,\n          function (columns, val) {\n            let { type } = val;\n            let maxLength = type.match(maxLengthRegex);\n            if (maxLength) {\n              maxLength = maxLength[1];\n            }\n            type = maxLength ? type.split('(')[0] : type;\n            columns[val.name] = {\n              type: type.toLowerCase(),\n              maxLength,\n              nullable: !val.notnull,\n              defaultValue: val.dflt_value,\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return '';\n\n    // Workaround for offset only,\n    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit\n    this.single.limit = noLimit ? -1 : this.single.limit;\n    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract('json_extract', params);\n  }\n\n  jsonSet(params) {\n    return this._jsonSet('json_set', params);\n  }\n\n  jsonInsert(params) {\n    return this._jsonSet('json_insert', params);\n  }\n\n  jsonRemove(params) {\n    const jsonCol = `json_remove(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )},${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n    return params.alias\n      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))\n      : jsonCol;\n  }\n\n  whereJsonPath(statement) {\n    return this._whereJsonPath('json_extract', statement);\n  }\n\n  whereJsonSupersetOf(statement) {\n    throw new Error(\n      'Json superset where clause not actually supported by SQLite'\n    );\n  }\n\n  whereJsonSubsetOf(statement) {\n    throw new Error(\n      'Json subset where clause not actually supported by SQLite'\n    );\n  }\n\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_extract', clause);\n  }\n}\n\nmodule.exports = QueryCompiler_SQLite3;\n"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMC,IAAI,GAAGD,OAAO,CAAC,aAAa,CAAC;AACnC,MAAME,QAAQ,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMG,OAAO,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAMI,MAAM,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAEvC,MAAMK,aAAa,GAAGL,OAAO,CAAC,8BAA8B,CAAC;AAC7D,MAAMM,IAAI,GAAGN,OAAO,CAAC,oBAAoB,CAAC;AAC1C,MAAM;EAAEO;AAAS,CAAC,GAAGP,OAAO,CAAC,kBAAkB,CAAC;AAChD,MAAM;EACJQ,UAAU;EACVC,SAAS,EAAEC;AACb,CAAC,GAAGV,OAAO,CAAC,sCAAsC,CAAC;AAEnD,MAAMW,QAAQ,GAAGZ,QAAQ,CAAC,EAAE,CAAC;AAE7B,MAAMa,qBAAqB,SAASP,aAAa,CAAC;EAChDQ,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAEC,SAAS,EAAE;IACtC,KAAK,CAACF,MAAM,EAAEC,OAAO,EAAEC,SAAS,CAAC;;IAEjC;IACA,IAAI,CAACC,QAAQ,GAAGN,QAAQ;IACxB,IAAI,CAACO,WAAW,GAAGP,QAAQ;IAC3B,IAAI,CAACQ,SAAS,GAAGR,QAAQ;IACzB,IAAI,CAACS,cAAc,GAAGT,QAAQ;EAChC;;EAEA;EACA;EACA;EACAU,MAAMA,CAAA,EAAG;IACP,MAAMC,YAAY,GAAG,IAAI,CAACC,MAAM,CAACF,MAAM,IAAI,EAAE;IAC7C,IAAIG,GAAG,GAAG,IAAI,CAACC,IAAI,CAAC,CAAC,GAAG,eAAe,IAAI,CAACC,SAAS,GAAG;IAExD,IAAIC,KAAK,CAACC,OAAO,CAACN,YAAY,CAAC,EAAE;MAC/B,IAAIA,YAAY,CAACO,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,EAAE;MACX,CAAC,MAAM,IACLP,YAAY,CAACO,MAAM,KAAK,CAAC,IACzBP,YAAY,CAAC,CAAC,CAAC,IACfnB,OAAO,CAACmB,YAAY,CAAC,CAAC,CAAC,CAAC,EACxB;QACA,OAAO;UACLE,GAAG,EAAEA,GAAG,GAAG,IAAI,CAACM;QAClB,CAAC;MACH;IACF,CAAC,MAAM,IAAI,OAAOR,YAAY,KAAK,QAAQ,IAAInB,OAAO,CAACmB,YAAY,CAAC,EAAE;MACpE,OAAO;QACLE,GAAG,EAAEA,GAAG,GAAG,IAAI,CAACM;MAClB,CAAC;IACH;IAEA,MAAMC,UAAU,GAAG,IAAI,CAACC,WAAW,CAACV,YAAY,CAAC;IAEjD,IAAIf,QAAQ,CAACwB,UAAU,CAAC,EAAE;MACxB,OAAO;QACLP,GAAG,EAAEA,GAAG,GAAGO;MACb,CAAC;IACH;IAEA,IAAIA,UAAU,CAACE,OAAO,CAACJ,MAAM,KAAK,CAAC,EAAE;MACnC,OAAO;QACLL,GAAG,EAAE;MACP,CAAC;IACH;IAEAA,GAAG,IAAI,IAAI,IAAI,CAACR,SAAS,CAACP,SAAS,CAACsB,UAAU,CAACE,OAAO,CAAC,GAAG;;IAE1D;IACA,IAAI,IAAI,CAACnB,MAAM,CAACoB,iBAAiB,KAAK,IAAI,EAAE;MAC1CH,UAAU,CAACI,MAAM,CAACC,OAAO,CAAEC,QAAQ,IAAK;QACtCpC,IAAI,CAACoC,QAAQ,EAAGC,OAAO,IAAK;UAC1B,IAAIA,OAAO,KAAKC,SAAS,EACvB,MAAM,IAAIC,SAAS,CACjB,8DAA8D,GAC5D,+DAA+D,GAC/D,gEACJ,CAAC;QACL,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IAEA,IAAIT,UAAU,CAACI,MAAM,CAACN,MAAM,KAAK,CAAC,EAAE;MAClC,MAAMY,UAAU,GAAG,IAAI,CAAC3B,MAAM,CAAC4B,YAAY,CACzCX,UAAU,CAACI,MAAM,CAAC,CAAC,CAAC,EACpB,IAAI,CAACrB,MAAM,CAACoB,iBAAiB,EAC7B,IAAI,CAACnB,OAAO,EACZ,IAAI,CAAC4B,cACP,CAAC;MACDnB,GAAG,IAAI,YAAYiB,UAAU,GAAG;MAEhC,MAAM;QAAEG,UAAU;QAAEC,MAAM;QAAEC;MAAM,CAAC,GAAG,IAAI,CAACvB,MAAM;MACjD,IAAIqB,UAAU,IAAIC,MAAM,EAAErB,GAAG,IAAI,IAAI,CAACuB,OAAO,CAACH,UAAU,CAAC,CAAC,KACrD,IAAIA,UAAU,IAAIE,KAAK,EAAE;QAC5BtB,GAAG,IAAI,IAAI,CAACwB,MAAM,CAACF,KAAK,CAACG,OAAO,EAAEL,UAAU,EAAEtB,YAAY,CAAC;QAC3D,MAAM4B,MAAM,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;QAC3B,IAAID,MAAM,EAAE1B,GAAG,IAAI,IAAI0B,MAAM,EAAE;MACjC;MAEA,MAAM;QAAEE;MAAU,CAAC,GAAG,IAAI,CAAC7B,MAAM;MACjC,IAAI6B,SAAS,EAAE;QACb5B,GAAG,IAAI,IAAI,CAAC6B,UAAU,CAACD,SAAS,CAAC;MACnC;MAEA,OAAO;QACL5B,GAAG;QACH4B;MACF,CAAC;IACH;IAEA,MAAME,MAAM,GAAG,EAAE;IACjB,IAAIC,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,EAAEA,CAAC,GAAGxB,UAAU,CAACI,MAAM,CAACN,MAAM,EAAE;MACrC,IAAI2B,EAAE,GAAG,CAAC,CAAC;MACX,MAAMC,KAAK,GAAIH,MAAM,CAACC,CAAC,CAAC,GAAG,EAAG;MAC9B,IAAIG,OAAO,GAAG3B,UAAU,CAACI,MAAM,CAACoB,CAAC,CAAC;MAClCG,OAAO,GAAGA,OAAO,KAAKnB,SAAS,GAAG,IAAI,CAACzB,MAAM,CAACoB,iBAAiB,GAAGwB,OAAO;MACzE,OAAO,EAAEF,EAAE,GAAGzB,UAAU,CAACE,OAAO,CAACJ,MAAM,EAAE;QACvC4B,KAAK,CAACE,IAAI,CACR,IAAI,CAAC7C,MAAM,CAAC8C,KAAK,CACf,IAAI,CAAC9C,MAAM,CAAC+C,SAAS,CACnBH,OAAO,CAACF,EAAE,CAAC,EACX,IAAI,CAACzC,OAAO,EACZ,IAAI,CAAC4B,cACP,CAAC,EACD,IAAI,CAAC3B,SAAS,CAAC8C,IAAI,CAAC/B,UAAU,CAACE,OAAO,CAACuB,EAAE,CAAC,CAC5C,CACF,CAAC;MACH;MACAF,MAAM,CAACC,CAAC,CAAC,GAAGE,KAAK,CAACM,IAAI,CAAC,IAAI,CAAC;IAC9B;IACAvC,GAAG,IAAI,UAAU,GAAG8B,MAAM,CAACS,IAAI,CAAC,oBAAoB,CAAC;IAErD,MAAM;MAAEnB,UAAU;MAAEC,MAAM;MAAEC;IAAM,CAAC,GAAG,IAAI,CAACvB,MAAM;IACjD,IAAIqB,UAAU,IAAIC,MAAM,EAAErB,GAAG,IAAI,aAAa,GAAG,IAAI,CAACuB,OAAO,CAACH,UAAU,CAAC,CAAC,KACrE,IAAIA,UAAU,IAAIE,KAAK,EAAE;MAC5BtB,GAAG,IACD,aAAa,GAAG,IAAI,CAACwB,MAAM,CAACF,KAAK,CAACG,OAAO,EAAEL,UAAU,EAAEtB,YAAY,CAAC;IACxE;IAEA,MAAM;MAAE8B;IAAU,CAAC,GAAG,IAAI,CAAC7B,MAAM;IACjC,IAAI6B,SAAS,EAAE5B,GAAG,IAAI,IAAI,CAAC6B,UAAU,CAACD,SAAS,CAAC;IAEhD,OAAO;MACL5B,GAAG;MACH4B;IACF,CAAC;EACH;;EAEA;EACAY,MAAMA,CAAA,EAAG;IACP,MAAMC,OAAO,GAAG,IAAI,CAACxC,IAAI,CAAC,CAAC;IAC3B,MAAMyC,UAAU,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC5C,MAAM,CAACyC,MAAM,CAAC;IACvD,MAAMd,MAAM,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;IAC3B,MAAM;MAAEC;IAAU,CAAC,GAAG,IAAI,CAAC7B,MAAM;IACjC,OAAO;MACLC,GAAG,EACDyC,OAAO,GACP,UAAU,IAAI,CAAC1C,MAAM,CAAC6C,IAAI,GAAG,OAAO,GAAG,EAAE,GAAG,IAAI,CAAC1C,SAAS,GAAG,GAC7D,OAAOwC,UAAU,CAACH,IAAI,CAAC,IAAI,CAAC,EAAE,IAC7Bb,MAAM,GAAG,IAAIA,MAAM,EAAE,GAAG,EAAE,CAAC,GAC5B,IAAI,CAACG,UAAU,CAACD,SAAS,CAAC;MAC5BA;IACF,CAAC;EACH;EAEAL,OAAOA,CAACd,OAAO,EAAE;IACf,IAAIA,OAAO,KAAK,IAAI,EAAE;MACpB,OAAO,yBAAyB;IAClC;IACA,OAAO,gBAAgB,IAAI,CAACoC,iBAAiB,CAACpC,OAAO,CAAC,aAAa;EACrE;EAEAe,MAAMA,CAACC,OAAO,EAAEhB,OAAO,EAAEZ,MAAM,EAAE;IAC/B,IAAIG,GAAG,GAAG,gBAAgB,IAAI,CAAC6C,iBAAiB,CAACpC,OAAO,CAAC,iBAAiB;IAC1E,IAAIgB,OAAO,IAAItB,KAAK,CAACC,OAAO,CAACqB,OAAO,CAAC,EAAE;MACrCzB,GAAG,IAAIyB,OAAO,CACXqB,GAAG,CAAEC,MAAM,IACV/D,UAAU,CACR+D,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,EACvB,IAAI,CAACzD,SAAS,CAACD,OAAO,EACtB,IAAI,CAACD,MAAM,EACX,IAAI,CAACE,SACP,CACF,CAAC,CACAsD,GAAG,CAAEC,MAAM,IAAK,GAAGA,MAAM,eAAeA,MAAM,EAAE,CAAC,CACjDR,IAAI,CAAC,IAAI,CAAC;MAEb,OAAOvC,GAAG;IACZ,CAAC,MAAM,IAAIyB,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MACjD,MAAMiB,UAAU,GAAG,IAAI,CAACC,WAAW,CAAClB,OAAO,CAAC;MAC5C,IAAI,OAAOiB,UAAU,KAAK,QAAQ,EAAE;QAClC1C,GAAG,IAAI0C,UAAU;MACnB,CAAC,MAAM;QACL1C,GAAG,IAAI0C,UAAU,CAACH,IAAI,CAAC,GAAG,CAAC;MAC7B;MAEA,OAAOvC,GAAG;IACZ,CAAC,MAAM;MACL,MAAMO,UAAU,GAAG,IAAI,CAACC,WAAW,CAACX,MAAM,CAAC;MAC3C,IAAI,OAAOU,UAAU,KAAK,QAAQ,EAAE;QAClC,MAAM,IAAI2C,KAAK,CACb,uEACF,CAAC;MACH;MAEAlD,GAAG,IAAIO,UAAU,CAACE,OAAO,CACtBqC,GAAG,CAAEC,MAAM,IACV/D,UAAU,CAAC+D,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC1D,OAAO,EAAE,IAAI,CAACD,MAAM,CAC/D,CAAC,CACAwD,GAAG,CAAEC,MAAM,IAAK,GAAGA,MAAM,eAAeA,MAAM,EAAE,CAAC,CACjDR,IAAI,CAAC,IAAI,CAAC;MAEb,OAAOvC,GAAG;IACZ;EACF;EAEA6B,UAAUA,CAACsB,KAAK,EAAE;IAChB,OAAOA,KAAK,GAAG,cAAc,IAAI,CAAC3D,SAAS,CAACP,SAAS,CAACkE,KAAK,CAAC,EAAE,GAAG,EAAE;EACrE;;EAEA;EACAC,QAAQA,CAAA,EAAG;IACT,MAAM;MAAEC;IAAM,CAAC,GAAG,IAAI,CAACtD,MAAM;IAC7B,OAAO;MACLC,GAAG,EAAE,eAAe,IAAI,CAACE,SAAS,EAAE;MACpCoD,MAAMA,CAAA,EAAG;QACP,OAAO,IAAI,CAACC,KAAK,CAAC;UAChBvD,GAAG,EAAE,6CAA6CqD,KAAK;QACzD,CAAC,CAAC,CAACG,KAAK,CAAC1E,IAAI,CAAC;MAChB;IACF,CAAC;EACH;;EAEA;EACA2E,UAAUA,CAAA,EAAG;IACX,MAAMV,MAAM,GAAG,IAAI,CAAChD,MAAM,CAAC0D,UAAU;;IAErC;IACA;IACA;IACA,MAAMJ,KAAK,GAAG,IAAI,CAAC/D,MAAM,CAACoE,oBAAoB,CAAC,IAAI,CAAC3D,MAAM,CAACsD,KAAK,EAAE3E,QAAQ,CAAC;IAE3E,OAAO;MACLsB,GAAG,EAAE,uBAAuBqD,KAAK,KAAK;MACtCC,MAAMA,CAACK,IAAI,EAAE;QACX,MAAMC,cAAc,GAAG,aAAa;QACpC,MAAMC,GAAG,GAAGjF,MAAM,CAChB+E,IAAI,EACJ,UAAUlD,OAAO,EAAEqD,GAAG,EAAE;UACtB,IAAI;YAAEC;UAAK,CAAC,GAAGD,GAAG;UAClB,IAAIE,SAAS,GAAGD,IAAI,CAACE,KAAK,CAACL,cAAc,CAAC;UAC1C,IAAII,SAAS,EAAE;YACbA,SAAS,GAAGA,SAAS,CAAC,CAAC,CAAC;UAC1B;UACAD,IAAI,GAAGC,SAAS,GAAGD,IAAI,CAACf,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGe,IAAI;UAC5CtD,OAAO,CAACqD,GAAG,CAACI,IAAI,CAAC,GAAG;YAClBH,IAAI,EAAEA,IAAI,CAACI,WAAW,CAAC,CAAC;YACxBH,SAAS;YACTI,QAAQ,EAAE,CAACN,GAAG,CAACO,OAAO;YACtBC,YAAY,EAAER,GAAG,CAACS;UACpB,CAAC;UACD,OAAO9D,OAAO;QAChB,CAAC,EACD,CAAC,CACH,CAAC;QACD,OAAQsC,MAAM,IAAIc,GAAG,CAACd,MAAM,CAAC,IAAKc,GAAG;MACvC;IACF,CAAC;EACH;EAEAW,KAAKA,CAAA,EAAG;IACN,MAAMC,OAAO,GAAG,CAAC,IAAI,CAAC1E,MAAM,CAACyE,KAAK,IAAI,IAAI,CAACzE,MAAM,CAACyE,KAAK,KAAK,CAAC;IAC7D,IAAIC,OAAO,IAAI,CAAC,IAAI,CAAC1E,MAAM,CAAC2E,MAAM,EAAE,OAAO,EAAE;;IAE7C;IACA;IACA,IAAI,CAAC3E,MAAM,CAACyE,KAAK,GAAGC,OAAO,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC1E,MAAM,CAACyE,KAAK;IACpD,OAAO,SAAS,IAAI,CAACG,iCAAiC,CAAC,OAAO,CAAC,EAAE;EACnE;;EAEA;EACAC,WAAWA,CAACC,MAAM,EAAE;IAClB,OAAO,IAAI,CAACC,YAAY,CAAC,cAAc,EAAED,MAAM,CAAC;EAClD;EAEAE,OAAOA,CAACF,MAAM,EAAE;IACd,OAAO,IAAI,CAACG,QAAQ,CAAC,UAAU,EAAEH,MAAM,CAAC;EAC1C;EAEAI,UAAUA,CAACJ,MAAM,EAAE;IACjB,OAAO,IAAI,CAACG,QAAQ,CAAC,aAAa,EAAEH,MAAM,CAAC;EAC7C;EAEAK,UAAUA,CAACL,MAAM,EAAE;IACjB,MAAMM,OAAO,GAAG,eAAejG,UAAU,CACvC2F,MAAM,CAAC9B,MAAM,EACb,IAAI,CAACxD,OAAO,EACZ,IAAI,CAACD,MAAM,EACX,IAAI,CAAC6B,cACP,CAAC,IAAI,IAAI,CAAC7B,MAAM,CAAC+C,SAAS,CACxBwC,MAAM,CAACO,IAAI,EACX,IAAI,CAAC7F,OAAO,EACZ,IAAI,CAAC4B,cACP,CAAC,GAAG;IACJ,OAAO0D,MAAM,CAACzC,KAAK,GACf,IAAI,CAAC9C,MAAM,CAAC8C,KAAK,CAAC+C,OAAO,EAAE,IAAI,CAAC3F,SAAS,CAAC8C,IAAI,CAACuC,MAAM,CAACzC,KAAK,CAAC,CAAC,GAC7D+C,OAAO;EACb;EAEAE,aAAaA,CAACC,SAAS,EAAE;IACvB,OAAO,IAAI,CAACC,cAAc,CAAC,cAAc,EAAED,SAAS,CAAC;EACvD;EAEAE,mBAAmBA,CAACF,SAAS,EAAE;IAC7B,MAAM,IAAIpC,KAAK,CACb,6DACF,CAAC;EACH;EAEAuC,iBAAiBA,CAACH,SAAS,EAAE;IAC3B,MAAM,IAAIpC,KAAK,CACb,2DACF,CAAC;EACH;EAEAwC,gBAAgBA,CAACC,MAAM,EAAE;IACvB,OAAO,IAAI,CAACC,iBAAiB,CAAC,cAAc,EAAED,MAAM,CAAC;EACvD;AACF;AAEAE,MAAM,CAACC,OAAO,GAAG1G,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}