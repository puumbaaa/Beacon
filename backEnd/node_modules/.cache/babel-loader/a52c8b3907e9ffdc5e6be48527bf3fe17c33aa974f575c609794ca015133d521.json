{"ast":null,"code":"const QueryCompiler_PG = require('../postgres/query/pg-querycompiler');\nconst {\n  columnize: columnize_,\n  wrap: wrap_,\n  operator: operator_\n} = require('../../formatter/wrappingFormatter');\nclass QueryCompiler_CRDB extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName}`;\n  }\n  upsert() {\n    let sql = this._upsert();\n    if (sql === '') return sql;\n    const {\n      returning\n    } = this.single;\n    if (returning) sql += this._returning(returning);\n    return {\n      sql: sql,\n      returning\n    };\n  }\n  _upsert() {\n    const upsertValues = this.single.upsert || [];\n    const sql = this.with() + `upsert into ${this.tableName} `;\n    const body = this._insertBody(upsertValues);\n    return body === '' ? '' : sql + body;\n  }\n  _groupOrder(item, type) {\n    // CockroachDB don't support PostgreSQL order nulls first/last syntax, we take the generic one.\n    return this._basicGroupOrder(item, type);\n  }\n  whereJsonPath(statement) {\n    let castValue = '';\n    if (!isNaN(statement.value) && parseInt(statement.value)) {\n      castValue = '::int';\n    } else if (!isNaN(statement.value) && parseFloat(statement.value)) {\n      castValue = '::float';\n    } else {\n      castValue = \" #>> '{}'\";\n    }\n    return `json_extract_path(${this._columnClause(statement)}, ${this.client.toArrayPathFromJsonPath(statement.jsonPath, this.builder, this.bindingsHolder)})${castValue} ${operator_(statement.operator, this.builder, this.client, this.bindingsHolder)} ${this._jsonValueClause(statement)}`;\n  }\n\n  // Json common functions\n  _jsonExtract(nameFunction, params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    return extractions.map(extraction => {\n      const jsonCol = `json_extract_path(${columnize_(extraction.column || extraction[0], this.builder, this.client, this.bindingsHolder)}, ${this.client.toArrayPathFromJsonPath(extraction.path || extraction[1], this.builder, this.bindingsHolder)})`;\n      const alias = extraction.alias || extraction[2];\n      return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;\n    }).join(', ');\n  }\n  _onJsonPathEquals(nameJoinFunction, clause) {\n    return 'json_extract_path(' + wrap_(clause.columnFirst, undefined, this.builder, this.client, this.bindingsHolder) + ', ' + this.client.toArrayPathFromJsonPath(clause.jsonPathFirst, this.builder, this.bindingsHolder) + ') = json_extract_path(' + wrap_(clause.columnSecond, undefined, this.builder, this.client, this.bindingsHolder) + ', ' + this.client.toArrayPathFromJsonPath(clause.jsonPathSecond, this.builder, this.bindingsHolder) + ')';\n  }\n}\nmodule.exports = QueryCompiler_CRDB;","map":{"version":3,"names":["QueryCompiler_PG","require","columnize","columnize_","wrap","wrap_","operator","operator_","QueryCompiler_CRDB","truncate","tableName","upsert","sql","_upsert","returning","single","_returning","upsertValues","with","body","_insertBody","_groupOrder","item","type","_basicGroupOrder","whereJsonPath","statement","castValue","isNaN","value","parseInt","parseFloat","_columnClause","client","toArrayPathFromJsonPath","jsonPath","builder","bindingsHolder","_jsonValueClause","_jsonExtract","nameFunction","params","extractions","Array","isArray","column","map","extraction","jsonCol","path","alias","formatter","join","_onJsonPathEquals","nameJoinFunction","clause","columnFirst","undefined","jsonPathFirst","columnSecond","jsonPathSecond","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/cockroachdb/crdb-querycompiler.js"],"sourcesContent":["const QueryCompiler_PG = require('../postgres/query/pg-querycompiler');\nconst {\n  columnize: columnize_,\n  wrap: wrap_,\n  operator: operator_,\n} = require('../../formatter/wrappingFormatter');\n\nclass QueryCompiler_CRDB extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName}`;\n  }\n\n  upsert() {\n    let sql = this._upsert();\n    if (sql === '') return sql;\n    const { returning } = this.single;\n    if (returning) sql += this._returning(returning);\n    return {\n      sql: sql,\n      returning,\n    };\n  }\n\n  _upsert() {\n    const upsertValues = this.single.upsert || [];\n    const sql = this.with() + `upsert into ${this.tableName} `;\n    const body = this._insertBody(upsertValues);\n    return body === '' ? '' : sql + body;\n  }\n\n  _groupOrder(item, type) {\n    // CockroachDB don't support PostgreSQL order nulls first/last syntax, we take the generic one.\n    return this._basicGroupOrder(item, type);\n  }\n\n  whereJsonPath(statement) {\n    let castValue = '';\n    if (!isNaN(statement.value) && parseInt(statement.value)) {\n      castValue = '::int';\n    } else if (!isNaN(statement.value) && parseFloat(statement.value)) {\n      castValue = '::float';\n    } else {\n      castValue = \" #>> '{}'\";\n    }\n    return `json_extract_path(${this._columnClause(\n      statement\n    )}, ${this.client.toArrayPathFromJsonPath(\n      statement.jsonPath,\n      this.builder,\n      this.bindingsHolder\n    )})${castValue} ${operator_(\n      statement.operator,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )} ${this._jsonValueClause(statement)}`;\n  }\n\n  // Json common functions\n  _jsonExtract(nameFunction, params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    return extractions\n      .map((extraction) => {\n        const jsonCol = `json_extract_path(${columnize_(\n          extraction.column || extraction[0],\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )}, ${this.client.toArrayPathFromJsonPath(\n          extraction.path || extraction[1],\n          this.builder,\n          this.bindingsHolder\n        )})`;\n        const alias = extraction.alias || extraction[2];\n        return alias\n          ? this.client.alias(jsonCol, this.formatter.wrap(alias))\n          : jsonCol;\n      })\n      .join(', ');\n  }\n\n  _onJsonPathEquals(nameJoinFunction, clause) {\n    return (\n      'json_extract_path(' +\n      wrap_(\n        clause.columnFirst,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ', ' +\n      this.client.toArrayPathFromJsonPath(\n        clause.jsonPathFirst,\n        this.builder,\n        this.bindingsHolder\n      ) +\n      ') = json_extract_path(' +\n      wrap_(\n        clause.columnSecond,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ', ' +\n      this.client.toArrayPathFromJsonPath(\n        clause.jsonPathSecond,\n        this.builder,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n}\n\nmodule.exports = QueryCompiler_CRDB;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}