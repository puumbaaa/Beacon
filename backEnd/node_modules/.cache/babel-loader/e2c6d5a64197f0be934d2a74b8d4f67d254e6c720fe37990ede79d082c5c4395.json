{"ast":null,"code":"// Oracledb Client\n// -------\nconst each = require('lodash/each');\nconst flatten = require('lodash/flatten');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\nconst Formatter = require('../../formatter');\nconst QueryCompiler = require('./query/oracledb-querycompiler');\nconst TableCompiler = require('./schema/oracledb-tablecompiler');\nconst ColumnCompiler = require('./schema/oracledb-columncompiler');\nconst {\n  BlobHelper,\n  ReturningHelper,\n  monkeyPatchConnection\n} = require('./utils');\nconst ViewCompiler = require('./schema/oracledb-viewcompiler');\nconst ViewBuilder = require('./schema/oracledb-viewbuilder');\nconst Transaction = require('./transaction');\nconst Client_Oracle = require('../oracle');\nconst {\n  isString\n} = require('../../util/is');\nconst {\n  outputQuery,\n  unwrapRaw\n} = require('../../formatter/wrappingFormatter');\nconst {\n  compileCallback\n} = require('../../formatter/formatterUtils');\nclass Client_Oracledb extends Client_Oracle {\n  constructor(config) {\n    super(config);\n    if (this.version) {\n      // Normalize version format; null bad format\n      // to trigger fallback to auto-detect.\n      this.version = parseVersion(this.version);\n    }\n    if (this.driver) {\n      process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;\n      process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;\n    }\n  }\n  _driver() {\n    const client = this;\n    const oracledb = require('oracledb');\n    client.fetchAsString = [];\n    if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {\n      this.config.fetchAsString.forEach(function (type) {\n        if (!isString(type)) return;\n        type = type.toUpperCase();\n        if (oracledb[type]) {\n          if (type !== 'NUMBER' && type !== 'DATE' && type !== 'CLOB' && type !== 'BUFFER') {\n            this.logger.warn('Only \"date\", \"number\", \"clob\" and \"buffer\" are supported for fetchAsString');\n          }\n          client.fetchAsString.push(oracledb[type]);\n        }\n      });\n    }\n    return oracledb;\n  }\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n  viewBuilder() {\n    return new ViewBuilder(this, ...arguments);\n  }\n  viewCompiler() {\n    return new ViewCompiler(this, ...arguments);\n  }\n  formatter(builder) {\n    return new Formatter(this, builder);\n  }\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n  prepBindings(bindings) {\n    return map(bindings, value => {\n      if (value instanceof BlobHelper && this.driver) {\n        return {\n          type: this.driver.BLOB,\n          dir: this.driver.BIND_OUT\n        };\n        // Returning helper always use ROWID as string\n      } else if (value instanceof ReturningHelper && this.driver) {\n        return {\n          type: this.driver.STRING,\n          dir: this.driver.BIND_OUT\n        };\n      } else if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      return value;\n    });\n  }\n\n  // Checks whether a value is a function... if it is, we compile it\n  // otherwise we check whether it's a raw\n  parameter(value, builder, formatter) {\n    if (typeof value === 'function') {\n      return outputQuery(compileCallback(value, undefined, this, formatter), true, builder, this);\n    } else if (value instanceof BlobHelper) {\n      formatter.bindings.push(value.value);\n      return '?';\n    }\n    return unwrapRaw(value, true, builder, this, formatter) || '?';\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    return new Promise((resolver, rejecter) => {\n      // If external authentication don't have to worry about username/password and\n      // if not need to set the username and password\n      const oracleDbConfig = this.connectionSettings.externalAuth ? {\n        externalAuth: this.connectionSettings.externalAuth\n      } : {\n        user: this.connectionSettings.user,\n        password: this.connectionSettings.password\n      };\n\n      // In the case of external authentication connection string will be given\n      oracleDbConfig.connectString = resolveConnectString(this.connectionSettings);\n      if (this.connectionSettings.prefetchRowCount) {\n        oracleDbConfig.prefetchRows = this.connectionSettings.prefetchRowCount;\n      }\n      if (this.connectionSettings.stmtCacheSize !== undefined) {\n        oracleDbConfig.stmtCacheSize = this.connectionSettings.stmtCacheSize;\n      }\n      this.driver.fetchAsString = this.fetchAsString;\n      this.driver.getConnection(oracleDbConfig, (err, connection) => {\n        if (err) {\n          return rejecter(err);\n        }\n        monkeyPatchConnection(connection, this);\n        resolver(connection);\n      });\n    });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection(connection) {\n    return connection.release();\n  }\n\n  // Handle oracle version resolution on acquiring connection from pool instead of connection creation.\n  // Must do this here since only the client used to create a connection would be updated with version\n  // information on creation. Poses a problem when knex instance is cloned since instances share the\n  // connection pool while having their own client instances.\n  async acquireConnection() {\n    const connection = await super.acquireConnection();\n    this.checkVersion(connection);\n    return connection;\n  }\n\n  // In Oracle, we need to check the version to dynamically determine\n  // certain limits. If user did not specify a version, get it from the connection.\n  checkVersion(connection) {\n    // Already determined version before?\n    if (this.version) {\n      return this.version;\n    }\n    const detectedVersion = parseVersion(connection.oracleServerVersionString);\n    if (!detectedVersion) {\n      // When original version is set to null, user-provided version was invalid and we fell-back to auto-detect.\n      // Otherwise, we couldn't auto-detect at all. Set error message accordingly.\n      throw new Error(this.version === null ? 'Invalid Oracledb version number format passed to knex. Unable to successfully auto-detect as fallback. Please specify a valid oracledb version.' : 'Unable to detect Oracledb version number automatically. Please specify the version in knex configuration.');\n    }\n    this.version = detectedVersion;\n    return detectedVersion;\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n    const options = Object.assign({}, obj.options, {\n      autoCommit: false\n    });\n    if (obj.method === 'select') {\n      options.resultSet = true;\n    }\n    return connection.executeAsync(obj.sql, obj.bindings, options).then(async function (response) {\n      // Flatten outBinds\n      let outBinds = flatten(response.outBinds);\n      obj.response = response.rows || [];\n      obj.rowsAffected = response.rows ? response.rows.rowsAffected : response.rowsAffected;\n\n      //added for outBind parameter\n      if (obj.method === 'raw' && outBinds.length > 0) {\n        return {\n          response: outBinds\n        };\n      }\n      if (obj.method === 'update') {\n        const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;\n        const updatedObjOutBinding = [];\n        const updatedOutBinds = [];\n        const updateOutBinds = i => function (value, index) {\n          const OutBindsOffset = index * modifiedRowsCount;\n          updatedOutBinds.push(outBinds[i + OutBindsOffset]);\n        };\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          updatedObjOutBinding.push(obj.outBinding[0]);\n          each(obj.outBinding[0], updateOutBinds(i));\n        }\n        outBinds = updatedOutBinds;\n        obj.outBinding = updatedObjOutBinding;\n      }\n      if (!obj.returning && outBinds.length === 0) {\n        if (!connection.isTransaction) {\n          await connection.commitAsync();\n        }\n        return obj;\n      }\n      const rowIds = [];\n      let offset = 0;\n      for (let line = 0; line < obj.outBinding.length; line++) {\n        const ret = obj.outBinding[line];\n        offset = offset + (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);\n        for (let index = 0; index < ret.length; index++) {\n          const out = ret[index];\n          await new Promise(function (bindResolver, bindRejecter) {\n            if (out instanceof BlobHelper) {\n              const blob = outBinds[index + offset];\n              if (out.returning) {\n                obj.response[line] = obj.response[line] || {};\n                obj.response[line][out.columnName] = out.value;\n              }\n              blob.on('error', function (err) {\n                bindRejecter(err);\n              });\n              blob.on('finish', function () {\n                bindResolver();\n              });\n              blob.write(out.value);\n              blob.end();\n            } else if (obj.outBinding[line][index] === 'ROWID') {\n              rowIds.push(outBinds[index + offset]);\n              bindResolver();\n            } else {\n              obj.response[line] = obj.response[line] || {};\n              obj.response[line][out] = outBinds[index + offset];\n              bindResolver();\n            }\n          });\n        }\n      }\n      if (obj.returningSql) {\n        const response = await connection.executeAsync(obj.returningSql(), rowIds, {\n          resultSet: true\n        });\n        obj.response = response.rows;\n      }\n      if (connection.isTransaction) {\n        return obj;\n      }\n      await connection.commitAsync();\n      return obj;\n    });\n  }\n\n  // Process the response as returned from the query.\n  processResponse(obj, runner) {\n    const {\n      response\n    } = obj;\n    if (obj.output) {\n      return obj.output.call(runner, response);\n    }\n    switch (obj.method) {\n      case 'select':\n        return response;\n      case 'first':\n        return response[0];\n      case 'pluck':\n        return map(response, obj.pluck);\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if (obj.returning && !isEmpty(obj.returning) || obj.returningSql) {\n          return response;\n        } else if (obj.rowsAffected !== undefined) {\n          return obj.rowsAffected;\n        } else {\n          return 1;\n        }\n      default:\n        return response;\n    }\n  }\n  processPassedConnection(connection) {\n    this.checkVersion(connection);\n    monkeyPatchConnection(connection, this);\n  }\n}\nClient_Oracledb.prototype.driverName = 'oracledb';\nfunction parseVersion(versionString) {\n  try {\n    // We only care about first two version components at most\n    const versionParts = versionString.split('.').slice(0, 2);\n    // Strip off any character suffixes in version number (ex. 12c => 12, 12.2c => 12.2)\n    versionParts.forEach((versionPart, idx) => {\n      versionParts[idx] = versionPart.replace(/\\D$/, '');\n    });\n    const version = versionParts.join('.');\n    return version.match(/^\\d+\\.?\\d*$/) ? version : null;\n  } catch (err) {\n    // Non-string versionString passed in.\n    return null;\n  }\n}\nfunction resolveConnectString(connectionSettings) {\n  if (connectionSettings.connectString) {\n    return connectionSettings.connectString;\n  }\n  if (!connectionSettings.port) {\n    return connectionSettings.host + '/' + connectionSettings.database;\n  }\n  return connectionSettings.host + ':' + connectionSettings.port + '/' + connectionSettings.database;\n}\nmodule.exports = Client_Oracledb;","map":{"version":3,"names":["each","require","flatten","isEmpty","map","Formatter","QueryCompiler","TableCompiler","ColumnCompiler","BlobHelper","ReturningHelper","monkeyPatchConnection","ViewCompiler","ViewBuilder","Transaction","Client_Oracle","isString","outputQuery","unwrapRaw","compileCallback","Client_Oracledb","constructor","config","version","parseVersion","driver","process","env","UV_THREADPOOL_SIZE","parseInt","poolMax","_driver","client","oracledb","fetchAsString","Array","isArray","forEach","type","toUpperCase","logger","warn","push","queryCompiler","builder","formatter","tableCompiler","arguments","columnCompiler","viewBuilder","viewCompiler","transaction","prepBindings","bindings","value","BLOB","dir","BIND_OUT","STRING","parameter","undefined","acquireRawConnection","Promise","resolver","rejecter","oracleDbConfig","connectionSettings","externalAuth","user","password","connectString","resolveConnectString","prefetchRowCount","prefetchRows","stmtCacheSize","getConnection","err","connection","destroyRawConnection","release","acquireConnection","checkVersion","detectedVersion","oracleServerVersionString","Error","_query","obj","sql","options","Object","assign","autoCommit","method","resultSet","executeAsync","then","response","outBinds","rows","rowsAffected","length","modifiedRowsCount","updatedObjOutBinding","updatedOutBinds","updateOutBinds","i","index","OutBindsOffset","outBinding","returning","isTransaction","commitAsync","rowIds","offset","line","ret","out","bindResolver","bindRejecter","blob","columnName","on","write","end","returningSql","processResponse","runner","output","call","pluck","processPassedConnection","prototype","driverName","versionString","versionParts","split","slice","versionPart","idx","replace","join","match","port","host","database","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/oracledb/index.js"],"sourcesContent":["// Oracledb Client\n// -------\nconst each = require('lodash/each');\nconst flatten = require('lodash/flatten');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\n\nconst Formatter = require('../../formatter');\nconst QueryCompiler = require('./query/oracledb-querycompiler');\nconst TableCompiler = require('./schema/oracledb-tablecompiler');\nconst ColumnCompiler = require('./schema/oracledb-columncompiler');\nconst {\n  BlobHelper,\n  ReturningHelper,\n  monkeyPatchConnection,\n} = require('./utils');\nconst ViewCompiler = require('./schema/oracledb-viewcompiler');\nconst ViewBuilder = require('./schema/oracledb-viewbuilder');\nconst Transaction = require('./transaction');\nconst Client_Oracle = require('../oracle');\nconst { isString } = require('../../util/is');\nconst { outputQuery, unwrapRaw } = require('../../formatter/wrappingFormatter');\nconst { compileCallback } = require('../../formatter/formatterUtils');\n\nclass Client_Oracledb extends Client_Oracle {\n  constructor(config) {\n    super(config);\n\n    if (this.version) {\n      // Normalize version format; null bad format\n      // to trigger fallback to auto-detect.\n      this.version = parseVersion(this.version);\n    }\n\n    if (this.driver) {\n      process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;\n      process.env.UV_THREADPOOL_SIZE =\n        parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;\n    }\n  }\n\n  _driver() {\n    const client = this;\n    const oracledb = require('oracledb');\n    client.fetchAsString = [];\n    if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {\n      this.config.fetchAsString.forEach(function (type) {\n        if (!isString(type)) return;\n        type = type.toUpperCase();\n        if (oracledb[type]) {\n          if (\n            type !== 'NUMBER' &&\n            type !== 'DATE' &&\n            type !== 'CLOB' &&\n            type !== 'BUFFER'\n          ) {\n            this.logger.warn(\n              'Only \"date\", \"number\", \"clob\" and \"buffer\" are supported for fetchAsString'\n            );\n          }\n          client.fetchAsString.push(oracledb[type]);\n        }\n      });\n    }\n    return oracledb;\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  viewBuilder() {\n    return new ViewBuilder(this, ...arguments);\n  }\n\n  viewCompiler() {\n    return new ViewCompiler(this, ...arguments);\n  }\n\n  formatter(builder) {\n    return new Formatter(this, builder);\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  prepBindings(bindings) {\n    return map(bindings, (value) => {\n      if (value instanceof BlobHelper && this.driver) {\n        return { type: this.driver.BLOB, dir: this.driver.BIND_OUT };\n        // Returning helper always use ROWID as string\n      } else if (value instanceof ReturningHelper && this.driver) {\n        return { type: this.driver.STRING, dir: this.driver.BIND_OUT };\n      } else if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      return value;\n    });\n  }\n\n  // Checks whether a value is a function... if it is, we compile it\n  // otherwise we check whether it's a raw\n  parameter(value, builder, formatter) {\n    if (typeof value === 'function') {\n      return outputQuery(\n        compileCallback(value, undefined, this, formatter),\n        true,\n        builder,\n        this\n      );\n    } else if (value instanceof BlobHelper) {\n      formatter.bindings.push(value.value);\n      return '?';\n    }\n    return unwrapRaw(value, true, builder, this, formatter) || '?';\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    return new Promise((resolver, rejecter) => {\n      // If external authentication don't have to worry about username/password and\n      // if not need to set the username and password\n      const oracleDbConfig = this.connectionSettings.externalAuth\n        ? { externalAuth: this.connectionSettings.externalAuth }\n        : {\n            user: this.connectionSettings.user,\n            password: this.connectionSettings.password,\n          };\n\n      // In the case of external authentication connection string will be given\n      oracleDbConfig.connectString = resolveConnectString(\n        this.connectionSettings\n      );\n\n      if (this.connectionSettings.prefetchRowCount) {\n        oracleDbConfig.prefetchRows = this.connectionSettings.prefetchRowCount;\n      }\n\n      if (this.connectionSettings.stmtCacheSize !== undefined) {\n        oracleDbConfig.stmtCacheSize = this.connectionSettings.stmtCacheSize;\n      }\n\n      this.driver.fetchAsString = this.fetchAsString;\n\n      this.driver.getConnection(oracleDbConfig, (err, connection) => {\n        if (err) {\n          return rejecter(err);\n        }\n        monkeyPatchConnection(connection, this);\n\n        resolver(connection);\n      });\n    });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection(connection) {\n    return connection.release();\n  }\n\n  // Handle oracle version resolution on acquiring connection from pool instead of connection creation.\n  // Must do this here since only the client used to create a connection would be updated with version\n  // information on creation. Poses a problem when knex instance is cloned since instances share the\n  // connection pool while having their own client instances.\n  async acquireConnection() {\n    const connection = await super.acquireConnection();\n    this.checkVersion(connection);\n    return connection;\n  }\n\n  // In Oracle, we need to check the version to dynamically determine\n  // certain limits. If user did not specify a version, get it from the connection.\n  checkVersion(connection) {\n    // Already determined version before?\n    if (this.version) {\n      return this.version;\n    }\n\n    const detectedVersion = parseVersion(connection.oracleServerVersionString);\n    if (!detectedVersion) {\n      // When original version is set to null, user-provided version was invalid and we fell-back to auto-detect.\n      // Otherwise, we couldn't auto-detect at all. Set error message accordingly.\n      throw new Error(\n        this.version === null\n          ? 'Invalid Oracledb version number format passed to knex. Unable to successfully auto-detect as fallback. Please specify a valid oracledb version.'\n          : 'Unable to detect Oracledb version number automatically. Please specify the version in knex configuration.'\n      );\n    }\n\n    this.version = detectedVersion;\n    return detectedVersion;\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    const options = Object.assign({}, obj.options, { autoCommit: false });\n    if (obj.method === 'select') {\n      options.resultSet = true;\n    }\n    return connection\n      .executeAsync(obj.sql, obj.bindings, options)\n      .then(async function (response) {\n        // Flatten outBinds\n        let outBinds = flatten(response.outBinds);\n        obj.response = response.rows || [];\n        obj.rowsAffected = response.rows\n          ? response.rows.rowsAffected\n          : response.rowsAffected;\n\n        //added for outBind parameter\n        if (obj.method === 'raw' && outBinds.length > 0) {\n          return {\n            response: outBinds,\n          };\n        }\n\n        if (obj.method === 'update') {\n          const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;\n          const updatedObjOutBinding = [];\n          const updatedOutBinds = [];\n          const updateOutBinds = (i) =>\n            function (value, index) {\n              const OutBindsOffset = index * modifiedRowsCount;\n              updatedOutBinds.push(outBinds[i + OutBindsOffset]);\n            };\n\n          for (let i = 0; i < modifiedRowsCount; i++) {\n            updatedObjOutBinding.push(obj.outBinding[0]);\n            each(obj.outBinding[0], updateOutBinds(i));\n          }\n          outBinds = updatedOutBinds;\n          obj.outBinding = updatedObjOutBinding;\n        }\n\n        if (!obj.returning && outBinds.length === 0) {\n          if (!connection.isTransaction) {\n            await connection.commitAsync();\n          }\n          return obj;\n        }\n        const rowIds = [];\n        let offset = 0;\n\n        for (let line = 0; line < obj.outBinding.length; line++) {\n          const ret = obj.outBinding[line];\n\n          offset =\n            offset +\n            (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);\n\n          for (let index = 0; index < ret.length; index++) {\n            const out = ret[index];\n\n            await new Promise(function (bindResolver, bindRejecter) {\n              if (out instanceof BlobHelper) {\n                const blob = outBinds[index + offset];\n                if (out.returning) {\n                  obj.response[line] = obj.response[line] || {};\n                  obj.response[line][out.columnName] = out.value;\n                }\n                blob.on('error', function (err) {\n                  bindRejecter(err);\n                });\n                blob.on('finish', function () {\n                  bindResolver();\n                });\n                blob.write(out.value);\n                blob.end();\n              } else if (obj.outBinding[line][index] === 'ROWID') {\n                rowIds.push(outBinds[index + offset]);\n                bindResolver();\n              } else {\n                obj.response[line] = obj.response[line] || {};\n                obj.response[line][out] = outBinds[index + offset];\n                bindResolver();\n              }\n            });\n          }\n        }\n        if (obj.returningSql) {\n          const response = await connection.executeAsync(\n            obj.returningSql(),\n            rowIds,\n            { resultSet: true }\n          );\n          obj.response = response.rows;\n        }\n        if (connection.isTransaction) {\n          return obj;\n        }\n        await connection.commitAsync();\n        return obj;\n      });\n  }\n\n  // Process the response as returned from the query.\n  processResponse(obj, runner) {\n    const { response } = obj;\n    if (obj.output) {\n      return obj.output.call(runner, response);\n    }\n    switch (obj.method) {\n      case 'select':\n        return response;\n      case 'first':\n        return response[0];\n      case 'pluck':\n        return map(response, obj.pluck);\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if ((obj.returning && !isEmpty(obj.returning)) || obj.returningSql) {\n          return response;\n        } else if (obj.rowsAffected !== undefined) {\n          return obj.rowsAffected;\n        } else {\n          return 1;\n        }\n      default:\n        return response;\n    }\n  }\n\n  processPassedConnection(connection) {\n    this.checkVersion(connection);\n    monkeyPatchConnection(connection, this);\n  }\n}\n\nClient_Oracledb.prototype.driverName = 'oracledb';\n\nfunction parseVersion(versionString) {\n  try {\n    // We only care about first two version components at most\n    const versionParts = versionString.split('.').slice(0, 2);\n    // Strip off any character suffixes in version number (ex. 12c => 12, 12.2c => 12.2)\n    versionParts.forEach((versionPart, idx) => {\n      versionParts[idx] = versionPart.replace(/\\D$/, '');\n    });\n    const version = versionParts.join('.');\n    return version.match(/^\\d+\\.?\\d*$/) ? version : null;\n  } catch (err) {\n    // Non-string versionString passed in.\n    return null;\n  }\n}\n\nfunction resolveConnectString(connectionSettings) {\n  if (connectionSettings.connectString) {\n    return connectionSettings.connectString;\n  }\n\n  if (!connectionSettings.port) {\n    return connectionSettings.host + '/' + connectionSettings.database;\n  }\n\n  return (\n    connectionSettings.host +\n    ':' +\n    connectionSettings.port +\n    '/' +\n    connectionSettings.database\n  );\n}\n\nmodule.exports = Client_Oracledb;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}