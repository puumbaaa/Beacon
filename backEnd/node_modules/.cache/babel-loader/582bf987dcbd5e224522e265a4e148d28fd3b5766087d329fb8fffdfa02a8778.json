{"ast":null,"code":"/* eslint max-len:0 */\n\n// Oracle Query Builder & Compiler\n// ------\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst reduce = require('lodash/reduce');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst {\n  ReturningHelper\n} = require('../utils');\nconst {\n  isString\n} = require('../../../util/is');\nconst components = ['comments', 'columns', 'join', 'where', 'union', 'group', 'having', 'order', 'lock'];\n\n// Query Compiler\n// -------\n\n// Set the \"Formatter\" to use for the queries,\n// ensuring that all parameterized values (even across sub-queries)\n// are properly built into the same query.\nclass QueryCompiler_Oracle extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      onConflict\n    } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for oracledb.');\n    }\n\n    // Compiles the `select` statement, or nested sub-selects\n    // by calling each of the component compilers, trimming out\n    // the empties, and returning a generated query string.\n    this.first = this.select;\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let insertValues = this.single.insert || [];\n    let {\n      returning\n    } = this.single;\n    if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {\n      insertValues = [this.single.insert];\n    }\n\n    // always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n    if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} (${this.formatter.wrap(this.single.returning)}) values (default)`, returning, this.tableName);\n    }\n    if (isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n    const insertData = this._prepInsert(insertValues);\n    const sql = {};\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} ${insertData}`, returning);\n    }\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} (${this.formatter.columnize(insertData.columns)}) values (${this.client.parameterize(insertData.values[0], undefined, this.builder, this.bindingsHolder)})`, returning, this.tableName);\n    }\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.sql = 'begin ' + insertData.values.map(value => {\n      let returningHelper;\n      const parameterizedValues = !insertDefaultsOnly ? this.client.parameterize(value, this.client.valueForUndefined, this.builder, this.bindingsHolder) : '';\n      const returningValues = Array.isArray(returning) ? returning : [returning];\n      let subSql = `insert into ${this.tableName} `;\n      if (returning) {\n        returningHelper = new ReturningHelper(returningValues.join(':'));\n        sql.outParams = (sql.outParams || []).concat(returningHelper);\n      }\n      if (insertDefaultsOnly) {\n        // no columns given so only the default value\n        subSql += `(${this.formatter.wrap(this.single.returning)}) values (default)`;\n      } else {\n        subSql += `(${this.formatter.columnize(insertData.columns)}) values (${parameterizedValues})`;\n      }\n      subSql += returning ? ` returning ROWID into ${this.client.parameter(returningHelper, this.builder, this.bindingsHolder)}` : '';\n\n      // pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n\n      subSql = this.formatter.client.positionBindings(subSql);\n      const parameterizedValuesWithoutDefault = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '');\n      return `execute immediate '${subSql.replace(/'/g, \"''\")}` + (parameterizedValuesWithoutDefault || returning ? \"' using \" : '') + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ', ' : '') + (returning ? 'out ?' : '') + ';';\n    }).join(' ') + 'end;';\n    if (returning) {\n      sql.returning = returning;\n      // generate select statement with special order by to keep the order because 'in (..)' may change the order\n      sql.returningSql = `select ${this.formatter.columnize(returning)}` + ' from ' + this.tableName + ' where ROWID in (' + sql.outParams.map((v, i) => `:${i + 1}`).join(', ') + ')' + ' order by case ROWID ' + sql.outParams.map((v, i) => `when CHARTOROWID(:${i + 1}) then ${i}`).join(' ') + ' end';\n    }\n    return sql;\n  }\n\n  // Update method, including joins, wheres, order & limits.\n  update() {\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    let {\n      returning\n    } = this.single;\n    const sql = `update ${this.tableName}` + ' set ' + updates.join(', ') + (where ? ` ${where}` : '');\n    if (!returning) {\n      return sql;\n    }\n\n    // always wrap returning argument in array\n    if (!Array.isArray(returning)) {\n      returning = [returning];\n    }\n    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n  forUpdate() {\n    return 'for update';\n  }\n  forShare() {\n    // lock for share is not directly supported by oracle\n    // use LOCK TABLE .. IN SHARE MODE; instead\n    this.client.logger.warn('lock for share is not supported by oracle dialect');\n    return '';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    // Node oracle drivers doesn't support LONG type (which is data_default type)\n    const sql = `select * from xmltable( '/ROWSET/ROW'\n      passing dbms_xmlgen.getXMLType('\n      select char_col_decl_length, column_name, data_type, data_default, nullable\n      from all_tab_columns where table_name = ''${table}'' ')\n      columns\n      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),\n      DATA_DEFAULT clob, NULLABLE varchar2(1))`;\n    return {\n      sql: sql,\n      output(resp) {\n        const out = reduce(resp, function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            type: val.DATA_TYPE,\n            defaultValue: val.DATA_DEFAULT,\n            maxLength: val.CHAR_COL_DECL_LENGTH,\n            nullable: val.NULLABLE === 'Y'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n  select() {\n    let query = this.with();\n    const statements = components.map(component => {\n      return this[component]();\n    });\n    query += compact(statements).join(' ');\n    return this._surroundQueryWithLimitAndOffset(query);\n  }\n  aggregate(stmt) {\n    return this._aggregate(stmt, {\n      aliasSeparator: ' '\n    });\n  }\n\n  // for single commands only\n  _addReturningToSqlAndConvert(sql, returning, tableName) {\n    const res = {\n      sql\n    };\n    if (!returning) {\n      return res;\n    }\n    const returningValues = Array.isArray(returning) ? returning : [returning];\n    const returningHelper = new ReturningHelper(returningValues.join(':'));\n    res.sql = sql + ' returning ROWID into ' + this.client.parameter(returningHelper, this.builder, this.bindingsHolder);\n    res.returningSql = `select ${this.formatter.columnize(returning)} from ${tableName} where ROWID = :1`;\n    res.outParams = [returningHelper];\n    res.returning = returning;\n    return res;\n  }\n  _surroundQueryWithLimitAndOffset(query) {\n    let {\n      limit\n    } = this.single;\n    const {\n      offset\n    } = this.single;\n    const hasLimit = limit || limit === 0 || limit === '0';\n    limit = +limit;\n    if (!hasLimit && !offset) return query;\n    query = query || '';\n    if (hasLimit && !offset) {\n      return `select * from (${query}) where rownum <= ${this._getValueOrParameterFromAttribute('limit', limit)}`;\n    }\n    const endRow = +offset + (hasLimit ? limit : 10000000000000);\n    return 'select * from ' + '(select row_.*, ROWNUM rownum_ from (' + query + ') row_ ' + 'where rownum <= ' + (this.single.skipBinding['offset'] ? endRow : this.client.parameter(endRow, this.builder, this.bindingsHolder)) + ') ' + 'where rownum_ > ' + this._getValueOrParameterFromAttribute('offset', offset);\n  }\n}\nmodule.exports = QueryCompiler_Oracle;","map":{"version":3,"names":["compact","require","identity","isEmpty","isPlainObject","reduce","QueryCompiler","ReturningHelper","isString","components","QueryCompiler_Oracle","constructor","client","builder","formatter","onConflict","single","Error","first","select","insert","insertValues","returning","Array","isArray","length","_addReturningToSqlAndConvert","tableName","wrap","insertData","_prepInsert","sql","values","columnize","columns","parameterize","undefined","bindingsHolder","insertDefaultsOnly","map","value","returningHelper","parameterizedValues","valueForUndefined","returningValues","subSql","join","outParams","concat","parameter","positionBindings","parameterizedValuesWithoutDefault","replace","returningSql","v","i","update","updates","_prepUpdate","where","truncate","forUpdate","forShare","logger","warn","columnInfo","column","table","customWrapIdentifier","output","resp","out","val","COLUMN_NAME","type","DATA_TYPE","defaultValue","DATA_DEFAULT","maxLength","CHAR_COL_DECL_LENGTH","nullable","NULLABLE","query","with","statements","component","_surroundQueryWithLimitAndOffset","aggregate","stmt","_aggregate","aliasSeparator","res","limit","offset","hasLimit","_getValueOrParameterFromAttribute","endRow","skipBinding","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js"],"sourcesContent":["/* eslint max-len:0 */\n\n// Oracle Query Builder & Compiler\n// ------\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst reduce = require('lodash/reduce');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst { ReturningHelper } = require('../utils');\nconst { isString } = require('../../../util/is');\n\nconst components = [\n  'comments',\n  'columns',\n  'join',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'lock',\n];\n\n// Query Compiler\n// -------\n\n// Set the \"Formatter\" to use for the queries,\n// ensuring that all parameterized values (even across sub-queries)\n// are properly built into the same query.\nclass QueryCompiler_Oracle extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { onConflict } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for oracledb.');\n    }\n\n    // Compiles the `select` statement, or nested sub-selects\n    // by calling each of the component compilers, trimming out\n    // the empties, and returning a generated query string.\n    this.first = this.select;\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let insertValues = this.single.insert || [];\n    let { returning } = this.single;\n\n    if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {\n      insertValues = [this.single.insert];\n    }\n\n    // always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    if (\n      Array.isArray(insertValues) &&\n      insertValues.length === 1 &&\n      isEmpty(insertValues[0])\n    ) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} (${this.formatter.wrap(\n          this.single.returning\n        )}) values (default)`,\n        returning,\n        this.tableName\n      );\n    }\n\n    if (\n      isEmpty(this.single.insert) &&\n      typeof this.single.insert !== 'function'\n    ) {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} ${insertData}`,\n        returning\n      );\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} (${this.formatter.columnize(\n          insertData.columns\n        )}) values (${this.client.parameterize(\n          insertData.values[0],\n          undefined,\n          this.builder,\n          this.bindingsHolder\n        )})`,\n        returning,\n        this.tableName\n      );\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n\n    sql.sql =\n      'begin ' +\n      insertData.values\n        .map((value) => {\n          let returningHelper;\n          const parameterizedValues = !insertDefaultsOnly\n            ? this.client.parameterize(\n                value,\n                this.client.valueForUndefined,\n                this.builder,\n                this.bindingsHolder\n              )\n            : '';\n          const returningValues = Array.isArray(returning)\n            ? returning\n            : [returning];\n          let subSql = `insert into ${this.tableName} `;\n\n          if (returning) {\n            returningHelper = new ReturningHelper(returningValues.join(':'));\n            sql.outParams = (sql.outParams || []).concat(returningHelper);\n          }\n\n          if (insertDefaultsOnly) {\n            // no columns given so only the default value\n            subSql += `(${this.formatter.wrap(\n              this.single.returning\n            )}) values (default)`;\n          } else {\n            subSql += `(${this.formatter.columnize(\n              insertData.columns\n            )}) values (${parameterizedValues})`;\n          }\n          subSql += returning\n            ? ` returning ROWID into ${this.client.parameter(\n                returningHelper,\n                this.builder,\n                this.bindingsHolder\n              )}`\n            : '';\n\n          // pre bind position because subSql is an execute immediate parameter\n          // later position binding will only convert the ? params\n\n          subSql = this.formatter.client.positionBindings(subSql);\n\n          const parameterizedValuesWithoutDefault = parameterizedValues\n            .replace('DEFAULT, ', '')\n            .replace(', DEFAULT', '');\n          return (\n            `execute immediate '${subSql.replace(/'/g, \"''\")}` +\n            (parameterizedValuesWithoutDefault || returning ? \"' using \" : '') +\n            parameterizedValuesWithoutDefault +\n            (parameterizedValuesWithoutDefault && returning ? ', ' : '') +\n            (returning ? 'out ?' : '') +\n            ';'\n          );\n        })\n        .join(' ') +\n      'end;';\n\n    if (returning) {\n      sql.returning = returning;\n      // generate select statement with special order by to keep the order because 'in (..)' may change the order\n      sql.returningSql =\n        `select ${this.formatter.columnize(returning)}` +\n        ' from ' +\n        this.tableName +\n        ' where ROWID in (' +\n        sql.outParams.map((v, i) => `:${i + 1}`).join(', ') +\n        ')' +\n        ' order by case ROWID ' +\n        sql.outParams\n          .map((v, i) => `when CHARTOROWID(:${i + 1}) then ${i}`)\n          .join(' ') +\n        ' end';\n    }\n\n    return sql;\n  }\n\n  // Update method, including joins, wheres, order & limits.\n  update() {\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    let { returning } = this.single;\n    const sql =\n      `update ${this.tableName}` +\n      ' set ' +\n      updates.join(', ') +\n      (where ? ` ${where}` : '');\n\n    if (!returning) {\n      return sql;\n    }\n\n    // always wrap returning argument in array\n    if (!Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    return 'for update';\n  }\n\n  forShare() {\n    // lock for share is not directly supported by oracle\n    // use LOCK TABLE .. IN SHARE MODE; instead\n    this.client.logger.warn(\n      'lock for share is not supported by oracle dialect'\n    );\n    return '';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    // Node oracle drivers doesn't support LONG type (which is data_default type)\n    const sql = `select * from xmltable( '/ROWSET/ROW'\n      passing dbms_xmlgen.getXMLType('\n      select char_col_decl_length, column_name, data_type, data_default, nullable\n      from all_tab_columns where table_name = ''${table}'' ')\n      columns\n      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),\n      DATA_DEFAULT clob, NULLABLE varchar2(1))`;\n\n    return {\n      sql: sql,\n      output(resp) {\n        const out = reduce(\n          resp,\n          function (columns, val) {\n            columns[val.COLUMN_NAME] = {\n              type: val.DATA_TYPE,\n              defaultValue: val.DATA_DEFAULT,\n              maxLength: val.CHAR_COL_DECL_LENGTH,\n              nullable: val.NULLABLE === 'Y',\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  select() {\n    let query = this.with();\n    const statements = components.map((component) => {\n      return this[component]();\n    });\n    query += compact(statements).join(' ');\n    return this._surroundQueryWithLimitAndOffset(query);\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, { aliasSeparator: ' ' });\n  }\n\n  // for single commands only\n  _addReturningToSqlAndConvert(sql, returning, tableName) {\n    const res = {\n      sql,\n    };\n\n    if (!returning) {\n      return res;\n    }\n\n    const returningValues = Array.isArray(returning) ? returning : [returning];\n    const returningHelper = new ReturningHelper(returningValues.join(':'));\n    res.sql =\n      sql +\n      ' returning ROWID into ' +\n      this.client.parameter(returningHelper, this.builder, this.bindingsHolder);\n    res.returningSql = `select ${this.formatter.columnize(\n      returning\n    )} from ${tableName} where ROWID = :1`;\n    res.outParams = [returningHelper];\n    res.returning = returning;\n    return res;\n  }\n\n  _surroundQueryWithLimitAndOffset(query) {\n    let { limit } = this.single;\n    const { offset } = this.single;\n    const hasLimit = limit || limit === 0 || limit === '0';\n    limit = +limit;\n\n    if (!hasLimit && !offset) return query;\n    query = query || '';\n\n    if (hasLimit && !offset) {\n      return `select * from (${query}) where rownum <= ${this._getValueOrParameterFromAttribute(\n        'limit',\n        limit\n      )}`;\n    }\n\n    const endRow = +offset + (hasLimit ? limit : 10000000000000);\n\n    return (\n      'select * from ' +\n      '(select row_.*, ROWNUM rownum_ from (' +\n      query +\n      ') row_ ' +\n      'where rownum <= ' +\n      (this.single.skipBinding['offset']\n        ? endRow\n        : this.client.parameter(endRow, this.builder, this.bindingsHolder)) +\n      ') ' +\n      'where rownum_ > ' +\n      this._getValueOrParameterFromAttribute('offset', offset)\n    );\n  }\n}\n\nmodule.exports = QueryCompiler_Oracle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}