{"ast":null,"code":"// TableBuilder\n\n// Takes the function passed to the \"createTable\" or \"table/editTable\"\n// functions and calls it with the \"TableBuilder\" as both the context and\n// the first argument. Inside this function we can specify what happens to the\n// method, pushing everything we want to do onto the \"allStatements\" array,\n// which is then compiled into sql.\n// ------\nconst each = require('lodash/each');\nconst extend = require('lodash/extend');\nconst assign = require('lodash/assign');\nconst toArray = require('lodash/toArray');\nconst helpers = require('../util/helpers');\nconst {\n  isString,\n  isFunction,\n  isObject\n} = require('../util/is');\nclass TableBuilder {\n  constructor(client, method, tableName, tableNameLike, fn) {\n    this.client = client;\n    this._fn = fn;\n    this._method = method;\n    this._schemaName = undefined;\n    this._tableName = tableName;\n    this._tableNameLike = tableNameLike;\n    this._statements = [];\n    this._single = {};\n    if (!tableNameLike && !isFunction(this._fn)) {\n      throw new TypeError('A callback function must be supplied to calls against `.createTable` ' + 'and `.table`');\n    }\n  }\n  setSchema(schemaName) {\n    this._schemaName = schemaName;\n  }\n\n  // Convert the current tableBuilder object \"toSQL\"\n  // giving us additional methods if we're altering\n  // rather than creating the table.\n  toSQL() {\n    if (this._method === 'alter') {\n      extend(this, AlterMethods);\n    }\n    // With 'create table ... like' callback function is useless.\n    if (this._fn) {\n      this._fn.call(this, this);\n    }\n    return this.client.tableCompiler(this).toSQL();\n  }\n\n  // The \"timestamps\" call is really just sets the `created_at` and `updated_at` columns.\n\n  timestamps(useTimestamps, defaultToNow, useCamelCase) {\n    if (isObject(useTimestamps)) {\n      ({\n        useTimestamps,\n        defaultToNow,\n        useCamelCase\n      } = useTimestamps);\n    }\n    const method = useTimestamps === true ? 'timestamp' : 'datetime';\n    const createdAt = this[method](useCamelCase ? 'createdAt' : 'created_at');\n    const updatedAt = this[method](useCamelCase ? 'updatedAt' : 'updated_at');\n    if (defaultToNow === true) {\n      const now = this.client.raw('CURRENT_TIMESTAMP');\n      createdAt.notNullable().defaultTo(now);\n      updatedAt.notNullable().defaultTo(now);\n    }\n  }\n\n  // Set the comment value for a table, they're only allowed to be called\n  // once per table.\n  comment(value) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Table comment must be string');\n    }\n    this._single.comment = value;\n  }\n\n  // Set a foreign key on the table, calling\n  // `table.foreign('column_name').references('column').on('table').onDelete()...\n  // Also called from the ColumnBuilder context when chaining.\n  foreign(column, keyName) {\n    const foreignData = {\n      column: column,\n      keyName: keyName\n    };\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'foreign',\n      args: [foreignData]\n    });\n    let returnObj = {\n      references(tableColumn) {\n        let pieces;\n        if (isString(tableColumn)) {\n          pieces = tableColumn.split('.');\n        }\n        if (!pieces || pieces.length === 1) {\n          foreignData.references = pieces ? pieces[0] : tableColumn;\n          return {\n            on(tableName) {\n              if (typeof tableName !== 'string') {\n                throw new TypeError(`Expected tableName to be a string, got: ${typeof tableName}`);\n              }\n              foreignData.inTable = tableName;\n              return returnObj;\n            },\n            inTable() {\n              return this.on.apply(this, arguments);\n            }\n          };\n        }\n        foreignData.inTable = pieces[0];\n        foreignData.references = pieces[1];\n        return returnObj;\n      },\n      withKeyName(keyName) {\n        foreignData.keyName = keyName;\n        return returnObj;\n      },\n      onUpdate(statement) {\n        foreignData.onUpdate = statement;\n        return returnObj;\n      },\n      onDelete(statement) {\n        foreignData.onDelete = statement;\n        return returnObj;\n      },\n      deferrable: type => {\n        const unSupported = ['mysql', 'mssql', 'redshift', 'mysql2', 'oracledb'];\n        if (unSupported.indexOf(this.client.dialect) !== -1) {\n          throw new Error(`${this.client.dialect} does not support deferrable`);\n        }\n        foreignData.deferrable = type;\n        return returnObj;\n      },\n      _columnBuilder(builder) {\n        extend(builder, returnObj);\n        returnObj = builder;\n        return builder;\n      }\n    };\n    return returnObj;\n  }\n  check(checkPredicate, bindings, constraintName) {\n    this._statements.push({\n      grouping: 'checks',\n      args: [checkPredicate, bindings, constraintName]\n    });\n    return this;\n  }\n}\n[\n// Each of the index methods can be called individually, with the\n// column name to be used, e.g. table.unique('column').\n'index', 'primary', 'unique',\n// Key specific\n'dropPrimary', 'dropUnique', 'dropIndex', 'dropForeign'].forEach(method => {\n  TableBuilder.prototype[method] = function () {\n    this._statements.push({\n      grouping: 'alterTable',\n      method,\n      args: toArray(arguments)\n    });\n    return this;\n  };\n});\n\n// Warn for dialect-specific table methods, since that's the\n// only time these are supported.\nconst specialMethods = {\n  mysql: ['engine', 'charset', 'collate'],\n  postgresql: ['inherits']\n};\neach(specialMethods, function (methods, dialect) {\n  methods.forEach(function (method) {\n    TableBuilder.prototype[method] = function (value) {\n      if (this.client.dialect !== dialect) {\n        throw new Error(`Knex only supports ${method} statement with ${dialect}.`);\n      }\n      if (this._method === 'alter') {\n        throw new Error(`Knex does not support altering the ${method} outside of create ` + `table, please use knex.raw statement.`);\n      }\n      this._single[method] = value;\n    };\n  });\n});\nhelpers.addQueryContext(TableBuilder);\n\n// Each of the column types that we can add, we create a new ColumnBuilder\n// instance and push it onto the statements array.\nconst columnTypes = [\n// Numeric\n'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'decimal', 'float', 'double', 'real', 'bit', 'boolean', 'serial',\n// Date / Time\n'date', 'datetime', 'timestamp', 'time', 'year',\n// Geometry\n'geometry', 'geography', 'point',\n// String\n'char', 'varchar', 'tinytext', 'tinyText', 'text', 'mediumtext', 'mediumText', 'longtext', 'longText', 'binary', 'varbinary', 'tinyblob', 'tinyBlob', 'mediumblob', 'mediumBlob', 'blob', 'longblob', 'longBlob', 'enum', 'set',\n// Increments, Aliases, and Additional\n'bool', 'dateTime', 'increments', 'bigincrements', 'bigIncrements', 'integer', 'biginteger', 'bigInteger', 'string', 'json', 'jsonb', 'uuid', 'enu', 'specificType'];\n\n// For each of the column methods, create a new \"ColumnBuilder\" interface,\n// push it onto the \"allStatements\" stack, and then return the interface,\n// with which we can add indexes, etc.\ncolumnTypes.forEach(type => {\n  TableBuilder.prototype[type] = function () {\n    const args = toArray(arguments);\n    const builder = this.client.columnBuilder(this, type, args);\n    this._statements.push({\n      grouping: 'columns',\n      builder\n    });\n    return builder;\n  };\n});\nconst AlterMethods = {\n  // Renames the current column `from` the current\n  // TODO: this.column(from).rename(to)\n  renameColumn(from, to) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'renameColumn',\n      args: [from, to]\n    });\n    return this;\n  },\n  dropTimestamps() {\n    // arguments[0] = useCamelCase\n    return this.dropColumns(arguments[0] === true ? ['createdAt', 'updatedAt'] : ['created_at', 'updated_at']);\n  },\n  setNullable(column) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'setNullable',\n      args: [column]\n    });\n    return this;\n  },\n  check(checkPredicate, bindings, constraintName) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'check',\n      args: [checkPredicate, bindings, constraintName]\n    });\n  },\n  dropChecks() {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'dropChecks',\n      args: toArray(arguments)\n    });\n  },\n  dropNullable(column) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'dropNullable',\n      args: [column]\n    });\n    return this;\n  }\n\n  // TODO: changeType\n};\n\n// Drop a column from the current table.\n// TODO: Enable this.column(columnName).drop();\nAlterMethods.dropColumn = AlterMethods.dropColumns = function () {\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'dropColumn',\n    args: toArray(arguments)\n  });\n  return this;\n};\nTableBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(TableBuilder.prototype, methodName)) {\n    throw new Error(`Can't extend TableBuilder with existing method ('${methodName}').`);\n  }\n  assign(TableBuilder.prototype, {\n    [methodName]: fn\n  });\n};\nmodule.exports = TableBuilder;","map":{"version":3,"names":["each","require","extend","assign","toArray","helpers","isString","isFunction","isObject","TableBuilder","constructor","client","method","tableName","tableNameLike","fn","_fn","_method","_schemaName","undefined","_tableName","_tableNameLike","_statements","_single","TypeError","setSchema","schemaName","toSQL","AlterMethods","call","tableCompiler","timestamps","useTimestamps","defaultToNow","useCamelCase","createdAt","updatedAt","now","raw","notNullable","defaultTo","comment","value","foreign","column","keyName","foreignData","push","grouping","args","returnObj","references","tableColumn","pieces","split","length","on","inTable","apply","arguments","withKeyName","onUpdate","statement","onDelete","deferrable","type","unSupported","indexOf","dialect","Error","_columnBuilder","builder","check","checkPredicate","bindings","constraintName","forEach","prototype","specialMethods","mysql","postgresql","methods","addQueryContext","columnTypes","columnBuilder","renameColumn","from","to","dropTimestamps","dropColumns","setNullable","dropChecks","dropNullable","dropColumn","methodName","Object","hasOwnProperty","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/schema/tablebuilder.js"],"sourcesContent":["// TableBuilder\n\n// Takes the function passed to the \"createTable\" or \"table/editTable\"\n// functions and calls it with the \"TableBuilder\" as both the context and\n// the first argument. Inside this function we can specify what happens to the\n// method, pushing everything we want to do onto the \"allStatements\" array,\n// which is then compiled into sql.\n// ------\nconst each = require('lodash/each');\nconst extend = require('lodash/extend');\nconst assign = require('lodash/assign');\nconst toArray = require('lodash/toArray');\nconst helpers = require('../util/helpers');\nconst { isString, isFunction, isObject } = require('../util/is');\n\nclass TableBuilder {\n  constructor(client, method, tableName, tableNameLike, fn) {\n    this.client = client;\n    this._fn = fn;\n    this._method = method;\n    this._schemaName = undefined;\n    this._tableName = tableName;\n    this._tableNameLike = tableNameLike;\n    this._statements = [];\n    this._single = {};\n\n    if (!tableNameLike && !isFunction(this._fn)) {\n      throw new TypeError(\n        'A callback function must be supplied to calls against `.createTable` ' +\n          'and `.table`'\n      );\n    }\n  }\n\n  setSchema(schemaName) {\n    this._schemaName = schemaName;\n  }\n\n  // Convert the current tableBuilder object \"toSQL\"\n  // giving us additional methods if we're altering\n  // rather than creating the table.\n  toSQL() {\n    if (this._method === 'alter') {\n      extend(this, AlterMethods);\n    }\n    // With 'create table ... like' callback function is useless.\n    if (this._fn) {\n      this._fn.call(this, this);\n    }\n    return this.client.tableCompiler(this).toSQL();\n  }\n\n  // The \"timestamps\" call is really just sets the `created_at` and `updated_at` columns.\n\n  timestamps(useTimestamps, defaultToNow, useCamelCase) {\n    if (isObject(useTimestamps)) {\n      ({ useTimestamps, defaultToNow, useCamelCase } = useTimestamps);\n    }\n    const method = useTimestamps === true ? 'timestamp' : 'datetime';\n    const createdAt = this[method](useCamelCase ? 'createdAt' : 'created_at');\n    const updatedAt = this[method](useCamelCase ? 'updatedAt' : 'updated_at');\n\n    if (defaultToNow === true) {\n      const now = this.client.raw('CURRENT_TIMESTAMP');\n      createdAt.notNullable().defaultTo(now);\n      updatedAt.notNullable().defaultTo(now);\n    }\n  }\n\n  // Set the comment value for a table, they're only allowed to be called\n  // once per table.\n  comment(value) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Table comment must be string');\n    }\n    this._single.comment = value;\n  }\n\n  // Set a foreign key on the table, calling\n  // `table.foreign('column_name').references('column').on('table').onDelete()...\n  // Also called from the ColumnBuilder context when chaining.\n  foreign(column, keyName) {\n    const foreignData = { column: column, keyName: keyName };\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'foreign',\n      args: [foreignData],\n    });\n    let returnObj = {\n      references(tableColumn) {\n        let pieces;\n        if (isString(tableColumn)) {\n          pieces = tableColumn.split('.');\n        }\n        if (!pieces || pieces.length === 1) {\n          foreignData.references = pieces ? pieces[0] : tableColumn;\n          return {\n            on(tableName) {\n              if (typeof tableName !== 'string') {\n                throw new TypeError(\n                  `Expected tableName to be a string, got: ${typeof tableName}`\n                );\n              }\n              foreignData.inTable = tableName;\n              return returnObj;\n            },\n            inTable() {\n              return this.on.apply(this, arguments);\n            },\n          };\n        }\n        foreignData.inTable = pieces[0];\n        foreignData.references = pieces[1];\n        return returnObj;\n      },\n      withKeyName(keyName) {\n        foreignData.keyName = keyName;\n        return returnObj;\n      },\n      onUpdate(statement) {\n        foreignData.onUpdate = statement;\n        return returnObj;\n      },\n      onDelete(statement) {\n        foreignData.onDelete = statement;\n        return returnObj;\n      },\n      deferrable: (type) => {\n        const unSupported = [\n          'mysql',\n          'mssql',\n          'redshift',\n          'mysql2',\n          'oracledb',\n        ];\n        if (unSupported.indexOf(this.client.dialect) !== -1) {\n          throw new Error(`${this.client.dialect} does not support deferrable`);\n        }\n        foreignData.deferrable = type;\n        return returnObj;\n      },\n      _columnBuilder(builder) {\n        extend(builder, returnObj);\n        returnObj = builder;\n        return builder;\n      },\n    };\n    return returnObj;\n  }\n\n  check(checkPredicate, bindings, constraintName) {\n    this._statements.push({\n      grouping: 'checks',\n      args: [checkPredicate, bindings, constraintName],\n    });\n    return this;\n  }\n}\n\n[\n  // Each of the index methods can be called individually, with the\n  // column name to be used, e.g. table.unique('column').\n  'index',\n  'primary',\n  'unique',\n\n  // Key specific\n  'dropPrimary',\n  'dropUnique',\n  'dropIndex',\n  'dropForeign',\n].forEach((method) => {\n  TableBuilder.prototype[method] = function () {\n    this._statements.push({\n      grouping: 'alterTable',\n      method,\n      args: toArray(arguments),\n    });\n    return this;\n  };\n});\n\n// Warn for dialect-specific table methods, since that's the\n// only time these are supported.\nconst specialMethods = {\n  mysql: ['engine', 'charset', 'collate'],\n  postgresql: ['inherits'],\n};\neach(specialMethods, function (methods, dialect) {\n  methods.forEach(function (method) {\n    TableBuilder.prototype[method] = function (value) {\n      if (this.client.dialect !== dialect) {\n        throw new Error(\n          `Knex only supports ${method} statement with ${dialect}.`\n        );\n      }\n      if (this._method === 'alter') {\n        throw new Error(\n          `Knex does not support altering the ${method} outside of create ` +\n            `table, please use knex.raw statement.`\n        );\n      }\n      this._single[method] = value;\n    };\n  });\n});\n\nhelpers.addQueryContext(TableBuilder);\n\n// Each of the column types that we can add, we create a new ColumnBuilder\n// instance and push it onto the statements array.\nconst columnTypes = [\n  // Numeric\n  'tinyint',\n  'smallint',\n  'mediumint',\n  'int',\n  'bigint',\n  'decimal',\n  'float',\n  'double',\n  'real',\n  'bit',\n  'boolean',\n  'serial',\n\n  // Date / Time\n  'date',\n  'datetime',\n  'timestamp',\n  'time',\n  'year',\n\n  // Geometry\n  'geometry',\n  'geography',\n  'point',\n\n  // String\n  'char',\n  'varchar',\n  'tinytext',\n  'tinyText',\n  'text',\n  'mediumtext',\n  'mediumText',\n  'longtext',\n  'longText',\n  'binary',\n  'varbinary',\n  'tinyblob',\n  'tinyBlob',\n  'mediumblob',\n  'mediumBlob',\n  'blob',\n  'longblob',\n  'longBlob',\n  'enum',\n  'set',\n\n  // Increments, Aliases, and Additional\n  'bool',\n  'dateTime',\n  'increments',\n  'bigincrements',\n  'bigIncrements',\n  'integer',\n  'biginteger',\n  'bigInteger',\n  'string',\n  'json',\n  'jsonb',\n  'uuid',\n  'enu',\n  'specificType',\n];\n\n// For each of the column methods, create a new \"ColumnBuilder\" interface,\n// push it onto the \"allStatements\" stack, and then return the interface,\n// with which we can add indexes, etc.\ncolumnTypes.forEach((type) => {\n  TableBuilder.prototype[type] = function () {\n    const args = toArray(arguments);\n    const builder = this.client.columnBuilder(this, type, args);\n    this._statements.push({\n      grouping: 'columns',\n      builder,\n    });\n    return builder;\n  };\n});\n\nconst AlterMethods = {\n  // Renames the current column `from` the current\n  // TODO: this.column(from).rename(to)\n  renameColumn(from, to) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'renameColumn',\n      args: [from, to],\n    });\n    return this;\n  },\n\n  dropTimestamps() {\n    // arguments[0] = useCamelCase\n    return this.dropColumns(\n      arguments[0] === true\n        ? ['createdAt', 'updatedAt']\n        : ['created_at', 'updated_at']\n    );\n  },\n\n  setNullable(column) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'setNullable',\n      args: [column],\n    });\n\n    return this;\n  },\n\n  check(checkPredicate, bindings, constraintName) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'check',\n      args: [checkPredicate, bindings, constraintName],\n    });\n  },\n\n  dropChecks() {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'dropChecks',\n      args: toArray(arguments),\n    });\n  },\n\n  dropNullable(column) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'dropNullable',\n      args: [column],\n    });\n\n    return this;\n  },\n\n  // TODO: changeType\n};\n\n// Drop a column from the current table.\n// TODO: Enable this.column(columnName).drop();\nAlterMethods.dropColumn = AlterMethods.dropColumns = function () {\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'dropColumn',\n    args: toArray(arguments),\n  });\n  return this;\n};\n\nTableBuilder.extend = (methodName, fn) => {\n  if (\n    Object.prototype.hasOwnProperty.call(TableBuilder.prototype, methodName)\n  ) {\n    throw new Error(\n      `Can't extend TableBuilder with existing method ('${methodName}').`\n    );\n  }\n\n  assign(TableBuilder.prototype, { [methodName]: fn });\n};\n\nmodule.exports = TableBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}