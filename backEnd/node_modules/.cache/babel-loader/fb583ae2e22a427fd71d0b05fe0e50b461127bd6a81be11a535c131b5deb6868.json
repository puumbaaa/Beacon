{"ast":null,"code":"// Sequence parser combinator\nfunction s(sequence, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    let position = index;\n    const ast = [];\n    for (const parser of sequence) {\n      const result = parser({\n        index: position,\n        input\n      });\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n    return {\n      success: true,\n      ast: post(ast),\n      index: position,\n      input\n    };\n  };\n}\n\n// Alternative parser combinator\nfunction a(alternative, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    for (const parser of alternative) {\n      const result = parser({\n        index,\n        input\n      });\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Many parser combinator\nfunction m(many, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    let result = {};\n    let position = index;\n    const ast = [];\n    do {\n      result = many({\n        index: position,\n        input\n      });\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n    if (ast.length > 0) {\n      return {\n        success: true,\n        ast: post(ast),\n        index: position,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index: position,\n        input\n      };\n    }\n  };\n}\n\n// Optional parser combinator\nfunction o(optional, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = optional({\n      index,\n      input\n    });\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input\n      };\n    } else {\n      return {\n        success: true,\n        ast: post(null),\n        index,\n        input\n      };\n    }\n  };\n}\n\n// Lookahead parser combinator\nfunction l(lookahead, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = lookahead.do({\n      index,\n      input\n    });\n    if (result.success) {\n      const resultNext = lookahead.next({\n        index: result.index,\n        input\n      });\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Negative parser combinator\nfunction n(negative, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = negative.do({\n      index,\n      input\n    });\n    if (result.success) {\n      const resultNot = negative.not({\n        index,\n        input\n      });\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Token parser combinator\nfunction t(token, post = v => v.text) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = input[index];\n    if (result !== undefined && (token.type === undefined || token.type === result.type) && (token.text === undefined || token.text.toUpperCase() === result.text.toUpperCase())) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index,\n        input\n      };\n    }\n  };\n}\n\n// Empty parser constant\nconst e = function ({\n  index = 0,\n  input\n}) {\n  return {\n    success: true,\n    ast: null,\n    index,\n    input\n  };\n};\n\n// Finish parser constant\nconst f = function ({\n  index = 0,\n  input\n}) {\n  return {\n    success: index === input.length,\n    ast: null,\n    index,\n    input\n  };\n};\nmodule.exports = {\n  s,\n  a,\n  m,\n  o,\n  l,\n  n,\n  t,\n  e,\n  f\n};","map":{"version":3,"names":["s","sequence","post","v","index","input","position","ast","parser","result","success","push","a","alternative","m","many","length","o","optional","l","lookahead","do","resultNext","next","n","negative","resultNot","not","t","token","text","undefined","type","toUpperCase","e","f","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js"],"sourcesContent":["// Sequence parser combinator\nfunction s(sequence, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let position = index;\n    const ast = [];\n\n    for (const parser of sequence) {\n      const result = parser({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n\n    return { success: true, ast: post(ast), index: position, input };\n  };\n}\n\n// Alternative parser combinator\nfunction a(alternative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    for (const parser of alternative) {\n      const result = parser({ index, input });\n\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Many parser combinator\nfunction m(many, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let result = {};\n    let position = index;\n    const ast = [];\n\n    do {\n      result = many({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n\n    if (ast.length > 0) {\n      return { success: true, ast: post(ast), index: position, input };\n    } else {\n      return { success: false, ast: null, index: position, input };\n    }\n  };\n}\n\n// Optional parser combinator\nfunction o(optional, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = optional({ index, input });\n\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input,\n      };\n    } else {\n      return { success: true, ast: post(null), index, input };\n    }\n  };\n}\n\n// Lookahead parser combinator\nfunction l(lookahead, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = lookahead.do({ index, input });\n\n    if (result.success) {\n      const resultNext = lookahead.next({ index: result.index, input });\n\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Negative parser combinator\nfunction n(negative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = negative.do({ index, input });\n\n    if (result.success) {\n      const resultNot = negative.not({ index, input });\n\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Token parser combinator\nfunction t(token, post = (v) => v.text) {\n  return function ({ index = 0, input }) {\n    const result = input[index];\n\n    if (\n      result !== undefined &&\n      (token.type === undefined || token.type === result.type) &&\n      (token.text === undefined ||\n        token.text.toUpperCase() === result.text.toUpperCase())\n    ) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input,\n      };\n    } else {\n      return { success: false, ast: null, index, input };\n    }\n  };\n}\n\n// Empty parser constant\nconst e = function ({ index = 0, input }) {\n  return { success: true, ast: null, index, input };\n};\n\n// Finish parser constant\nconst f = function ({ index = 0, input }) {\n  return { success: index === input.length, ast: null, index, input };\n};\n\nmodule.exports = { s, a, m, o, l, n, t, e, f };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}