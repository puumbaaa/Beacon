{"ast":null,"code":"// Redshift Query Builder & Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\nconst QueryCompiler_PG = require('../../postgres/query/pg-querycompiler');\nconst identity = require('lodash/identity');\nconst {\n  columnize: columnize_\n} = require('../../../formatter/wrappingFormatter');\nclass QueryCompiler_Redshift extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName.toLowerCase()}`;\n  }\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const sql = QueryCompiler.prototype.insert.apply(this, arguments);\n    if (sql === '') return sql;\n    this._slightReturn();\n    return {\n      sql\n    };\n  }\n\n  // Compiles an `update` query, warning on unsupported returning\n  update() {\n    const sql = QueryCompiler.prototype.update.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql\n    };\n  }\n\n  // Compiles an `delete` query, warning on unsupported returning\n  del() {\n    const sql = QueryCompiler.prototype.del.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql\n    };\n  }\n\n  // simple: if trying to return, warn\n  _slightReturn() {\n    if (this.single.isReturning) {\n      this.client.logger.warn('insert/update/delete returning is not supported by redshift dialect');\n    }\n  }\n  forUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n  forShare() {\n    this.client.logger.warn('lock for share is not supported by redshift dialect');\n    return '';\n  }\n  forNoKeyUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n  forKeyShare() {\n    this.client.logger.warn('lock for share is not supported by redshift dialect');\n    return '';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n    const sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [table.toLowerCase(), this.client.database().toLowerCase()];\n    return this._buildColumnInfoQuery(schema, sql, bindings, column);\n  }\n  jsonExtract(params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    return extractions.map(extraction => {\n      const jsonCol = `json_extract_path_text(${columnize_(extraction.column || extraction[0], this.builder, this.client, this.bindingsHolder)}, ${this.client.toPathForJson(params.path || extraction[1], this.builder, this.bindingsHolder)})`;\n      const alias = extraction.alias || extraction[2];\n      return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;\n    }).join(', ');\n  }\n  jsonSet(params) {\n    throw new Error('Json set is not supported by Redshift');\n  }\n  jsonInsert(params) {\n    throw new Error('Json insert is not supported by Redshift');\n  }\n  jsonRemove(params) {\n    throw new Error('Json remove is not supported by Redshift');\n  }\n  whereJsonPath(statement) {\n    return this._whereJsonPath('json_extract_path_text', Object.assign({}, statement, {\n      path: this.client.toPathForJson(statement.path)\n    }));\n  }\n  whereJsonSupersetOf(statement) {\n    throw new Error('Json superset is not supported by Redshift');\n  }\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset is not supported by Redshift');\n  }\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_extract_path_text', clause);\n  }\n}\nmodule.exports = QueryCompiler_Redshift;","map":{"version":3,"names":["QueryCompiler","require","QueryCompiler_PG","identity","columnize","columnize_","QueryCompiler_Redshift","truncate","tableName","toLowerCase","insert","sql","prototype","apply","arguments","_slightReturn","update","del","single","isReturning","client","logger","warn","forUpdate","forShare","forNoKeyUpdate","forKeyShare","columnInfo","column","schema","table","customWrapIdentifier","bindings","database","_buildColumnInfoQuery","jsonExtract","params","extractions","Array","isArray","map","extraction","jsonCol","builder","bindingsHolder","toPathForJson","path","alias","formatter","wrap","join","jsonSet","Error","jsonInsert","jsonRemove","whereJsonPath","statement","_whereJsonPath","Object","assign","whereJsonSupersetOf","whereJsonSubsetOf","onJsonPathEquals","clause","_onJsonPathEquals","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js"],"sourcesContent":["// Redshift Query Builder & Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\nconst QueryCompiler_PG = require('../../postgres/query/pg-querycompiler');\n\nconst identity = require('lodash/identity');\nconst {\n  columnize: columnize_,\n} = require('../../../formatter/wrappingFormatter');\n\nclass QueryCompiler_Redshift extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName.toLowerCase()}`;\n  }\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const sql = QueryCompiler.prototype.insert.apply(this, arguments);\n    if (sql === '') return sql;\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // Compiles an `update` query, warning on unsupported returning\n  update() {\n    const sql = QueryCompiler.prototype.update.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // Compiles an `delete` query, warning on unsupported returning\n  del() {\n    const sql = QueryCompiler.prototype.del.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // simple: if trying to return, warn\n  _slightReturn() {\n    if (this.single.isReturning) {\n      this.client.logger.warn(\n        'insert/update/delete returning is not supported by redshift dialect'\n      );\n    }\n  }\n\n  forUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n\n  forShare() {\n    this.client.logger.warn(\n      'lock for share is not supported by redshift dialect'\n    );\n    return '';\n  }\n\n  forNoKeyUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n\n  forKeyShare() {\n    this.client.logger.warn(\n      'lock for share is not supported by redshift dialect'\n    );\n    return '';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    const sql =\n      'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [\n      table.toLowerCase(),\n      this.client.database().toLowerCase(),\n    ];\n\n    return this._buildColumnInfoQuery(schema, sql, bindings, column);\n  }\n\n  jsonExtract(params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    return extractions\n      .map((extraction) => {\n        const jsonCol = `json_extract_path_text(${columnize_(\n          extraction.column || extraction[0],\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )}, ${this.client.toPathForJson(\n          params.path || extraction[1],\n          this.builder,\n          this.bindingsHolder\n        )})`;\n        const alias = extraction.alias || extraction[2];\n        return alias\n          ? this.client.alias(jsonCol, this.formatter.wrap(alias))\n          : jsonCol;\n      })\n      .join(', ');\n  }\n\n  jsonSet(params) {\n    throw new Error('Json set is not supported by Redshift');\n  }\n\n  jsonInsert(params) {\n    throw new Error('Json insert is not supported by Redshift');\n  }\n\n  jsonRemove(params) {\n    throw new Error('Json remove is not supported by Redshift');\n  }\n\n  whereJsonPath(statement) {\n    return this._whereJsonPath(\n      'json_extract_path_text',\n      Object.assign({}, statement, {\n        path: this.client.toPathForJson(statement.path),\n      })\n    );\n  }\n\n  whereJsonSupersetOf(statement) {\n    throw new Error('Json superset is not supported by Redshift');\n  }\n\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset is not supported by Redshift');\n  }\n\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_extract_path_text', clause);\n  }\n}\n\nmodule.exports = QueryCompiler_Redshift;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}