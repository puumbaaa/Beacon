{"ast":null,"code":"// MSSQL Query Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst Raw = require('../../../raw.js');\nconst {\n  columnize: columnize_\n} = require('../../../formatter/wrappingFormatter');\nconst components = ['comments', 'columns', 'join', 'lock', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset'];\nclass QueryCompiler_MSSQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      onConflict\n    } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for mssql.');\n    }\n    this._emptyInsertValue = 'default values';\n  }\n  with() {\n    // WITH RECURSIVE is a syntax error:\n    // SQL Server does not syntactically distinguish recursive and non-recursive CTEs.\n    // So mark all statements as non-recursive, generate the SQL, then restore.\n    // This approach ensures any changes in base class with() get propagated here.\n    const undoList = [];\n    if (this.grouped.with) {\n      for (const stmt of this.grouped.with) {\n        if (stmt.recursive) {\n          undoList.push(stmt);\n          stmt.recursive = false;\n        }\n      }\n    }\n    const result = super.with();\n\n    // Restore the recursive markings, in case this same query gets cloned and passed to other drivers.\n    for (const stmt of undoList) {\n      stmt.recursive = true;\n    }\n    return result;\n  }\n  select() {\n    const sql = this.with();\n    const statements = components.map(component => this[component](this));\n    return sql + compact(statements).join(' ');\n  }\n\n  //#region Insert\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.insertWithTriggers();\n    } else {\n      return this.standardInsert();\n    }\n  }\n  insertWithTriggers() {\n    const insertValues = this.single.insert || [];\n    const {\n      returning\n    } = this.single;\n    let sql = this.with() + `${this._buildTempTable(returning)}insert into ${this.tableName} `;\n    const returningSql = returning ? this._returning('insert', returning, true) + ' ' : '';\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue + this._buildReturningSelect(returning),\n        returning\n      };\n    }\n    sql += this._buildInsertData(insertValues, returningSql);\n    if (returning) {\n      sql += this._buildReturningSelect(returning);\n    }\n    return {\n      sql,\n      returning\n    };\n  }\n  _buildInsertData(insertValues, returningSql) {\n    let sql = '';\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql += `) ${returningSql}values (` + this._buildInsertValues(insertData) + ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        return '';\n      }\n    }\n    return sql;\n  }\n  standardInsert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    const {\n      returning\n    } = this.single;\n    const returningSql = returning ? this._returning('insert', returning) + ' ' : '';\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue,\n        returning\n      };\n    }\n    sql += this._buildInsertData(insertValues, returningSql);\n    return {\n      sql,\n      returning\n    };\n  }\n  //#endregion\n\n  //#region Update\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.updateWithTriggers();\n    } else {\n      return this.standardUpdate();\n    }\n  }\n  updateWithTriggers() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const {\n      returning\n    } = this.single;\n    const declaredTemp = this._buildTempTable(returning);\n    return {\n      sql: withSQL + declaredTemp + `update ${top ? top + ' ' : ''}${this.tableName}` + ' set ' + updates.join(', ') + (returning ? ` ${this._returning('update', returning, true)}` : '') + (join ? ` from ${this.tableName} ${join}` : '') + (where ? ` ${where}` : '') + (order ? ` ${order}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount'\n    };\n  }\n  _formatGroupsItemValue(value, nulls) {\n    const column = super._formatGroupsItemValue(value);\n    // MSSQL dont support 'is null' syntax in order by,\n    // so we override this function and add MSSQL specific syntax.\n    if (nulls && !(value instanceof Raw)) {\n      const collNulls = `IIF(${column} is null,`;\n      if (nulls === 'first') {\n        return `${collNulls}0,1)`;\n      } else if (nulls === 'last') {\n        return `${collNulls}1,0)`;\n      }\n    }\n    return column;\n  }\n  standardUpdate() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `update ${top ? top + ' ' : ''}${this.tableName}` + ' set ' + updates.join(', ') + (returning ? ` ${this._returning('update', returning)}` : '') + (join ? ` from ${this.tableName} ${join}` : '') + (where ? ` ${where}` : '') + (order ? ` ${order}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  }\n  //#endregion\n\n  //#region Delete\n  // Compiles a `delete` query.\n  del() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.deleteWithTriggers();\n    } else {\n      return this.standardDelete();\n    }\n  }\n  deleteWithTriggers() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n    const wheres = this.where();\n    const joins = this.join();\n    const {\n      returning\n    } = this.single;\n    const returningStr = returning ? ` ${this._returning('del', returning, true)}` : '';\n    const deleteSelector = joins ? `${tableName}${returningStr} ` : '';\n    return {\n      sql: withSQL + `${this._buildTempTable(returning)}delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : '') + (joins ? ` ${joins}` : '') + (wheres ? ` ${wheres}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount'\n    };\n  }\n  standardDelete() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n    const wheres = this.where();\n    const joins = this.join();\n    const {\n      returning\n    } = this.single;\n    const returningStr = returning ? ` ${this._returning('del', returning)}` : '';\n    // returning needs to be before \"from\" when using join\n    const deleteSelector = joins ? `${tableName}${returningStr} ` : '';\n    return {\n      sql: withSQL + `delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : '') + (joins ? ` ${joins}` : '') + (wheres ? ` ${wheres}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  }\n  //#endregion\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const top = this.top();\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.type === 'json') {\n          sql.push(this.json(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n    const select = this.onlyJson() ? '' : 'select ';\n    return `${select}${hints}${distinctClause}` + (top ? top + ' ' : '') + sql.join(', ') + (this.tableName ? ` from ${this.tableName}` : '');\n  }\n  _returning(method, value, withTrigger) {\n    switch (method) {\n      case 'update':\n      case 'insert':\n        return value ? `output ${this.formatter.columnizeWithPrefix('inserted.', value)}${withTrigger ? ' into #out' : ''}` : '';\n      case 'del':\n        return value ? `output ${this.formatter.columnizeWithPrefix('deleted.', value)}${withTrigger ? ' into #out' : ''}` : '';\n      case 'rowcount':\n        return value ? ';select @@rowcount' : '';\n    }\n  }\n  _buildTempTable(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build values that will be returned from this procedure\n      if (Array.isArray(values)) {\n        selections = values.map(value => `[t].${this.formatter.columnize(value)}`).join(',');\n      } else {\n        selections = `[t].${this.formatter.columnize(values)}`;\n      }\n\n      // Force #out to be correctly populated with the correct column structure.\n      let sql = `select top(0) ${selections} into #out `;\n      sql += `from ${this.tableName} as t `;\n      sql += `left join ${this.tableName} on 0=1;`;\n      return sql;\n    }\n    return '';\n  }\n  _buildReturningSelect(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build columns to return\n      if (Array.isArray(values)) {\n        selections = values.map(value => `${this.formatter.columnize(value)}`).join(',');\n      } else {\n        selections = this.formatter.columnize(values);\n      }\n\n      // Get the returned values\n      let sql = `; select ${selections} from #out; `;\n      // Drop the temp table to prevent memory leaks\n      sql += `drop table #out;`;\n      return sql;\n    }\n    return '';\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n  forUpdate() {\n    // this doesn't work exacltly as it should, one should also mention index while locking\n    // https://stackoverflow.com/a/9818448/360060\n    return 'with (UPDLOCK)';\n  }\n  forShare() {\n    // http://www.sqlteam.com/article/introduction-to-locking-in-sql-server\n    return 'with (HOLDLOCK)';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    // GOTCHA: INFORMATION_SCHEMA.COLUMNS must be capitalized to work when the database has a case-sensitive collation. [#4573]\n    let sql = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from INFORMATION_SCHEMA.COLUMNS where table_name = ? and table_catalog = ?`;\n    const bindings = [table, this.client.database()];\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ` and table_schema = 'dbo'`;\n    }\n    return {\n      sql,\n      bindings: bindings,\n      output(resp) {\n        const out = resp.reduce((columns, val) => {\n          columns[val[0].value] = {\n            defaultValue: val[1].value,\n            type: val[2].value,\n            maxLength: val[3].value,\n            nullable: val[4].value === 'YES'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n  top() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noLimit || !noOffset) return '';\n    return `top (${this._getValueOrParameterFromAttribute('limit')})`;\n  }\n  limit() {\n    return '';\n  }\n  offset() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noOffset) return '';\n    let offset = `offset ${noOffset ? '0' : this._getValueOrParameterFromAttribute('offset')} rows`;\n    if (!noLimit) {\n      offset += ` fetch next ${this._getValueOrParameterFromAttribute('limit')} rows only`;\n    }\n    return offset;\n  }\n  whereLike(statement) {\n    return `${this._columnClause(statement)} collate SQL_Latin1_General_CP1_CS_AS ${this._not(statement, 'like ')}${this._valueClause(statement)}`;\n  }\n  whereILike(statement) {\n    return `${this._columnClause(statement)} collate SQL_Latin1_General_CP1_CI_AS ${this._not(statement, 'like ')}${this._valueClause(statement)}`;\n  }\n  jsonExtract(params) {\n    // JSON_VALUE return NULL if we query object or array\n    // JSON_QUERY return NULL if we query literal/single value\n    return this._jsonExtract(params.singleValue ? 'JSON_VALUE' : 'JSON_QUERY', params);\n  }\n  jsonSet(params) {\n    return this._jsonSet('JSON_MODIFY', params);\n  }\n  jsonInsert(params) {\n    return this._jsonSet('JSON_MODIFY', params);\n  }\n  jsonRemove(params) {\n    const jsonCol = `JSON_MODIFY(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)},${this.client.parameter(params.path, this.builder, this.bindingsHolder)}, NULL)`;\n    return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;\n  }\n  whereJsonPath(statement) {\n    return this._whereJsonPath('JSON_VALUE', statement);\n  }\n  whereJsonSupersetOf(statement) {\n    throw new Error('Json superset where clause not actually supported by MSSQL');\n  }\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset where clause not actually supported by MSSQL');\n  }\n  _getExtracts(statement, operator) {\n    const column = columnize_(statement.column, this.builder, this.client, this.bindingsHolder);\n    return (Array.isArray(statement.values) ? statement.values : [statement.values]).map(function (value) {\n      return 'JSON_VALUE(' + column + ',' + this.client.parameter(value, this.builder, this.bindingsHolder) + ')';\n    }, this).join(operator);\n  }\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('JSON_VALUE', clause);\n  }\n}\n\n// Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\nmodule.exports = QueryCompiler_MSSQL;","map":{"version":3,"names":["QueryCompiler","require","compact","identity","isEmpty","Raw","columnize","columnize_","components","QueryCompiler_MSSQL","constructor","client","builder","formatter","onConflict","single","Error","_emptyInsertValue","with","undoList","grouped","stmt","recursive","push","result","select","sql","statements","map","component","join","insert","options","includeTriggerModifications","insertWithTriggers","standardInsert","insertValues","returning","_buildTempTable","tableName","returningSql","_returning","Array","isArray","length","_buildReturningSelect","_buildInsertData","insertData","_prepInsert","columns","_buildInsertValues","update","updateWithTriggers","standardUpdate","top","withSQL","updates","_prepUpdate","where","order","declaredTemp","_formatGroupsItemValue","value","nulls","column","collNulls","del","deleteWithTriggers","standardDelete","wheres","joins","returningStr","deleteSelector","distinctClause","onlyUnions","hints","_hintComments","i","distinct","distinctOn","type","aggregate","aggregateRaw","analytic","json","onlyJson","method","withTrigger","columnizeWithPrefix","values","selections","truncate","forUpdate","forShare","columnInfo","schema","table","customWrapIdentifier","bindings","database","output","resp","out","reduce","val","defaultValue","maxLength","nullable","noLimit","limit","noOffset","offset","_getValueOrParameterFromAttribute","whereLike","statement","_columnClause","_not","_valueClause","whereILike","jsonExtract","params","_jsonExtract","singleValue","jsonSet","_jsonSet","jsonInsert","jsonRemove","jsonCol","bindingsHolder","parameter","path","alias","wrap","whereJsonPath","_whereJsonPath","whereJsonSupersetOf","whereJsonSubsetOf","_getExtracts","operator","onJsonPathEquals","clause","_onJsonPathEquals","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js"],"sourcesContent":["// MSSQL Query Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst Raw = require('../../../raw.js');\nconst {\n  columnize: columnize_,\n} = require('../../../formatter/wrappingFormatter');\n\nconst components = [\n  'comments',\n  'columns',\n  'join',\n  'lock',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'limit',\n  'offset',\n];\n\nclass QueryCompiler_MSSQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { onConflict } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for mssql.');\n    }\n\n    this._emptyInsertValue = 'default values';\n  }\n\n  with() {\n    // WITH RECURSIVE is a syntax error:\n    // SQL Server does not syntactically distinguish recursive and non-recursive CTEs.\n    // So mark all statements as non-recursive, generate the SQL, then restore.\n    // This approach ensures any changes in base class with() get propagated here.\n    const undoList = [];\n    if (this.grouped.with) {\n      for (const stmt of this.grouped.with) {\n        if (stmt.recursive) {\n          undoList.push(stmt);\n          stmt.recursive = false;\n        }\n      }\n    }\n\n    const result = super.with();\n\n    // Restore the recursive markings, in case this same query gets cloned and passed to other drivers.\n    for (const stmt of undoList) {\n      stmt.recursive = true;\n    }\n    return result;\n  }\n\n  select() {\n    const sql = this.with();\n    const statements = components.map((component) => this[component](this));\n    return sql + compact(statements).join(' ');\n  }\n\n  //#region Insert\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.insertWithTriggers();\n    } else {\n      return this.standardInsert();\n    }\n  }\n\n  insertWithTriggers() {\n    const insertValues = this.single.insert || [];\n    const { returning } = this.single;\n    let sql =\n      this.with() +\n      `${this._buildTempTable(returning)}insert into ${this.tableName} `;\n    const returningSql = returning\n      ? this._returning('insert', returning, true) + ' '\n      : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql:\n          sql +\n          returningSql +\n          this._emptyInsertValue +\n          this._buildReturningSelect(returning),\n        returning,\n      };\n    }\n    sql += this._buildInsertData(insertValues, returningSql);\n\n    if (returning) {\n      sql += this._buildReturningSelect(returning);\n    }\n\n    return {\n      sql,\n      returning,\n    };\n  }\n\n  _buildInsertData(insertValues, returningSql) {\n    let sql = '';\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql +=\n          `) ${returningSql}values (` +\n          this._buildInsertValues(insertData) +\n          ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        return '';\n      }\n    }\n    return sql;\n  }\n\n  standardInsert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    const { returning } = this.single;\n    const returningSql = returning\n      ? this._returning('insert', returning) + ' '\n      : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue,\n        returning,\n      };\n    }\n\n    sql += this._buildInsertData(insertValues, returningSql);\n\n    return {\n      sql,\n      returning,\n    };\n  }\n  //#endregion\n\n  //#region Update\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.updateWithTriggers();\n    } else {\n      return this.standardUpdate();\n    }\n  }\n\n  updateWithTriggers() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const { returning } = this.single;\n    const declaredTemp = this._buildTempTable(returning);\n    return {\n      sql:\n        withSQL +\n        declaredTemp +\n        `update ${top ? top + ' ' : ''}${this.tableName}` +\n        ' set ' +\n        updates.join(', ') +\n        (returning ? ` ${this._returning('update', returning, true)}` : '') +\n        (join ? ` from ${this.tableName} ${join}` : '') +\n        (where ? ` ${where}` : '') +\n        (order ? ` ${order}` : '') +\n        (!returning\n          ? this._returning('rowcount', '@@rowcount')\n          : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount',\n    };\n  }\n\n  _formatGroupsItemValue(value, nulls) {\n    const column = super._formatGroupsItemValue(value);\n    // MSSQL dont support 'is null' syntax in order by,\n    // so we override this function and add MSSQL specific syntax.\n    if (nulls && !(value instanceof Raw)) {\n      const collNulls = `IIF(${column} is null,`;\n      if (nulls === 'first') {\n        return `${collNulls}0,1)`;\n      } else if (nulls === 'last') {\n        return `${collNulls}1,0)`;\n      }\n    }\n    return column;\n  }\n\n  standardUpdate() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `update ${top ? top + ' ' : ''}${this.tableName}` +\n        ' set ' +\n        updates.join(', ') +\n        (returning ? ` ${this._returning('update', returning)}` : '') +\n        (join ? ` from ${this.tableName} ${join}` : '') +\n        (where ? ` ${where}` : '') +\n        (order ? ` ${order}` : '') +\n        (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount',\n    };\n  }\n  //#endregion\n\n  //#region Delete\n  // Compiles a `delete` query.\n  del() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.deleteWithTriggers();\n    } else {\n      return this.standardDelete();\n    }\n  }\n\n  deleteWithTriggers() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const wheres = this.where();\n    const joins = this.join();\n    const { returning } = this.single;\n    const returningStr = returning\n      ? ` ${this._returning('del', returning, true)}`\n      : '';\n    const deleteSelector = joins ? `${tableName}${returningStr} ` : '';\n    return {\n      sql:\n        withSQL +\n        `${this._buildTempTable(\n          returning\n        )}delete ${deleteSelector}from ${tableName}` +\n        (!joins ? returningStr : '') +\n        (joins ? ` ${joins}` : '') +\n        (wheres ? ` ${wheres}` : '') +\n        (!returning\n          ? this._returning('rowcount', '@@rowcount')\n          : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount',\n    };\n  }\n\n  standardDelete() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const wheres = this.where();\n    const joins = this.join();\n    const { returning } = this.single;\n    const returningStr = returning\n      ? ` ${this._returning('del', returning)}`\n      : '';\n    // returning needs to be before \"from\" when using join\n    const deleteSelector = joins ? `${tableName}${returningStr} ` : '';\n    return {\n      sql:\n        withSQL +\n        `delete ${deleteSelector}from ${tableName}` +\n        (!joins ? returningStr : '') +\n        (joins ? ` ${joins}` : '') +\n        (wheres ? ` ${wheres}` : '') +\n        (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount',\n    };\n  }\n  //#endregion\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const top = this.top();\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.type === 'json') {\n          sql.push(this.json(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n    const select = this.onlyJson() ? '' : 'select ';\n    return (\n      `${select}${hints}${distinctClause}` +\n      (top ? top + ' ' : '') +\n      sql.join(', ') +\n      (this.tableName ? ` from ${this.tableName}` : '')\n    );\n  }\n\n  _returning(method, value, withTrigger) {\n    switch (method) {\n      case 'update':\n      case 'insert':\n        return value\n          ? `output ${this.formatter.columnizeWithPrefix('inserted.', value)}${\n              withTrigger ? ' into #out' : ''\n            }`\n          : '';\n      case 'del':\n        return value\n          ? `output ${this.formatter.columnizeWithPrefix('deleted.', value)}${\n              withTrigger ? ' into #out' : ''\n            }`\n          : '';\n      case 'rowcount':\n        return value ? ';select @@rowcount' : '';\n    }\n  }\n\n  _buildTempTable(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build values that will be returned from this procedure\n      if (Array.isArray(values)) {\n        selections = values\n          .map((value) => `[t].${this.formatter.columnize(value)}`)\n          .join(',');\n      } else {\n        selections = `[t].${this.formatter.columnize(values)}`;\n      }\n\n      // Force #out to be correctly populated with the correct column structure.\n      let sql = `select top(0) ${selections} into #out `;\n      sql += `from ${this.tableName} as t `;\n      sql += `left join ${this.tableName} on 0=1;`;\n\n      return sql;\n    }\n\n    return '';\n  }\n\n  _buildReturningSelect(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build columns to return\n      if (Array.isArray(values)) {\n        selections = values\n          .map((value) => `${this.formatter.columnize(value)}`)\n          .join(',');\n      } else {\n        selections = this.formatter.columnize(values);\n      }\n\n      // Get the returned values\n      let sql = `; select ${selections} from #out; `;\n      // Drop the temp table to prevent memory leaks\n      sql += `drop table #out;`;\n\n      return sql;\n    }\n\n    return '';\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    // this doesn't work exacltly as it should, one should also mention index while locking\n    // https://stackoverflow.com/a/9818448/360060\n    return 'with (UPDLOCK)';\n  }\n\n  forShare() {\n    // http://www.sqlteam.com/article/introduction-to-locking-in-sql-server\n    return 'with (HOLDLOCK)';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    // GOTCHA: INFORMATION_SCHEMA.COLUMNS must be capitalized to work when the database has a case-sensitive collation. [#4573]\n    let sql = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from INFORMATION_SCHEMA.COLUMNS where table_name = ? and table_catalog = ?`;\n    const bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ` and table_schema = 'dbo'`;\n    }\n\n    return {\n      sql,\n      bindings: bindings,\n      output(resp) {\n        const out = resp.reduce((columns, val) => {\n          columns[val[0].value] = {\n            defaultValue: val[1].value,\n            type: val[2].value,\n            maxLength: val[3].value,\n            nullable: val[4].value === 'YES',\n          };\n          return columns;\n        }, {});\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  top() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noLimit || !noOffset) return '';\n    return `top (${this._getValueOrParameterFromAttribute('limit')})`;\n  }\n\n  limit() {\n    return '';\n  }\n\n  offset() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noOffset) return '';\n    let offset = `offset ${\n      noOffset ? '0' : this._getValueOrParameterFromAttribute('offset')\n    } rows`;\n    if (!noLimit) {\n      offset += ` fetch next ${this._getValueOrParameterFromAttribute(\n        'limit'\n      )} rows only`;\n    }\n    return offset;\n  }\n\n  whereLike(statement) {\n    return `${this._columnClause(\n      statement\n    )} collate SQL_Latin1_General_CP1_CS_AS ${this._not(\n      statement,\n      'like '\n    )}${this._valueClause(statement)}`;\n  }\n\n  whereILike(statement) {\n    return `${this._columnClause(\n      statement\n    )} collate SQL_Latin1_General_CP1_CI_AS ${this._not(\n      statement,\n      'like '\n    )}${this._valueClause(statement)}`;\n  }\n\n  jsonExtract(params) {\n    // JSON_VALUE return NULL if we query object or array\n    // JSON_QUERY return NULL if we query literal/single value\n    return this._jsonExtract(\n      params.singleValue ? 'JSON_VALUE' : 'JSON_QUERY',\n      params\n    );\n  }\n\n  jsonSet(params) {\n    return this._jsonSet('JSON_MODIFY', params);\n  }\n\n  jsonInsert(params) {\n    return this._jsonSet('JSON_MODIFY', params);\n  }\n\n  jsonRemove(params) {\n    const jsonCol = `JSON_MODIFY(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )},${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )}, NULL)`;\n    return params.alias\n      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))\n      : jsonCol;\n  }\n\n  whereJsonPath(statement) {\n    return this._whereJsonPath('JSON_VALUE', statement);\n  }\n\n  whereJsonSupersetOf(statement) {\n    throw new Error(\n      'Json superset where clause not actually supported by MSSQL'\n    );\n  }\n\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset where clause not actually supported by MSSQL');\n  }\n\n  _getExtracts(statement, operator) {\n    const column = columnize_(\n      statement.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (\n      Array.isArray(statement.values) ? statement.values : [statement.values]\n    )\n      .map(function (value) {\n        return (\n          'JSON_VALUE(' +\n          column +\n          ',' +\n          this.client.parameter(value, this.builder, this.bindingsHolder) +\n          ')'\n        );\n      }, this)\n      .join(operator);\n  }\n\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('JSON_VALUE', clause);\n  }\n}\n\n// Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\nmodule.exports = QueryCompiler_MSSQL;\n"],"mappings":"AAAA;AACA;AACA,MAAMA,aAAa,GAAGC,OAAO,CAAC,8BAA8B,CAAC;AAE7D,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAME,QAAQ,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMG,OAAO,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAMI,GAAG,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AACtC,MAAM;EACJK,SAAS,EAAEC;AACb,CAAC,GAAGN,OAAO,CAAC,sCAAsC,CAAC;AAEnD,MAAMO,UAAU,GAAG,CACjB,UAAU,EACV,SAAS,EACT,MAAM,EACN,MAAM,EACN,OAAO,EACP,OAAO,EACP,OAAO,EACP,QAAQ,EACR,OAAO,EACP,OAAO,EACP,QAAQ,CACT;AAED,MAAMC,mBAAmB,SAAST,aAAa,CAAC;EAC9CU,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAEC,SAAS,EAAE;IACtC,KAAK,CAACF,MAAM,EAAEC,OAAO,EAAEC,SAAS,CAAC;IAEjC,MAAM;MAAEC;IAAW,CAAC,GAAG,IAAI,CAACC,MAAM;IAClC,IAAID,UAAU,EAAE;MACd,MAAM,IAAIE,KAAK,CAAC,2CAA2C,CAAC;IAC9D;IAEA,IAAI,CAACC,iBAAiB,GAAG,gBAAgB;EAC3C;EAEAC,IAAIA,CAAA,EAAG;IACL;IACA;IACA;IACA;IACA,MAAMC,QAAQ,GAAG,EAAE;IACnB,IAAI,IAAI,CAACC,OAAO,CAACF,IAAI,EAAE;MACrB,KAAK,MAAMG,IAAI,IAAI,IAAI,CAACD,OAAO,CAACF,IAAI,EAAE;QACpC,IAAIG,IAAI,CAACC,SAAS,EAAE;UAClBH,QAAQ,CAACI,IAAI,CAACF,IAAI,CAAC;UACnBA,IAAI,CAACC,SAAS,GAAG,KAAK;QACxB;MACF;IACF;IAEA,MAAME,MAAM,GAAG,KAAK,CAACN,IAAI,CAAC,CAAC;;IAE3B;IACA,KAAK,MAAMG,IAAI,IAAIF,QAAQ,EAAE;MAC3BE,IAAI,CAACC,SAAS,GAAG,IAAI;IACvB;IACA,OAAOE,MAAM;EACf;EAEAC,MAAMA,CAAA,EAAG;IACP,MAAMC,GAAG,GAAG,IAAI,CAACR,IAAI,CAAC,CAAC;IACvB,MAAMS,UAAU,GAAGnB,UAAU,CAACoB,GAAG,CAAEC,SAAS,IAAK,IAAI,CAACA,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC;IACvE,OAAOH,GAAG,GAAGxB,OAAO,CAACyB,UAAU,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC;EAC5C;;EAEA;EACA;EACA;EACAC,MAAMA,CAAA,EAAG;IACP,IACE,IAAI,CAAChB,MAAM,CAACiB,OAAO,IACnB,IAAI,CAACjB,MAAM,CAACiB,OAAO,CAACC,2BAA2B,EAC/C;MACA,OAAO,IAAI,CAACC,kBAAkB,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,OAAO,IAAI,CAACC,cAAc,CAAC,CAAC;IAC9B;EACF;EAEAD,kBAAkBA,CAAA,EAAG;IACnB,MAAME,YAAY,GAAG,IAAI,CAACrB,MAAM,CAACgB,MAAM,IAAI,EAAE;IAC7C,MAAM;MAAEM;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,IAAIW,GAAG,GACL,IAAI,CAACR,IAAI,CAAC,CAAC,GACX,GAAG,IAAI,CAACoB,eAAe,CAACD,SAAS,CAAC,eAAe,IAAI,CAACE,SAAS,GAAG;IACpE,MAAMC,YAAY,GAAGH,SAAS,GAC1B,IAAI,CAACI,UAAU,CAAC,QAAQ,EAAEJ,SAAS,EAAE,IAAI,CAAC,GAAG,GAAG,GAChD,EAAE;IAEN,IAAIK,KAAK,CAACC,OAAO,CAACP,YAAY,CAAC,EAAE;MAC/B,IAAIA,YAAY,CAACQ,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,EAAE;MACX;IACF,CAAC,MAAM,IAAI,OAAOR,YAAY,KAAK,QAAQ,IAAIhC,OAAO,CAACgC,YAAY,CAAC,EAAE;MACpE,OAAO;QACLV,GAAG,EACDA,GAAG,GACHc,YAAY,GACZ,IAAI,CAACvB,iBAAiB,GACtB,IAAI,CAAC4B,qBAAqB,CAACR,SAAS,CAAC;QACvCA;MACF,CAAC;IACH;IACAX,GAAG,IAAI,IAAI,CAACoB,gBAAgB,CAACV,YAAY,EAAEI,YAAY,CAAC;IAExD,IAAIH,SAAS,EAAE;MACbX,GAAG,IAAI,IAAI,CAACmB,qBAAqB,CAACR,SAAS,CAAC;IAC9C;IAEA,OAAO;MACLX,GAAG;MACHW;IACF,CAAC;EACH;EAEAS,gBAAgBA,CAACV,YAAY,EAAEI,YAAY,EAAE;IAC3C,IAAId,GAAG,GAAG,EAAE;IACZ,MAAMqB,UAAU,GAAG,IAAI,CAACC,WAAW,CAACZ,YAAY,CAAC;IACjD,IAAI,OAAOW,UAAU,KAAK,QAAQ,EAAE;MAClCrB,GAAG,IAAIqB,UAAU;IACnB,CAAC,MAAM;MACL,IAAIA,UAAU,CAACE,OAAO,CAACL,MAAM,EAAE;QAC7BlB,GAAG,IAAI,IAAI,IAAI,CAACb,SAAS,CAACP,SAAS,CAACyC,UAAU,CAACE,OAAO,CAAC,EAAE;QACzDvB,GAAG,IACD,KAAKc,YAAY,UAAU,GAC3B,IAAI,CAACU,kBAAkB,CAACH,UAAU,CAAC,GACnC,GAAG;MACP,CAAC,MAAM,IAAIX,YAAY,CAACQ,MAAM,KAAK,CAAC,IAAIR,YAAY,CAAC,CAAC,CAAC,EAAE;QACvDV,GAAG,IAAIc,YAAY,GAAG,IAAI,CAACvB,iBAAiB;MAC9C,CAAC,MAAM;QACL,OAAO,EAAE;MACX;IACF;IACA,OAAOS,GAAG;EACZ;EAEAS,cAAcA,CAAA,EAAG;IACf,MAAMC,YAAY,GAAG,IAAI,CAACrB,MAAM,CAACgB,MAAM,IAAI,EAAE;IAC7C,IAAIL,GAAG,GAAG,IAAI,CAACR,IAAI,CAAC,CAAC,GAAG,eAAe,IAAI,CAACqB,SAAS,GAAG;IACxD,MAAM;MAAEF;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,MAAMyB,YAAY,GAAGH,SAAS,GAC1B,IAAI,CAACI,UAAU,CAAC,QAAQ,EAAEJ,SAAS,CAAC,GAAG,GAAG,GAC1C,EAAE;IAEN,IAAIK,KAAK,CAACC,OAAO,CAACP,YAAY,CAAC,EAAE;MAC/B,IAAIA,YAAY,CAACQ,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,EAAE;MACX;IACF,CAAC,MAAM,IAAI,OAAOR,YAAY,KAAK,QAAQ,IAAIhC,OAAO,CAACgC,YAAY,CAAC,EAAE;MACpE,OAAO;QACLV,GAAG,EAAEA,GAAG,GAAGc,YAAY,GAAG,IAAI,CAACvB,iBAAiB;QAChDoB;MACF,CAAC;IACH;IAEAX,GAAG,IAAI,IAAI,CAACoB,gBAAgB,CAACV,YAAY,EAAEI,YAAY,CAAC;IAExD,OAAO;MACLd,GAAG;MACHW;IACF,CAAC;EACH;EACA;;EAEA;EACA;EACAc,MAAMA,CAAA,EAAG;IACP,IACE,IAAI,CAACpC,MAAM,CAACiB,OAAO,IACnB,IAAI,CAACjB,MAAM,CAACiB,OAAO,CAACC,2BAA2B,EAC/C;MACA,OAAO,IAAI,CAACmB,kBAAkB,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,OAAO,IAAI,CAACC,cAAc,CAAC,CAAC;IAC9B;EACF;EAEAD,kBAAkBA,CAAA,EAAG;IACnB,MAAME,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC,CAAC;IACtB,MAAMC,OAAO,GAAG,IAAI,CAACrC,IAAI,CAAC,CAAC;IAC3B,MAAMsC,OAAO,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC1C,MAAM,CAACoC,MAAM,CAAC;IACpD,MAAMrB,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC;IACxB,MAAM4B,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IAC1B,MAAMC,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IAC1B,MAAM;MAAEtB;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,MAAM6C,YAAY,GAAG,IAAI,CAACtB,eAAe,CAACD,SAAS,CAAC;IACpD,OAAO;MACLX,GAAG,EACD6B,OAAO,GACPK,YAAY,GACZ,UAAUN,GAAG,GAAGA,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,CAACf,SAAS,EAAE,GACjD,OAAO,GACPiB,OAAO,CAAC1B,IAAI,CAAC,IAAI,CAAC,IACjBO,SAAS,GAAG,IAAI,IAAI,CAACI,UAAU,CAAC,QAAQ,EAAEJ,SAAS,EAAE,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC,IAClEP,IAAI,GAAG,SAAS,IAAI,CAACS,SAAS,IAAIT,IAAI,EAAE,GAAG,EAAE,CAAC,IAC9C4B,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzBC,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzB,CAACtB,SAAS,GACP,IAAI,CAACI,UAAU,CAAC,UAAU,EAAE,YAAY,CAAC,GACzC,IAAI,CAACI,qBAAqB,CAACR,SAAS,CAAC,CAAC;MAC5CA,SAAS,EAAEA,SAAS,IAAI;IAC1B,CAAC;EACH;EAEAwB,sBAAsBA,CAACC,KAAK,EAAEC,KAAK,EAAE;IACnC,MAAMC,MAAM,GAAG,KAAK,CAACH,sBAAsB,CAACC,KAAK,CAAC;IAClD;IACA;IACA,IAAIC,KAAK,IAAI,EAAED,KAAK,YAAYzD,GAAG,CAAC,EAAE;MACpC,MAAM4D,SAAS,GAAG,OAAOD,MAAM,WAAW;MAC1C,IAAID,KAAK,KAAK,OAAO,EAAE;QACrB,OAAO,GAAGE,SAAS,MAAM;MAC3B,CAAC,MAAM,IAAIF,KAAK,KAAK,MAAM,EAAE;QAC3B,OAAO,GAAGE,SAAS,MAAM;MAC3B;IACF;IACA,OAAOD,MAAM;EACf;EAEAX,cAAcA,CAAA,EAAG;IACf,MAAMC,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC,CAAC;IACtB,MAAMC,OAAO,GAAG,IAAI,CAACrC,IAAI,CAAC,CAAC;IAC3B,MAAMsC,OAAO,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC1C,MAAM,CAACoC,MAAM,CAAC;IACpD,MAAMrB,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC;IACxB,MAAM4B,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IAC1B,MAAMC,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IAC1B,MAAM;MAAEtB;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,OAAO;MACLW,GAAG,EACD6B,OAAO,GACP,UAAUD,GAAG,GAAGA,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,CAACf,SAAS,EAAE,GACjD,OAAO,GACPiB,OAAO,CAAC1B,IAAI,CAAC,IAAI,CAAC,IACjBO,SAAS,GAAG,IAAI,IAAI,CAACI,UAAU,CAAC,QAAQ,EAAEJ,SAAS,CAAC,EAAE,GAAG,EAAE,CAAC,IAC5DP,IAAI,GAAG,SAAS,IAAI,CAACS,SAAS,IAAIT,IAAI,EAAE,GAAG,EAAE,CAAC,IAC9C4B,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzBC,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzB,CAACtB,SAAS,GAAG,IAAI,CAACI,UAAU,CAAC,UAAU,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC;MAC/DJ,SAAS,EAAEA,SAAS,IAAI;IAC1B,CAAC;EACH;EACA;;EAEA;EACA;EACA6B,GAAGA,CAAA,EAAG;IACJ,IACE,IAAI,CAACnD,MAAM,CAACiB,OAAO,IACnB,IAAI,CAACjB,MAAM,CAACiB,OAAO,CAACC,2BAA2B,EAC/C;MACA,OAAO,IAAI,CAACkC,kBAAkB,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,OAAO,IAAI,CAACC,cAAc,CAAC,CAAC;IAC9B;EACF;EAEAD,kBAAkBA,CAAA,EAAG;IACnB;IACA,MAAMZ,OAAO,GAAG,IAAI,CAACrC,IAAI,CAAC,CAAC;IAC3B,MAAM;MAAEqB;IAAU,CAAC,GAAG,IAAI;IAC1B,MAAM8B,MAAM,GAAG,IAAI,CAACX,KAAK,CAAC,CAAC;IAC3B,MAAMY,KAAK,GAAG,IAAI,CAACxC,IAAI,CAAC,CAAC;IACzB,MAAM;MAAEO;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,MAAMwD,YAAY,GAAGlC,SAAS,GAC1B,IAAI,IAAI,CAACI,UAAU,CAAC,KAAK,EAAEJ,SAAS,EAAE,IAAI,CAAC,EAAE,GAC7C,EAAE;IACN,MAAMmC,cAAc,GAAGF,KAAK,GAAG,GAAG/B,SAAS,GAAGgC,YAAY,GAAG,GAAG,EAAE;IAClE,OAAO;MACL7C,GAAG,EACD6B,OAAO,GACP,GAAG,IAAI,CAACjB,eAAe,CACrBD,SACF,CAAC,UAAUmC,cAAc,QAAQjC,SAAS,EAAE,IAC3C,CAAC+B,KAAK,GAAGC,YAAY,GAAG,EAAE,CAAC,IAC3BD,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzBD,MAAM,GAAG,IAAIA,MAAM,EAAE,GAAG,EAAE,CAAC,IAC3B,CAAChC,SAAS,GACP,IAAI,CAACI,UAAU,CAAC,UAAU,EAAE,YAAY,CAAC,GACzC,IAAI,CAACI,qBAAqB,CAACR,SAAS,CAAC,CAAC;MAC5CA,SAAS,EAAEA,SAAS,IAAI;IAC1B,CAAC;EACH;EAEA+B,cAAcA,CAAA,EAAG;IACf;IACA,MAAMb,OAAO,GAAG,IAAI,CAACrC,IAAI,CAAC,CAAC;IAC3B,MAAM;MAAEqB;IAAU,CAAC,GAAG,IAAI;IAC1B,MAAM8B,MAAM,GAAG,IAAI,CAACX,KAAK,CAAC,CAAC;IAC3B,MAAMY,KAAK,GAAG,IAAI,CAACxC,IAAI,CAAC,CAAC;IACzB,MAAM;MAAEO;IAAU,CAAC,GAAG,IAAI,CAACtB,MAAM;IACjC,MAAMwD,YAAY,GAAGlC,SAAS,GAC1B,IAAI,IAAI,CAACI,UAAU,CAAC,KAAK,EAAEJ,SAAS,CAAC,EAAE,GACvC,EAAE;IACN;IACA,MAAMmC,cAAc,GAAGF,KAAK,GAAG,GAAG/B,SAAS,GAAGgC,YAAY,GAAG,GAAG,EAAE;IAClE,OAAO;MACL7C,GAAG,EACD6B,OAAO,GACP,UAAUiB,cAAc,QAAQjC,SAAS,EAAE,IAC1C,CAAC+B,KAAK,GAAGC,YAAY,GAAG,EAAE,CAAC,IAC3BD,KAAK,GAAG,IAAIA,KAAK,EAAE,GAAG,EAAE,CAAC,IACzBD,MAAM,GAAG,IAAIA,MAAM,EAAE,GAAG,EAAE,CAAC,IAC3B,CAAChC,SAAS,GAAG,IAAI,CAACI,UAAU,CAAC,UAAU,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC;MAC/DJ,SAAS,EAAEA,SAAS,IAAI;IAC1B,CAAC;EACH;EACA;;EAEA;EACAY,OAAOA,CAAA,EAAG;IACR,IAAIwB,cAAc,GAAG,EAAE;IACvB,IAAI,IAAI,CAACC,UAAU,CAAC,CAAC,EAAE,OAAO,EAAE;IAChC,MAAMpB,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC,CAAC;IACtB,MAAMqB,KAAK,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IAClC,MAAM3B,OAAO,GAAG,IAAI,CAAC7B,OAAO,CAAC6B,OAAO,IAAI,EAAE;IAC1C,IAAI4B,CAAC,GAAG,CAAC,CAAC;MACRnD,GAAG,GAAG,EAAE;IACV,IAAIuB,OAAO,EAAE;MACX,OAAO,EAAE4B,CAAC,GAAG5B,OAAO,CAACL,MAAM,EAAE;QAC3B,MAAMvB,IAAI,GAAG4B,OAAO,CAAC4B,CAAC,CAAC;QACvB,IAAIxD,IAAI,CAACyD,QAAQ,EAAEL,cAAc,GAAG,WAAW;QAC/C,IAAIpD,IAAI,CAAC0D,UAAU,EAAE;UACnBN,cAAc,GAAG,IAAI,CAACM,UAAU,CAAC1D,IAAI,CAACyC,KAAK,CAAC;UAC5C;QACF;QACA,IAAIzC,IAAI,CAAC2D,IAAI,KAAK,WAAW,EAAE;UAC7BtD,GAAG,CAACH,IAAI,CAAC,GAAG,IAAI,CAAC0D,SAAS,CAAC5D,IAAI,CAAC,CAAC;QACnC,CAAC,MAAM,IAAIA,IAAI,CAAC2D,IAAI,KAAK,cAAc,EAAE;UACvCtD,GAAG,CAACH,IAAI,CAAC,IAAI,CAAC2D,YAAY,CAAC7D,IAAI,CAAC,CAAC;QACnC,CAAC,MAAM,IAAIA,IAAI,CAAC2D,IAAI,KAAK,UAAU,EAAE;UACnCtD,GAAG,CAACH,IAAI,CAAC,IAAI,CAAC4D,QAAQ,CAAC9D,IAAI,CAAC,CAAC;QAC/B,CAAC,MAAM,IAAIA,IAAI,CAAC2D,IAAI,KAAK,MAAM,EAAE;UAC/BtD,GAAG,CAACH,IAAI,CAAC,IAAI,CAAC6D,IAAI,CAAC/D,IAAI,CAAC,CAAC;QAC3B,CAAC,MAAM,IAAIA,IAAI,CAACyC,KAAK,IAAIzC,IAAI,CAACyC,KAAK,CAAClB,MAAM,GAAG,CAAC,EAAE;UAC9ClB,GAAG,CAACH,IAAI,CAAC,IAAI,CAACV,SAAS,CAACP,SAAS,CAACe,IAAI,CAACyC,KAAK,CAAC,CAAC;QAChD;MACF;IACF;IACA,IAAIpC,GAAG,CAACkB,MAAM,KAAK,CAAC,EAAElB,GAAG,GAAG,CAAC,GAAG,CAAC;IACjC,MAAMD,MAAM,GAAG,IAAI,CAAC4D,QAAQ,CAAC,CAAC,GAAG,EAAE,GAAG,SAAS;IAC/C,OACE,GAAG5D,MAAM,GAAGkD,KAAK,GAAGF,cAAc,EAAE,IACnCnB,GAAG,GAAGA,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GACtB5B,GAAG,CAACI,IAAI,CAAC,IAAI,CAAC,IACb,IAAI,CAACS,SAAS,GAAG,SAAS,IAAI,CAACA,SAAS,EAAE,GAAG,EAAE,CAAC;EAErD;EAEAE,UAAUA,CAAC6C,MAAM,EAAExB,KAAK,EAAEyB,WAAW,EAAE;IACrC,QAAQD,MAAM;MACZ,KAAK,QAAQ;MACb,KAAK,QAAQ;QACX,OAAOxB,KAAK,GACR,UAAU,IAAI,CAACjD,SAAS,CAAC2E,mBAAmB,CAAC,WAAW,EAAE1B,KAAK,CAAC,GAC9DyB,WAAW,GAAG,YAAY,GAAG,EAAE,EAC/B,GACF,EAAE;MACR,KAAK,KAAK;QACR,OAAOzB,KAAK,GACR,UAAU,IAAI,CAACjD,SAAS,CAAC2E,mBAAmB,CAAC,UAAU,EAAE1B,KAAK,CAAC,GAC7DyB,WAAW,GAAG,YAAY,GAAG,EAAE,EAC/B,GACF,EAAE;MACR,KAAK,UAAU;QACb,OAAOzB,KAAK,GAAG,oBAAoB,GAAG,EAAE;IAC5C;EACF;EAEAxB,eAAeA,CAACmD,MAAM,EAAE;IACtB;IACA,IAAIA,MAAM,IAAIA,MAAM,CAAC7C,MAAM,GAAG,CAAC,EAAE;MAC/B,IAAI8C,UAAU,GAAG,EAAE;;MAEnB;MACA,IAAIhD,KAAK,CAACC,OAAO,CAAC8C,MAAM,CAAC,EAAE;QACzBC,UAAU,GAAGD,MAAM,CAChB7D,GAAG,CAAEkC,KAAK,IAAK,OAAO,IAAI,CAACjD,SAAS,CAACP,SAAS,CAACwD,KAAK,CAAC,EAAE,CAAC,CACxDhC,IAAI,CAAC,GAAG,CAAC;MACd,CAAC,MAAM;QACL4D,UAAU,GAAG,OAAO,IAAI,CAAC7E,SAAS,CAACP,SAAS,CAACmF,MAAM,CAAC,EAAE;MACxD;;MAEA;MACA,IAAI/D,GAAG,GAAG,iBAAiBgE,UAAU,aAAa;MAClDhE,GAAG,IAAI,QAAQ,IAAI,CAACa,SAAS,QAAQ;MACrCb,GAAG,IAAI,aAAa,IAAI,CAACa,SAAS,UAAU;MAE5C,OAAOb,GAAG;IACZ;IAEA,OAAO,EAAE;EACX;EAEAmB,qBAAqBA,CAAC4C,MAAM,EAAE;IAC5B;IACA,IAAIA,MAAM,IAAIA,MAAM,CAAC7C,MAAM,GAAG,CAAC,EAAE;MAC/B,IAAI8C,UAAU,GAAG,EAAE;;MAEnB;MACA,IAAIhD,KAAK,CAACC,OAAO,CAAC8C,MAAM,CAAC,EAAE;QACzBC,UAAU,GAAGD,MAAM,CAChB7D,GAAG,CAAEkC,KAAK,IAAK,GAAG,IAAI,CAACjD,SAAS,CAACP,SAAS,CAACwD,KAAK,CAAC,EAAE,CAAC,CACpDhC,IAAI,CAAC,GAAG,CAAC;MACd,CAAC,MAAM;QACL4D,UAAU,GAAG,IAAI,CAAC7E,SAAS,CAACP,SAAS,CAACmF,MAAM,CAAC;MAC/C;;MAEA;MACA,IAAI/D,GAAG,GAAG,YAAYgE,UAAU,cAAc;MAC9C;MACAhE,GAAG,IAAI,kBAAkB;MAEzB,OAAOA,GAAG;IACZ;IAEA,OAAO,EAAE;EACX;;EAEA;EACAiE,QAAQA,CAAA,EAAG;IACT,OAAO,kBAAkB,IAAI,CAACpD,SAAS,EAAE;EAC3C;EAEAqD,SAASA,CAAA,EAAG;IACV;IACA;IACA,OAAO,gBAAgB;EACzB;EAEAC,QAAQA,CAAA,EAAG;IACT;IACA,OAAO,iBAAiB;EAC1B;;EAEA;EACAC,UAAUA,CAAA,EAAG;IACX,MAAM9B,MAAM,GAAG,IAAI,CAACjD,MAAM,CAAC+E,UAAU;IACrC,IAAIC,MAAM,GAAG,IAAI,CAAChF,MAAM,CAACgF,MAAM;;IAE/B;IACA;IACA;IACA,MAAMC,KAAK,GAAG,IAAI,CAACrF,MAAM,CAACsF,oBAAoB,CAAC,IAAI,CAAClF,MAAM,CAACiF,KAAK,EAAE7F,QAAQ,CAAC;IAE3E,IAAI4F,MAAM,EAAE;MACVA,MAAM,GAAG,IAAI,CAACpF,MAAM,CAACsF,oBAAoB,CAACF,MAAM,EAAE5F,QAAQ,CAAC;IAC7D;;IAEA;IACA,IAAIuB,GAAG,GAAG,2KAA2K;IACrL,MAAMwE,QAAQ,GAAG,CAACF,KAAK,EAAE,IAAI,CAACrF,MAAM,CAACwF,QAAQ,CAAC,CAAC,CAAC;IAEhD,IAAIJ,MAAM,EAAE;MACVrE,GAAG,IAAI,uBAAuB;MAC9BwE,QAAQ,CAAC3E,IAAI,CAACwE,MAAM,CAAC;IACvB,CAAC,MAAM;MACLrE,GAAG,IAAI,2BAA2B;IACpC;IAEA,OAAO;MACLA,GAAG;MACHwE,QAAQ,EAAEA,QAAQ;MAClBE,MAAMA,CAACC,IAAI,EAAE;QACX,MAAMC,GAAG,GAAGD,IAAI,CAACE,MAAM,CAAC,CAACtD,OAAO,EAAEuD,GAAG,KAAK;UACxCvD,OAAO,CAACuD,GAAG,CAAC,CAAC,CAAC,CAAC1C,KAAK,CAAC,GAAG;YACtB2C,YAAY,EAAED,GAAG,CAAC,CAAC,CAAC,CAAC1C,KAAK;YAC1BkB,IAAI,EAAEwB,GAAG,CAAC,CAAC,CAAC,CAAC1C,KAAK;YAClB4C,SAAS,EAAEF,GAAG,CAAC,CAAC,CAAC,CAAC1C,KAAK;YACvB6C,QAAQ,EAAEH,GAAG,CAAC,CAAC,CAAC,CAAC1C,KAAK,KAAK;UAC7B,CAAC;UACD,OAAOb,OAAO;QAChB,CAAC,EAAE,CAAC,CAAC,CAAC;QACN,OAAQe,MAAM,IAAIsC,GAAG,CAACtC,MAAM,CAAC,IAAKsC,GAAG;MACvC;IACF,CAAC;EACH;EAEAhD,GAAGA,CAAA,EAAG;IACJ,MAAMsD,OAAO,GAAG,CAAC,IAAI,CAAC7F,MAAM,CAAC8F,KAAK,IAAI,IAAI,CAAC9F,MAAM,CAAC8F,KAAK,KAAK,CAAC;IAC7D,MAAMC,QAAQ,GAAG,CAAC,IAAI,CAAC/F,MAAM,CAACgG,MAAM;IACpC,IAAIH,OAAO,IAAI,CAACE,QAAQ,EAAE,OAAO,EAAE;IACnC,OAAO,QAAQ,IAAI,CAACE,iCAAiC,CAAC,OAAO,CAAC,GAAG;EACnE;EAEAH,KAAKA,CAAA,EAAG;IACN,OAAO,EAAE;EACX;EAEAE,MAAMA,CAAA,EAAG;IACP,MAAMH,OAAO,GAAG,CAAC,IAAI,CAAC7F,MAAM,CAAC8F,KAAK,IAAI,IAAI,CAAC9F,MAAM,CAAC8F,KAAK,KAAK,CAAC;IAC7D,MAAMC,QAAQ,GAAG,CAAC,IAAI,CAAC/F,MAAM,CAACgG,MAAM;IACpC,IAAID,QAAQ,EAAE,OAAO,EAAE;IACvB,IAAIC,MAAM,GAAG,UACXD,QAAQ,GAAG,GAAG,GAAG,IAAI,CAACE,iCAAiC,CAAC,QAAQ,CAAC,OAC5D;IACP,IAAI,CAACJ,OAAO,EAAE;MACZG,MAAM,IAAI,eAAe,IAAI,CAACC,iCAAiC,CAC7D,OACF,CAAC,YAAY;IACf;IACA,OAAOD,MAAM;EACf;EAEAE,SAASA,CAACC,SAAS,EAAE;IACnB,OAAO,GAAG,IAAI,CAACC,aAAa,CAC1BD,SACF,CAAC,yCAAyC,IAAI,CAACE,IAAI,CACjDF,SAAS,EACT,OACF,CAAC,GAAG,IAAI,CAACG,YAAY,CAACH,SAAS,CAAC,EAAE;EACpC;EAEAI,UAAUA,CAACJ,SAAS,EAAE;IACpB,OAAO,GAAG,IAAI,CAACC,aAAa,CAC1BD,SACF,CAAC,yCAAyC,IAAI,CAACE,IAAI,CACjDF,SAAS,EACT,OACF,CAAC,GAAG,IAAI,CAACG,YAAY,CAACH,SAAS,CAAC,EAAE;EACpC;EAEAK,WAAWA,CAACC,MAAM,EAAE;IAClB;IACA;IACA,OAAO,IAAI,CAACC,YAAY,CACtBD,MAAM,CAACE,WAAW,GAAG,YAAY,GAAG,YAAY,EAChDF,MACF,CAAC;EACH;EAEAG,OAAOA,CAACH,MAAM,EAAE;IACd,OAAO,IAAI,CAACI,QAAQ,CAAC,aAAa,EAAEJ,MAAM,CAAC;EAC7C;EAEAK,UAAUA,CAACL,MAAM,EAAE;IACjB,OAAO,IAAI,CAACI,QAAQ,CAAC,aAAa,EAAEJ,MAAM,CAAC;EAC7C;EAEAM,UAAUA,CAACN,MAAM,EAAE;IACjB,MAAMO,OAAO,GAAG,eAAexH,UAAU,CACvCiH,MAAM,CAACxD,MAAM,EACb,IAAI,CAACpD,OAAO,EACZ,IAAI,CAACD,MAAM,EACX,IAAI,CAACqH,cACP,CAAC,IAAI,IAAI,CAACrH,MAAM,CAACsH,SAAS,CACxBT,MAAM,CAACU,IAAI,EACX,IAAI,CAACtH,OAAO,EACZ,IAAI,CAACoH,cACP,CAAC,SAAS;IACV,OAAOR,MAAM,CAACW,KAAK,GACf,IAAI,CAACxH,MAAM,CAACwH,KAAK,CAACJ,OAAO,EAAE,IAAI,CAAClH,SAAS,CAACuH,IAAI,CAACZ,MAAM,CAACW,KAAK,CAAC,CAAC,GAC7DJ,OAAO;EACb;EAEAM,aAAaA,CAACnB,SAAS,EAAE;IACvB,OAAO,IAAI,CAACoB,cAAc,CAAC,YAAY,EAAEpB,SAAS,CAAC;EACrD;EAEAqB,mBAAmBA,CAACrB,SAAS,EAAE;IAC7B,MAAM,IAAIlG,KAAK,CACb,4DACF,CAAC;EACH;EAEAwH,iBAAiBA,CAACtB,SAAS,EAAE;IAC3B,MAAM,IAAIlG,KAAK,CAAC,0DAA0D,CAAC;EAC7E;EAEAyH,YAAYA,CAACvB,SAAS,EAAEwB,QAAQ,EAAE;IAChC,MAAM1E,MAAM,GAAGzD,UAAU,CACvB2G,SAAS,CAAClD,MAAM,EAChB,IAAI,CAACpD,OAAO,EACZ,IAAI,CAACD,MAAM,EACX,IAAI,CAACqH,cACP,CAAC;IACD,OAAO,CACLtF,KAAK,CAACC,OAAO,CAACuE,SAAS,CAACzB,MAAM,CAAC,GAAGyB,SAAS,CAACzB,MAAM,GAAG,CAACyB,SAAS,CAACzB,MAAM,CAAC,EAEtE7D,GAAG,CAAC,UAAUkC,KAAK,EAAE;MACpB,OACE,aAAa,GACbE,MAAM,GACN,GAAG,GACH,IAAI,CAACrD,MAAM,CAACsH,SAAS,CAACnE,KAAK,EAAE,IAAI,CAAClD,OAAO,EAAE,IAAI,CAACoH,cAAc,CAAC,GAC/D,GAAG;IAEP,CAAC,EAAE,IAAI,CAAC,CACPlG,IAAI,CAAC4G,QAAQ,CAAC;EACnB;EAEAC,gBAAgBA,CAACC,MAAM,EAAE;IACvB,OAAO,IAAI,CAACC,iBAAiB,CAAC,YAAY,EAAED,MAAM,CAAC;EACrD;AACF;;AAEA;AACA;AACAE,MAAM,CAACC,OAAO,GAAGtI,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}