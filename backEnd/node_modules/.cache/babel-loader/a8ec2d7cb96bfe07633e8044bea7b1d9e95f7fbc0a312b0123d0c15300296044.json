{"ast":null,"code":"// Query Compiler\n// -------\nconst helpers = require('../util/helpers');\nconst Raw = require('../raw');\nconst QueryBuilder = require('./querybuilder');\nconst JoinClause = require('./joinclause');\nconst debug = require('debug');\nconst assign = require('lodash/assign');\nconst compact = require('lodash/compact');\nconst groupBy = require('lodash/groupBy');\nconst has = require('lodash/has');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\nconst omitBy = require('lodash/omitBy');\nconst reduce = require('lodash/reduce');\nconst {\n  nanoid\n} = require('../util/nanoid');\nconst {\n  isString,\n  isUndefined\n} = require('../util/is');\nconst {\n  columnize: columnize_,\n  direction: direction_,\n  operator: operator_,\n  wrap: wrap_,\n  unwrapRaw: unwrapRaw_,\n  rawOrFn: rawOrFn_\n} = require('../formatter/wrappingFormatter');\nconst debugBindings = debug('knex:bindings');\nconst components = ['comments', 'columns', 'join', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset', 'lock', 'waitMode'];\n\n// The \"QueryCompiler\" takes all of the query statements which\n// have been gathered in the \"QueryBuilder\" and turns them into a\n// properly formatted / bound query string.\nclass QueryCompiler {\n  constructor(client, builder, bindings) {\n    this.client = client;\n    this.method = builder._method || 'select';\n    this.options = builder._options;\n    this.single = builder._single;\n    this.queryComments = builder._comments;\n    this.timeout = builder._timeout || false;\n    this.cancelOnTimeout = builder._cancelOnTimeout || false;\n    this.grouped = groupBy(builder._statements, 'grouping');\n    this.formatter = client.formatter(builder);\n    // Used when the insert call is empty.\n    this._emptyInsertValue = 'default values';\n    this.first = this.select;\n    this.bindings = bindings || [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n    this.builder = this.formatter.builder;\n  }\n\n  // Collapse the builder into a single object\n  toSQL(method, tz) {\n    this._undefinedInWhereClause = false;\n    this.undefinedBindingsInfo = [];\n    method = method || this.method;\n    const val = this[method]() || '';\n    const query = {\n      method,\n      options: reduce(this.options, assign, {}),\n      timeout: this.timeout,\n      cancelOnTimeout: this.cancelOnTimeout,\n      bindings: this.bindingsHolder.bindings || [],\n      __knexQueryUid: nanoid()\n    };\n    Object.defineProperties(query, {\n      toNative: {\n        value: () => {\n          return {\n            sql: this.client.positionBindings(query.sql),\n            bindings: this.client.prepBindings(query.bindings)\n          };\n        },\n        enumerable: false\n      }\n    });\n    if (isString(val)) {\n      query.sql = val;\n    } else {\n      assign(query, val);\n    }\n    if (method === 'select' || method === 'first') {\n      if (this.single.as) {\n        query.as = this.single.as;\n      }\n    }\n    if (this._undefinedInWhereClause) {\n      debugBindings(query.bindings);\n      throw new Error(`Undefined binding(s) detected when compiling ` + `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(', ')}] query: ${query.sql}`);\n    }\n    return query;\n  }\n\n  // Compiles the `select` statement, or nested sub-selects by calling each of\n  // the component compilers, trimming out the empties, and returning a\n  // generated query string.\n  select() {\n    let sql = this.with();\n    let unionStatement = '';\n    const firstStatements = [];\n    const endStatements = [];\n    components.forEach(component => {\n      const statement = this[component](this);\n      // We store the 'union' statement to append it at the end.\n      // We still need to call the component sequentially because of\n      // order of bindings.\n      switch (component) {\n        case 'union':\n          unionStatement = statement;\n          break;\n        case 'comments':\n        case 'columns':\n        case 'join':\n        case 'where':\n          firstStatements.push(statement);\n          break;\n        default:\n          endStatements.push(statement);\n          break;\n      }\n    });\n\n    // Check if we need to wrap the main query.\n    // We need to wrap main query if one of union have wrap options to true\n    // to avoid error syntax (in PostgreSQL for example).\n    const wrapMainQuery = this.grouped.union && this.grouped.union.map(u => u.wrap).some(u => u);\n    if (this.onlyUnions()) {\n      const statements = compact(firstStatements.concat(endStatements)).join(' ');\n      sql += unionStatement + (statements ? ' ' + statements : '');\n    } else {\n      const allStatements = (wrapMainQuery ? '(' : '') + compact(firstStatements).join(' ') + (wrapMainQuery ? ')' : '');\n      const endStat = compact(endStatements).join(' ');\n      sql += allStatements + (unionStatement ? ' ' + unionStatement : '') + (endStat ? ' ' + endStat : endStat);\n    }\n    return sql;\n  }\n  pluck() {\n    let toPluck = this.single.pluck;\n    if (toPluck.indexOf('.') !== -1) {\n      toPluck = toPluck.split('.').slice(-1)[0];\n    }\n    return {\n      sql: this.select(),\n      pluck: toPluck\n    };\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const insertValues = this.single.insert || [];\n    const sql = this.with() + `insert into ${this.tableName} `;\n    const body = this._insertBody(insertValues);\n    return body === '' ? '' : sql + body;\n  }\n  _onConflictClause(columns) {\n    return columns instanceof Raw ? this.formatter.wrap(columns) : `(${this.formatter.columnize(columns)})`;\n  }\n  _buildInsertValues(insertData) {\n    let sql = '';\n    let i = -1;\n    while (++i < insertData.values.length) {\n      if (i !== 0) sql += '), (';\n      sql += this.client.parameterize(insertData.values[i], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n    }\n    return sql;\n  }\n  _insertBody(insertValues) {\n    let sql = '';\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${columnize_(insertData.columns, this.builder, this.client, this.bindingsHolder)}`;\n        sql += ') values (' + this._buildInsertValues(insertData) + ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n    return sql;\n  }\n\n  // Compiles the \"update\" query.\n  update() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    return withSQL + `update ${this.single.only ? 'only ' : ''}${tableName}` + ' set ' + updateData.join(', ') + (wheres ? ` ${wheres}` : '');\n  }\n  _hintComments() {\n    let hints = this.grouped.hintComments || [];\n    hints = hints.map(hint => compact(hint.value).join(' '));\n    hints = compact(hints).join(' ');\n    return hints ? `/*+ ${hints} */ ` : '';\n  }\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.type === 'json') {\n          sql.push(this.json(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(columnize_(stmt.value, this.builder, this.client, this.bindingsHolder));\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n    const select = this.onlyJson() ? '' : 'select ';\n    return `${select}${hints}${distinctClause}` + sql.join(', ') + (this.tableName ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}` : '');\n  }\n\n  // Add comments to the query\n  comments() {\n    if (!this.queryComments.length) return '';\n    return this.queryComments.map(comment => `/* ${comment.comment} */`).join(' ');\n  }\n  _aggregate(stmt, {\n    aliasSeparator = ' as ',\n    distinctParentheses\n  } = {}) {\n    const value = stmt.value;\n    const method = stmt.method;\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    const wrap = identifier => wrap_(identifier, undefined, this.builder, this.client, this.bindingsHolder);\n    const addAlias = (value, alias) => {\n      if (alias) {\n        return value + aliasSeparator + wrap(alias);\n      }\n      return value;\n    };\n    const aggregateArray = (value, alias) => {\n      let columns = value.map(wrap).join(', ');\n      if (distinct) {\n        const openParen = distinctParentheses ? '(' : ' ';\n        const closeParen = distinctParentheses ? ')' : '';\n        columns = distinct.trim() + openParen + columns + closeParen;\n      }\n      const aggregated = `${method}(${columns})`;\n      return addAlias(aggregated, alias);\n    };\n    const aggregateString = (value, alias) => {\n      const aggregated = `${method}(${distinct + wrap(value)})`;\n      return addAlias(aggregated, alias);\n    };\n    if (Array.isArray(value)) {\n      return [aggregateArray(value)];\n    }\n    if (typeof value === 'object') {\n      if (stmt.alias) {\n        throw new Error('When using an object explicit alias can not be used');\n      }\n      return Object.entries(value).map(([alias, column]) => {\n        if (Array.isArray(column)) {\n          return aggregateArray(column, alias);\n        }\n        return aggregateString(column, alias);\n      });\n    }\n\n    // Allows us to speciy an alias for the aggregate types.\n    const splitOn = value.toLowerCase().indexOf(' as ');\n    let column = value;\n    let {\n      alias\n    } = stmt;\n    if (splitOn !== -1) {\n      column = value.slice(0, splitOn);\n      if (alias) {\n        throw new Error(`Found multiple aliases for same column: ${column}`);\n      }\n      alias = value.slice(splitOn + 4);\n    }\n    return [aggregateString(column, alias)];\n  }\n  aggregate(stmt) {\n    return this._aggregate(stmt);\n  }\n  aggregateRaw(stmt) {\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    return `${stmt.method}(${distinct + unwrapRaw_(stmt.value, undefined, this.builder, this.client, this.bindingsHolder)})`;\n  }\n  _joinTable(join) {\n    return join.schema && !(join.table instanceof Raw) ? `${join.schema}.${join.table}` : join.table;\n  }\n\n  // Compiles all each of the `join` clauses on the query,\n  // including any nested join queries.\n  join() {\n    let sql = '';\n    let i = -1;\n    const joins = this.grouped.join;\n    if (!joins) return '';\n    while (++i < joins.length) {\n      const join = joins[i];\n      const table = this._joinTable(join);\n      if (i > 0) sql += ' ';\n      if (join.joinType === 'raw') {\n        sql += unwrapRaw_(join.table, undefined, this.builder, this.client, this.bindingsHolder);\n      } else {\n        sql += join.joinType + ' join ' + wrap_(table, undefined, this.builder, this.client, this.bindingsHolder);\n        let ii = -1;\n        while (++ii < join.clauses.length) {\n          const clause = join.clauses[ii];\n          if (ii > 0) {\n            sql += ` ${clause.bool} `;\n          } else {\n            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;\n          }\n          const val = this[clause.type](clause);\n          if (val) {\n            sql += val;\n          }\n        }\n      }\n    }\n    return sql;\n  }\n  onBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  }\n  onNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  }\n  onExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n  onIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiOnIn(statement);\n    let values;\n    if (statement.value instanceof Raw) {\n      values = this.client.parameter(statement.value, this.builder, this.formatter);\n    } else {\n      values = this.client.parameterize(statement.value, undefined, this.builder, this.bindingsHolder);\n    }\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'in ') + this.wrap(values);\n  }\n  multiOnIn(statement) {\n    let i = -1,\n      sql = `(${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)}) `;\n    sql += this._not(statement, 'in ') + '((';\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(statement.value[i], undefined, this.builder, this.bindingsHolder);\n    }\n    return sql + '))';\n  }\n\n  // Compiles all `where` statements on the query.\n  where() {\n    const wheres = this.grouped.where;\n    if (!wheres) return;\n    const sql = [];\n    let i = -1;\n    while (++i < wheres.length) {\n      const stmt = wheres[i];\n      if (Object.prototype.hasOwnProperty.call(stmt, 'value') && helpers.containsUndefined(stmt.value)) {\n        this.undefinedBindingsInfo.push(stmt.column);\n        this._undefinedInWhereClause = true;\n      }\n      const val = this[stmt.type](stmt);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        } else {\n          sql.push(stmt.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n  group() {\n    return this._groupsOrders('group');\n  }\n  order() {\n    return this._groupsOrders('order');\n  }\n\n  // Compiles the `having` statements.\n  having() {\n    const havings = this.grouped.having;\n    if (!havings) return '';\n    const sql = ['having'];\n    for (let i = 0, l = havings.length; i < l; i++) {\n      const s = havings[i];\n      const val = this[s.type](s);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        }\n        if (sql.length > 1 || sql.length === 1 && sql[0] !== 'having') {\n          sql.push(s.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n  havingRaw(statement) {\n    return this._not(statement, '') + unwrapRaw_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n  havingWrapped(statement) {\n    const val = rawOrFn_(statement.value, 'where', this.builder, this.client, this.bindingsHolder);\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  }\n  havingBasic(statement) {\n    return this._not(statement, '') + wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(statement.operator, this.builder, this.client, this.bindingsHolder) + ' ' + this.client.parameter(statement.value, this.builder, this.bindingsHolder);\n  }\n  havingNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  }\n  havingExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n  havingBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  }\n  havingIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'in ') + this.wrap(this.client.parameterize(statement.value, undefined, this.builder, this.bindingsHolder));\n  }\n  multiHavingIn(statement) {\n    return this.multiOnIn(statement);\n  }\n\n  // Compile the \"union\" queries attached to the main query.\n  union() {\n    const onlyUnions = this.onlyUnions();\n    const unions = this.grouped.union;\n    if (!unions) return '';\n    let sql = '';\n    for (let i = 0, l = unions.length; i < l; i++) {\n      const union = unions[i];\n      if (i > 0) sql += ' ';\n      if (i > 0 || !onlyUnions) sql += union.clause + ' ';\n      const statement = rawOrFn_(union.value, undefined, this.builder, this.client, this.bindingsHolder);\n      if (statement) {\n        const wrap = union.wrap;\n        if (wrap) sql += '(';\n        sql += statement;\n        if (wrap) sql += ')';\n      }\n    }\n    return sql;\n  }\n\n  // If we haven't specified any columns or a `tableName`, we're assuming this\n  // is only being used for unions.\n  onlyUnions() {\n    return (!this.grouped.columns || !!this.grouped.columns[0].value) && this.grouped.union && !this.tableName;\n  }\n  _getValueOrParameterFromAttribute(attribute, rawValue) {\n    if (this.single.skipBinding[attribute] === true) {\n      return rawValue !== undefined && rawValue !== null ? rawValue : this.single[attribute];\n    }\n    return this.client.parameter(this.single[attribute], this.builder, this.bindingsHolder);\n  }\n  onlyJson() {\n    return !this.tableName && this.grouped.columns && this.grouped.columns.length === 1 && this.grouped.columns[0].type === 'json';\n  }\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit) return '';\n    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;\n  }\n  offset() {\n    if (!this.single.offset) return '';\n    return `offset ${this._getValueOrParameterFromAttribute('offset')}`;\n  }\n\n  // Compiles a `delete` query.\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const {\n      tableName\n    } = this;\n    const withSQL = this.with();\n    const wheres = this.where();\n    const joins = this.join();\n    // When using joins, delete the \"from\" table values as a default\n    const deleteSelector = joins ? tableName + ' ' : '';\n    return withSQL + `delete ${deleteSelector}from ${this.single.only ? 'only ' : ''}${tableName}` + (joins ? ` ${joins}` : '') + (wheres ? ` ${wheres}` : '');\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate ${this.tableName}`;\n  }\n\n  // Compiles the \"locks\".\n  lock() {\n    if (this.single.lock) {\n      return this[this.single.lock]();\n    }\n  }\n\n  // Compiles the wait mode on the locks.\n  waitMode() {\n    if (this.single.waitMode) {\n      return this[this.single.waitMode]();\n    }\n  }\n\n  // Fail on unsupported databases\n  skipLocked() {\n    throw new Error('.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+');\n  }\n\n  // Fail on unsupported databases\n  noWait() {\n    throw new Error('.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+');\n  }\n  distinctOn(value) {\n    throw new Error('.distinctOn() is currently only supported on PostgreSQL');\n  }\n\n  // On Clause\n  // ------\n\n  onWrapped(clause) {\n    const self = this;\n    const wrapJoin = new JoinClause();\n    clause.value.call(wrapJoin, wrapJoin);\n    let sql = '';\n    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {\n      const wrapClause = wrapJoin.clauses[ii];\n      if (ii > 0) {\n        sql += ` ${wrapClause.bool} `;\n      }\n      const val = self[wrapClause.type](wrapClause);\n      if (val) {\n        sql += val;\n      }\n    }\n    if (sql.length) {\n      return `(${sql})`;\n    }\n    return '';\n  }\n  onBasic(clause) {\n    const toWrap = clause.value instanceof QueryBuilder;\n    return wrap_(clause.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(clause.operator, this.builder, this.client, this.bindingsHolder) + ' ' + (toWrap ? '(' : '') + wrap_(clause.value, undefined, this.builder, this.client, this.bindingsHolder) + (toWrap ? ')' : '');\n  }\n  onVal(clause) {\n    return wrap_(clause.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(clause.operator, this.builder, this.client, this.bindingsHolder) + ' ' + this.client.parameter(clause.value, this.builder, this.bindingsHolder);\n  }\n  onRaw(clause) {\n    return unwrapRaw_(clause.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n  onUsing(clause) {\n    return '(' + columnize_(clause.column, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n\n  // Where Clause\n  // ------\n\n  _valueClause(statement) {\n    return statement.asColumn ? wrap_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) : this.client.parameter(statement.value, this.builder, this.bindingsHolder);\n  }\n  _columnClause(statement) {\n    let columns;\n    if (Array.isArray(statement.column)) {\n      columns = `(${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)})`;\n    } else {\n      columns = wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder);\n    }\n    return columns;\n  }\n  whereIn(statement) {\n    const values = this.client.values(statement.value, this.builder, this.bindingsHolder);\n    return `${this._columnClause(statement)} ${this._not(statement, 'in ')}${values}`;\n  }\n  whereLike(statement) {\n    return `${this._columnClause(statement)} ${this._not(statement, 'like ')}${this._valueClause(statement)}`;\n  }\n  whereILike(statement) {\n    return `${this._columnClause(statement)} ${this._not(statement, 'ilike ')}${this._valueClause(statement)}`;\n  }\n  whereNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  }\n\n  // Compiles a basic \"where\" clause.\n  whereBasic(statement) {\n    return this._not(statement, '') + wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(statement.operator, this.builder, this.client, this.bindingsHolder) + ' ' + this._valueClause(statement);\n  }\n  whereExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n  whereWrapped(statement) {\n    const val = rawOrFn_(statement.value, 'where', this.builder, this.client, this.bindingsHolder);\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  }\n  whereBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  }\n\n  // Compiles a \"whereRaw\" query.\n  whereRaw(statement) {\n    return this._not(statement, '') + unwrapRaw_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n  _jsonWrapValue(jsonValue) {\n    if (!this.builder._isJsonObject(jsonValue)) {\n      try {\n        return JSON.stringify(JSON.parse(jsonValue.replace(/\\n|\\t/g, '')));\n      } catch (e) {\n        return jsonValue;\n      }\n    }\n    return JSON.stringify(jsonValue);\n  }\n  _jsonValueClause(statement) {\n    statement.value = this._jsonWrapValue(statement.value);\n    return this._valueClause(statement);\n  }\n  whereJsonObject(statement) {\n    return `${this._columnClause(statement)} ${statement.not ? '!=' : '='} ${this._jsonValueClause(statement)}`;\n  }\n  wrap(str) {\n    if (str.charAt(0) !== '(') return `(${str})`;\n    return str;\n  }\n  json(stmt) {\n    return this[stmt.method](stmt.params);\n  }\n  analytic(stmt) {\n    let sql = '';\n    const self = this;\n    sql += stmt.method + '() over (';\n    if (stmt.raw) {\n      sql += stmt.raw;\n    } else {\n      if (stmt.partitions.length) {\n        sql += 'partition by ';\n        sql += map(stmt.partitions, function (partition) {\n          if (isString(partition)) {\n            return self.formatter.columnize(partition);\n          } else return self.formatter.columnize(partition.column) + (partition.order ? ' ' + partition.order : '');\n        }).join(', ') + ' ';\n      }\n      sql += 'order by ';\n      sql += map(stmt.order, function (order) {\n        if (isString(order)) {\n          return self.formatter.columnize(order);\n        } else return self.formatter.columnize(order.column) + (order.order ? ' ' + order.order : '');\n      }).join(', ');\n    }\n    sql += ')';\n    if (stmt.alias) {\n      sql += ' as ' + stmt.alias;\n    }\n    return sql;\n  }\n\n  // Compiles all `with` statements on the query.\n  with() {\n    if (!this.grouped.with || !this.grouped.with.length) {\n      return '';\n    }\n    const withs = this.grouped.with;\n    if (!withs) return;\n    const sql = [];\n    let i = -1;\n    let isRecursive = false;\n    while (++i < withs.length) {\n      const stmt = withs[i];\n      if (stmt.recursive) {\n        isRecursive = true;\n      }\n      const val = this[stmt.type](stmt);\n      sql.push(val);\n    }\n    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;\n  }\n  withWrapped(statement) {\n    const val = rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n    const columnList = statement.columnList ? '(' + columnize_(statement.columnList, this.builder, this.client, this.bindingsHolder) + ')' : '';\n    const materialized = statement.materialized === undefined ? '' : statement.materialized ? 'materialized ' : 'not materialized ';\n    return val && columnize_(statement.alias, this.builder, this.client, this.bindingsHolder) + columnList + ' as ' + materialized + '(' + val + ')' || '';\n  }\n\n  // Determines whether to add a \"not\" prefix to the where clause.\n  _not(statement, str) {\n    if (statement.not) return `not ${str}`;\n    return str;\n  }\n  _prepInsert(data) {\n    const isRaw = rawOrFn_(data, undefined, this.builder, this.client, this.bindingsHolder);\n    if (isRaw) return isRaw;\n    let columns = [];\n    const values = [];\n    if (!Array.isArray(data)) data = data ? [data] : [];\n    let i = -1;\n    while (++i < data.length) {\n      if (data[i] == null) break;\n      if (i === 0) columns = Object.keys(data[i]).sort();\n      const row = new Array(columns.length);\n      const keys = Object.keys(data[i]);\n      let j = -1;\n      while (++j < keys.length) {\n        const key = keys[j];\n        let idx = columns.indexOf(key);\n        if (idx === -1) {\n          columns = columns.concat(key).sort();\n          idx = columns.indexOf(key);\n          let k = -1;\n          while (++k < values.length) {\n            values[k].splice(idx, 0, undefined);\n          }\n          row.splice(idx, 0, undefined);\n        }\n        row[idx] = data[i][key];\n      }\n      values.push(row);\n    }\n    return {\n      columns,\n      values\n    };\n  }\n\n  // \"Preps\" the update.\n  _prepUpdate(data = {}) {\n    const {\n      counter = {}\n    } = this.single;\n    for (const column of Object.keys(counter)) {\n      //Skip?\n      if (has(data, column)) {\n        //Needed?\n        this.client.logger.warn(`increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`);\n        continue;\n      }\n      let value = counter[column];\n      const symbol = value < 0 ? '-' : '+';\n      if (symbol === '-') {\n        value = -value;\n      }\n      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);\n    }\n    data = omitBy(data, isUndefined);\n    const vals = [];\n    const columns = Object.keys(data);\n    let i = -1;\n    while (++i < columns.length) {\n      vals.push(wrap_(columns[i], undefined, this.builder, this.client, this.bindingsHolder) + ' = ' + this.client.parameter(data[columns[i]], this.builder, this.bindingsHolder));\n    }\n    if (isEmpty(vals)) {\n      throw new Error(['Empty .update() call detected!', 'Update data does not contain any values to update.', 'This will result in a faulty query.', this.single.table ? `Table: ${this.single.table}.` : '', this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ''].join(' '));\n    }\n    return vals;\n  }\n  _formatGroupsItemValue(value, nulls) {\n    const {\n      formatter\n    } = this;\n    let nullOrder = '';\n    if (nulls === 'last') {\n      nullOrder = ' is null';\n    } else if (nulls === 'first') {\n      nullOrder = ' is not null';\n    }\n    let groupOrder;\n    if (value instanceof Raw) {\n      groupOrder = unwrapRaw_(value, undefined, this.builder, this.client, this.bindingsHolder);\n    } else if (value instanceof QueryBuilder || nulls) {\n      groupOrder = '(' + formatter.columnize(value) + nullOrder + ')';\n    } else {\n      groupOrder = formatter.columnize(value);\n    }\n    return groupOrder;\n  }\n  _basicGroupOrder(item, type) {\n    const column = this._formatGroupsItemValue(item.value, item.nulls);\n    const direction = type === 'order' && item.type !== 'orderByRaw' ? ` ${direction_(item.direction, this.builder, this.client, this.bindingsHolder)}` : '';\n    return column + direction;\n  }\n  _groupOrder(item, type) {\n    return this._basicGroupOrder(item, type);\n  }\n  _groupOrderNulls(item, type) {\n    const column = this._formatGroupsItemValue(item.value);\n    const direction = type === 'order' && item.type !== 'orderByRaw' ? ` ${direction_(item.direction, this.builder, this.client, this.bindingsHolder)}` : '';\n    if (item.nulls && !(item.value instanceof Raw)) {\n      return `${column}${direction ? direction : ''} nulls ${item.nulls}`;\n    }\n    return column + direction;\n  }\n\n  // Compiles the `order by` statements.\n  _groupsOrders(type) {\n    const items = this.grouped[type];\n    if (!items) return '';\n    const sql = items.map(item => {\n      return this._groupOrder(item, type);\n    });\n    return sql.length ? type + ' by ' + sql.join(', ') : '';\n  }\n\n  // Get the table name, wrapping it if necessary.\n  // Implemented as a property to prevent ordering issues as described in #704.\n  get tableName() {\n    if (!this._tableName) {\n      // Only call this.formatter.wrap() the first time this property is accessed.\n      let tableName = this.single.table;\n      const schemaName = this.single.schema;\n      if (tableName && schemaName) {\n        const isQueryBuilder = tableName instanceof QueryBuilder;\n        const isRawQuery = tableName instanceof Raw;\n        const isFunction = typeof tableName === 'function';\n        if (!isQueryBuilder && !isRawQuery && !isFunction) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n      }\n      this._tableName = tableName ?\n      // Wrap subQuery with parenthesis, #3485\n      wrap_(tableName, tableName instanceof QueryBuilder, this.builder, this.client, this.bindingsHolder) : '';\n    }\n    return this._tableName;\n  }\n  _jsonPathWrap(extraction) {\n    return this.client.parameter(extraction.path || extraction[1], this.builder, this.bindingsHolder);\n  }\n\n  // Json common functions\n  _jsonExtract(nameFunction, params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    if (!Array.isArray(nameFunction)) {\n      nameFunction = [nameFunction];\n    }\n    return extractions.map(extraction => {\n      let jsonCol = `${columnize_(extraction.column || extraction[0], this.builder, this.client, this.bindingsHolder)}, ${this._jsonPathWrap(extraction)}`;\n      nameFunction.forEach(f => {\n        jsonCol = f + '(' + jsonCol + ')';\n      });\n      const alias = extraction.alias || extraction[2];\n      return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;\n    }).join(', ');\n  }\n  _jsonSet(nameFunction, params) {\n    const jsonSet = `${nameFunction}(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)}, ${this.client.parameter(params.path, this.builder, this.bindingsHolder)}, ${this.client.parameter(params.value, this.builder, this.bindingsHolder)})`;\n    return params.alias ? this.client.alias(jsonSet, this.formatter.wrap(params.alias)) : jsonSet;\n  }\n  _whereJsonPath(nameFunction, statement) {\n    return `${nameFunction}(${this._columnClause(statement)}, ${this._jsonPathWrap({\n      path: statement.jsonPath\n    })}) ${operator_(statement.operator, this.builder, this.client, this.bindingsHolder)} ${this._jsonValueClause(statement)}`;\n  }\n  _onJsonPathEquals(nameJoinFunction, clause) {\n    return nameJoinFunction + '(' + wrap_(clause.columnFirst, undefined, this.builder, this.client, this.bindingsHolder) + ', ' + this.client.parameter(clause.jsonPathFirst, this.builder, this.bindingsHolder) + ') = ' + nameJoinFunction + '(' + wrap_(clause.columnSecond, undefined, this.builder, this.client, this.bindingsHolder) + ', ' + this.client.parameter(clause.jsonPathSecond, this.builder, this.bindingsHolder) + ')';\n  }\n}\nmodule.exports = QueryCompiler;","map":{"version":3,"names":["helpers","require","Raw","QueryBuilder","JoinClause","debug","assign","compact","groupBy","has","isEmpty","map","omitBy","reduce","nanoid","isString","isUndefined","columnize","columnize_","direction","direction_","operator","operator_","wrap","wrap_","unwrapRaw","unwrapRaw_","rawOrFn","rawOrFn_","debugBindings","components","QueryCompiler","constructor","client","builder","bindings","method","_method","options","_options","single","_single","queryComments","_comments","timeout","_timeout","cancelOnTimeout","_cancelOnTimeout","grouped","_statements","formatter","_emptyInsertValue","first","select","bindingsHolder","toSQL","tz","_undefinedInWhereClause","undefinedBindingsInfo","val","query","__knexQueryUid","Object","defineProperties","toNative","value","sql","positionBindings","prepBindings","enumerable","as","Error","toUpperCase","join","with","unionStatement","firstStatements","endStatements","forEach","component","statement","push","wrapMainQuery","union","u","some","onlyUnions","statements","concat","allStatements","endStat","pluck","toPluck","indexOf","split","slice","insert","insertValues","tableName","body","_insertBody","_onConflictClause","columns","_buildInsertValues","insertData","i","values","length","parameterize","valueForUndefined","Array","isArray","_prepInsert","update","withSQL","updateData","_prepUpdate","wheres","where","only","_hintComments","hints","hintComments","hint","distinctClause","stmt","distinct","distinctOn","type","aggregate","aggregateRaw","analytic","json","onlyJson","comments","comment","_aggregate","aliasSeparator","distinctParentheses","aggregateDistinct","identifier","undefined","addAlias","alias","aggregateArray","openParen","closeParen","trim","aggregated","aggregateString","entries","column","splitOn","toLowerCase","_joinTable","schema","table","joins","joinType","ii","clauses","clause","bool","onBetween","_not","parameter","onNull","onExists","onIn","multiOnIn","prototype","hasOwnProperty","call","containsUndefined","group","_groupsOrders","order","having","havings","l","s","havingRaw","havingWrapped","havingBasic","havingNull","havingExists","havingBetween","havingIn","multiHavingIn","unions","_getValueOrParameterFromAttribute","attribute","rawValue","skipBinding","limit","noLimit","offset","del","deleteSelector","truncate","lock","waitMode","skipLocked","noWait","onWrapped","self","wrapJoin","wrapClause","onBasic","toWrap","onVal","onRaw","onUsing","_valueClause","asColumn","_columnClause","whereIn","whereLike","whereILike","whereNull","whereBasic","whereExists","whereWrapped","whereBetween","whereRaw","_jsonWrapValue","jsonValue","_isJsonObject","JSON","stringify","parse","replace","e","_jsonValueClause","whereJsonObject","not","str","charAt","params","raw","partitions","partition","withs","isRecursive","recursive","withWrapped","columnList","materialized","data","isRaw","keys","sort","row","j","key","idx","k","splice","counter","logger","warn","symbol","vals","_formatGroupsItemValue","nulls","nullOrder","groupOrder","_basicGroupOrder","item","_groupOrder","_groupOrderNulls","items","_tableName","schemaName","isQueryBuilder","isRawQuery","isFunction","_jsonPathWrap","extraction","path","_jsonExtract","nameFunction","extractions","jsonCol","f","_jsonSet","jsonSet","_whereJsonPath","jsonPath","_onJsonPathEquals","nameJoinFunction","columnFirst","jsonPathFirst","columnSecond","jsonPathSecond","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/query/querycompiler.js"],"sourcesContent":["// Query Compiler\n// -------\nconst helpers = require('../util/helpers');\nconst Raw = require('../raw');\nconst QueryBuilder = require('./querybuilder');\nconst JoinClause = require('./joinclause');\nconst debug = require('debug');\n\nconst assign = require('lodash/assign');\nconst compact = require('lodash/compact');\nconst groupBy = require('lodash/groupBy');\nconst has = require('lodash/has');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\nconst omitBy = require('lodash/omitBy');\nconst reduce = require('lodash/reduce');\nconst { nanoid } = require('../util/nanoid');\nconst { isString, isUndefined } = require('../util/is');\nconst {\n  columnize: columnize_,\n  direction: direction_,\n  operator: operator_,\n  wrap: wrap_,\n  unwrapRaw: unwrapRaw_,\n  rawOrFn: rawOrFn_,\n} = require('../formatter/wrappingFormatter');\n\nconst debugBindings = debug('knex:bindings');\n\nconst components = [\n  'comments',\n  'columns',\n  'join',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'limit',\n  'offset',\n  'lock',\n  'waitMode',\n];\n\n// The \"QueryCompiler\" takes all of the query statements which\n// have been gathered in the \"QueryBuilder\" and turns them into a\n// properly formatted / bound query string.\nclass QueryCompiler {\n  constructor(client, builder, bindings) {\n    this.client = client;\n    this.method = builder._method || 'select';\n    this.options = builder._options;\n    this.single = builder._single;\n    this.queryComments = builder._comments;\n    this.timeout = builder._timeout || false;\n    this.cancelOnTimeout = builder._cancelOnTimeout || false;\n    this.grouped = groupBy(builder._statements, 'grouping');\n    this.formatter = client.formatter(builder);\n    // Used when the insert call is empty.\n    this._emptyInsertValue = 'default values';\n    this.first = this.select;\n\n    this.bindings = bindings || [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n    this.builder = this.formatter.builder;\n  }\n\n  // Collapse the builder into a single object\n  toSQL(method, tz) {\n    this._undefinedInWhereClause = false;\n    this.undefinedBindingsInfo = [];\n\n    method = method || this.method;\n    const val = this[method]() || '';\n\n    const query = {\n      method,\n      options: reduce(this.options, assign, {}),\n      timeout: this.timeout,\n      cancelOnTimeout: this.cancelOnTimeout,\n      bindings: this.bindingsHolder.bindings || [],\n      __knexQueryUid: nanoid(),\n    };\n\n    Object.defineProperties(query, {\n      toNative: {\n        value: () => {\n          return {\n            sql: this.client.positionBindings(query.sql),\n            bindings: this.client.prepBindings(query.bindings),\n          };\n        },\n        enumerable: false,\n      },\n    });\n\n    if (isString(val)) {\n      query.sql = val;\n    } else {\n      assign(query, val);\n    }\n\n    if (method === 'select' || method === 'first') {\n      if (this.single.as) {\n        query.as = this.single.as;\n      }\n    }\n\n    if (this._undefinedInWhereClause) {\n      debugBindings(query.bindings);\n      throw new Error(\n        `Undefined binding(s) detected when compiling ` +\n          `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(\n            ', '\n          )}] query: ${query.sql}`\n      );\n    }\n\n    return query;\n  }\n\n  // Compiles the `select` statement, or nested sub-selects by calling each of\n  // the component compilers, trimming out the empties, and returning a\n  // generated query string.\n  select() {\n    let sql = this.with();\n\n    let unionStatement = '';\n\n    const firstStatements = [];\n    const endStatements = [];\n\n    components.forEach((component) => {\n      const statement = this[component](this);\n      // We store the 'union' statement to append it at the end.\n      // We still need to call the component sequentially because of\n      // order of bindings.\n      switch (component) {\n        case 'union':\n          unionStatement = statement;\n          break;\n        case 'comments':\n        case 'columns':\n        case 'join':\n        case 'where':\n          firstStatements.push(statement);\n          break;\n        default:\n          endStatements.push(statement);\n          break;\n      }\n    });\n\n    // Check if we need to wrap the main query.\n    // We need to wrap main query if one of union have wrap options to true\n    // to avoid error syntax (in PostgreSQL for example).\n    const wrapMainQuery =\n      this.grouped.union &&\n      this.grouped.union.map((u) => u.wrap).some((u) => u);\n\n    if (this.onlyUnions()) {\n      const statements = compact(firstStatements.concat(endStatements)).join(\n        ' '\n      );\n      sql += unionStatement + (statements ? ' ' + statements : '');\n    } else {\n      const allStatements =\n        (wrapMainQuery ? '(' : '') +\n        compact(firstStatements).join(' ') +\n        (wrapMainQuery ? ')' : '');\n      const endStat = compact(endStatements).join(' ');\n      sql +=\n        allStatements +\n        (unionStatement ? ' ' + unionStatement : '') +\n        (endStat ? ' ' + endStat : endStat);\n    }\n    return sql;\n  }\n\n  pluck() {\n    let toPluck = this.single.pluck;\n    if (toPluck.indexOf('.') !== -1) {\n      toPluck = toPluck.split('.').slice(-1)[0];\n    }\n    return {\n      sql: this.select(),\n      pluck: toPluck,\n    };\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const insertValues = this.single.insert || [];\n    const sql = this.with() + `insert into ${this.tableName} `;\n    const body = this._insertBody(insertValues);\n    return body === '' ? '' : sql + body;\n  }\n\n  _onConflictClause(columns) {\n    return columns instanceof Raw\n      ? this.formatter.wrap(columns)\n      : `(${this.formatter.columnize(columns)})`;\n  }\n\n  _buildInsertValues(insertData) {\n    let sql = '';\n    let i = -1;\n    while (++i < insertData.values.length) {\n      if (i !== 0) sql += '), (';\n      sql += this.client.parameterize(\n        insertData.values[i],\n        this.client.valueForUndefined,\n        this.builder,\n        this.bindingsHolder\n      );\n    }\n    return sql;\n  }\n\n  _insertBody(insertValues) {\n    let sql = '';\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${columnize_(\n          insertData.columns,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )}`;\n        sql += ') values (' + this._buildInsertValues(insertData) + ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n    return sql;\n  }\n\n  // Compiles the \"update\" query.\n  update() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    return (\n      withSQL +\n      `update ${this.single.only ? 'only ' : ''}${tableName}` +\n      ' set ' +\n      updateData.join(', ') +\n      (wheres ? ` ${wheres}` : '')\n    );\n  }\n\n  _hintComments() {\n    let hints = this.grouped.hintComments || [];\n    hints = hints.map((hint) => compact(hint.value).join(' '));\n    hints = compact(hints).join(' ');\n    return hints ? `/*+ ${hints} */ ` : '';\n  }\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.type === 'json') {\n          sql.push(this.json(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(\n            columnize_(\n              stmt.value,\n              this.builder,\n              this.client,\n              this.bindingsHolder\n            )\n          );\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n    const select = this.onlyJson() ? '' : 'select ';\n    return (\n      `${select}${hints}${distinctClause}` +\n      sql.join(', ') +\n      (this.tableName\n        ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}`\n        : '')\n    );\n  }\n\n  // Add comments to the query\n  comments() {\n    if (!this.queryComments.length) return '';\n    return this.queryComments\n      .map((comment) => `/* ${comment.comment} */`)\n      .join(' ');\n  }\n\n  _aggregate(stmt, { aliasSeparator = ' as ', distinctParentheses } = {}) {\n    const value = stmt.value;\n    const method = stmt.method;\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    const wrap = (identifier) =>\n      wrap_(\n        identifier,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    const addAlias = (value, alias) => {\n      if (alias) {\n        return value + aliasSeparator + wrap(alias);\n      }\n      return value;\n    };\n    const aggregateArray = (value, alias) => {\n      let columns = value.map(wrap).join(', ');\n      if (distinct) {\n        const openParen = distinctParentheses ? '(' : ' ';\n        const closeParen = distinctParentheses ? ')' : '';\n        columns = distinct.trim() + openParen + columns + closeParen;\n      }\n      const aggregated = `${method}(${columns})`;\n      return addAlias(aggregated, alias);\n    };\n    const aggregateString = (value, alias) => {\n      const aggregated = `${method}(${distinct + wrap(value)})`;\n      return addAlias(aggregated, alias);\n    };\n\n    if (Array.isArray(value)) {\n      return [aggregateArray(value)];\n    }\n\n    if (typeof value === 'object') {\n      if (stmt.alias) {\n        throw new Error('When using an object explicit alias can not be used');\n      }\n      return Object.entries(value).map(([alias, column]) => {\n        if (Array.isArray(column)) {\n          return aggregateArray(column, alias);\n        }\n        return aggregateString(column, alias);\n      });\n    }\n\n    // Allows us to speciy an alias for the aggregate types.\n    const splitOn = value.toLowerCase().indexOf(' as ');\n    let column = value;\n    let { alias } = stmt;\n    if (splitOn !== -1) {\n      column = value.slice(0, splitOn);\n      if (alias) {\n        throw new Error(`Found multiple aliases for same column: ${column}`);\n      }\n      alias = value.slice(splitOn + 4);\n    }\n    return [aggregateString(column, alias)];\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt);\n  }\n\n  aggregateRaw(stmt) {\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    return `${stmt.method}(${\n      distinct +\n      unwrapRaw_(\n        stmt.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    })`;\n  }\n\n  _joinTable(join) {\n    return join.schema && !(join.table instanceof Raw)\n      ? `${join.schema}.${join.table}`\n      : join.table;\n  }\n\n  // Compiles all each of the `join` clauses on the query,\n  // including any nested join queries.\n  join() {\n    let sql = '';\n    let i = -1;\n    const joins = this.grouped.join;\n    if (!joins) return '';\n    while (++i < joins.length) {\n      const join = joins[i];\n      const table = this._joinTable(join);\n      if (i > 0) sql += ' ';\n      if (join.joinType === 'raw') {\n        sql += unwrapRaw_(\n          join.table,\n          undefined,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        );\n      } else {\n        sql +=\n          join.joinType +\n          ' join ' +\n          wrap_(\n            table,\n            undefined,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          );\n        let ii = -1;\n        while (++ii < join.clauses.length) {\n          const clause = join.clauses[ii];\n          if (ii > 0) {\n            sql += ` ${clause.bool} `;\n          } else {\n            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;\n          }\n          const val = this[clause.type](clause);\n          if (val) {\n            sql += val;\n          }\n        }\n      }\n    }\n    return sql;\n  }\n\n  onBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  onNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  onExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  onIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiOnIn(statement);\n\n    let values;\n    if (statement.value instanceof Raw) {\n      values = this.client.parameter(\n        statement.value,\n        this.builder,\n        this.formatter\n      );\n    } else {\n      values = this.client.parameterize(\n        statement.value,\n        undefined,\n        this.builder,\n        this.bindingsHolder\n      );\n    }\n\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'in ') +\n      this.wrap(values)\n    );\n  }\n\n  multiOnIn(statement) {\n    let i = -1,\n      sql = `(${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )}) `;\n    sql += this._not(statement, 'in ') + '((';\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(\n        statement.value[i],\n        undefined,\n        this.builder,\n        this.bindingsHolder\n      );\n    }\n    return sql + '))';\n  }\n\n  // Compiles all `where` statements on the query.\n  where() {\n    const wheres = this.grouped.where;\n    if (!wheres) return;\n    const sql = [];\n    let i = -1;\n    while (++i < wheres.length) {\n      const stmt = wheres[i];\n      if (\n        Object.prototype.hasOwnProperty.call(stmt, 'value') &&\n        helpers.containsUndefined(stmt.value)\n      ) {\n        this.undefinedBindingsInfo.push(stmt.column);\n        this._undefinedInWhereClause = true;\n      }\n      const val = this[stmt.type](stmt);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        } else {\n          sql.push(stmt.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  group() {\n    return this._groupsOrders('group');\n  }\n\n  order() {\n    return this._groupsOrders('order');\n  }\n\n  // Compiles the `having` statements.\n  having() {\n    const havings = this.grouped.having;\n    if (!havings) return '';\n    const sql = ['having'];\n    for (let i = 0, l = havings.length; i < l; i++) {\n      const s = havings[i];\n      const val = this[s.type](s);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        }\n        if (sql.length > 1 || (sql.length === 1 && sql[0] !== 'having')) {\n          sql.push(s.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  havingRaw(statement) {\n    return (\n      this._not(statement, '') +\n      unwrapRaw_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    );\n  }\n\n  havingWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      'where',\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';\n  }\n\n  havingBasic(statement) {\n    return (\n      this._not(statement, '') +\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        statement.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this.client.parameter(statement.value, this.builder, this.bindingsHolder)\n    );\n  }\n\n  havingNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  havingExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  havingBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  havingIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'in ') +\n      this.wrap(\n        this.client.parameterize(\n          statement.value,\n          undefined,\n          this.builder,\n          this.bindingsHolder\n        )\n      )\n    );\n  }\n\n  multiHavingIn(statement) {\n    return this.multiOnIn(statement);\n  }\n\n  // Compile the \"union\" queries attached to the main query.\n  union() {\n    const onlyUnions = this.onlyUnions();\n    const unions = this.grouped.union;\n    if (!unions) return '';\n    let sql = '';\n    for (let i = 0, l = unions.length; i < l; i++) {\n      const union = unions[i];\n      if (i > 0) sql += ' ';\n      if (i > 0 || !onlyUnions) sql += union.clause + ' ';\n      const statement = rawOrFn_(\n        union.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n      if (statement) {\n        const wrap = union.wrap;\n        if (wrap) sql += '(';\n        sql += statement;\n        if (wrap) sql += ')';\n      }\n    }\n    return sql;\n  }\n\n  // If we haven't specified any columns or a `tableName`, we're assuming this\n  // is only being used for unions.\n  onlyUnions() {\n    return (\n      (!this.grouped.columns || !!this.grouped.columns[0].value) &&\n      this.grouped.union &&\n      !this.tableName\n    );\n  }\n\n  _getValueOrParameterFromAttribute(attribute, rawValue) {\n    if (this.single.skipBinding[attribute] === true) {\n      return rawValue !== undefined && rawValue !== null\n        ? rawValue\n        : this.single[attribute];\n    }\n    return this.client.parameter(\n      this.single[attribute],\n      this.builder,\n      this.bindingsHolder\n    );\n  }\n\n  onlyJson() {\n    return (\n      !this.tableName &&\n      this.grouped.columns &&\n      this.grouped.columns.length === 1 &&\n      this.grouped.columns[0].type === 'json'\n    );\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit) return '';\n    return `limit ${this._getValueOrParameterFromAttribute('limit')}`;\n  }\n\n  offset() {\n    if (!this.single.offset) return '';\n    return `offset ${this._getValueOrParameterFromAttribute('offset')}`;\n  }\n\n  // Compiles a `delete` query.\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const { tableName } = this;\n    const withSQL = this.with();\n    const wheres = this.where();\n    const joins = this.join();\n    // When using joins, delete the \"from\" table values as a default\n    const deleteSelector = joins ? tableName + ' ' : '';\n    return (\n      withSQL +\n      `delete ${deleteSelector}from ${\n        this.single.only ? 'only ' : ''\n      }${tableName}` +\n      (joins ? ` ${joins}` : '') +\n      (wheres ? ` ${wheres}` : '')\n    );\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate ${this.tableName}`;\n  }\n\n  // Compiles the \"locks\".\n  lock() {\n    if (this.single.lock) {\n      return this[this.single.lock]();\n    }\n  }\n\n  // Compiles the wait mode on the locks.\n  waitMode() {\n    if (this.single.waitMode) {\n      return this[this.single.waitMode]();\n    }\n  }\n\n  // Fail on unsupported databases\n  skipLocked() {\n    throw new Error(\n      '.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+'\n    );\n  }\n\n  // Fail on unsupported databases\n  noWait() {\n    throw new Error(\n      '.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+'\n    );\n  }\n\n  distinctOn(value) {\n    throw new Error('.distinctOn() is currently only supported on PostgreSQL');\n  }\n\n  // On Clause\n  // ------\n\n  onWrapped(clause) {\n    const self = this;\n\n    const wrapJoin = new JoinClause();\n    clause.value.call(wrapJoin, wrapJoin);\n\n    let sql = '';\n\n    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {\n      const wrapClause = wrapJoin.clauses[ii];\n      if (ii > 0) {\n        sql += ` ${wrapClause.bool} `;\n      }\n      const val = self[wrapClause.type](wrapClause);\n      if (val) {\n        sql += val;\n      }\n    }\n\n    if (sql.length) {\n      return `(${sql})`;\n    }\n    return '';\n  }\n\n  onBasic(clause) {\n    const toWrap = clause.value instanceof QueryBuilder;\n    return (\n      wrap_(\n        clause.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        clause.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      (toWrap ? '(' : '') +\n      wrap_(\n        clause.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      (toWrap ? ')' : '')\n    );\n  }\n\n  onVal(clause) {\n    return (\n      wrap_(\n        clause.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        clause.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this.client.parameter(clause.value, this.builder, this.bindingsHolder)\n    );\n  }\n\n  onRaw(clause) {\n    return unwrapRaw_(\n      clause.value,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n  }\n\n  onUsing(clause) {\n    return (\n      '(' +\n      columnize_(\n        clause.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  // Where Clause\n  // ------\n\n  _valueClause(statement) {\n    return statement.asColumn\n      ? wrap_(\n          statement.value,\n          undefined,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )\n      : this.client.parameter(\n          statement.value,\n          this.builder,\n          this.bindingsHolder\n        );\n  }\n\n  _columnClause(statement) {\n    let columns;\n    if (Array.isArray(statement.column)) {\n      columns = `(${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )})`;\n    } else {\n      columns = wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    }\n    return columns;\n  }\n\n  whereIn(statement) {\n    const values = this.client.values(\n      statement.value,\n      this.builder,\n      this.bindingsHolder\n    );\n    return `${this._columnClause(statement)} ${this._not(\n      statement,\n      'in '\n    )}${values}`;\n  }\n\n  whereLike(statement) {\n    return `${this._columnClause(statement)} ${this._not(\n      statement,\n      'like '\n    )}${this._valueClause(statement)}`;\n  }\n\n  whereILike(statement) {\n    return `${this._columnClause(statement)} ${this._not(\n      statement,\n      'ilike '\n    )}${this._valueClause(statement)}`;\n  }\n\n  whereNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  // Compiles a basic \"where\" clause.\n  whereBasic(statement) {\n    return (\n      this._not(statement, '') +\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        statement.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._valueClause(statement)\n    );\n  }\n\n  whereExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  whereWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      'where',\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';\n  }\n\n  whereBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  // Compiles a \"whereRaw\" query.\n  whereRaw(statement) {\n    return (\n      this._not(statement, '') +\n      unwrapRaw_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    );\n  }\n\n  _jsonWrapValue(jsonValue) {\n    if (!this.builder._isJsonObject(jsonValue)) {\n      try {\n        return JSON.stringify(JSON.parse(jsonValue.replace(/\\n|\\t/g, '')));\n      } catch (e) {\n        return jsonValue;\n      }\n    }\n    return JSON.stringify(jsonValue);\n  }\n\n  _jsonValueClause(statement) {\n    statement.value = this._jsonWrapValue(statement.value);\n    return this._valueClause(statement);\n  }\n\n  whereJsonObject(statement) {\n    return `${this._columnClause(statement)} ${\n      statement.not ? '!=' : '='\n    } ${this._jsonValueClause(statement)}`;\n  }\n\n  wrap(str) {\n    if (str.charAt(0) !== '(') return `(${str})`;\n    return str;\n  }\n\n  json(stmt) {\n    return this[stmt.method](stmt.params);\n  }\n\n  analytic(stmt) {\n    let sql = '';\n    const self = this;\n    sql += stmt.method + '() over (';\n\n    if (stmt.raw) {\n      sql += stmt.raw;\n    } else {\n      if (stmt.partitions.length) {\n        sql += 'partition by ';\n        sql +=\n          map(stmt.partitions, function (partition) {\n            if (isString(partition)) {\n              return self.formatter.columnize(partition);\n            } else return self.formatter.columnize(partition.column) + (partition.order ? ' ' + partition.order : '');\n          }).join(', ') + ' ';\n      }\n\n      sql += 'order by ';\n      sql += map(stmt.order, function (order) {\n        if (isString(order)) {\n          return self.formatter.columnize(order);\n        } else return self.formatter.columnize(order.column) + (order.order ? ' ' + order.order : '');\n      }).join(', ');\n    }\n\n    sql += ')';\n\n    if (stmt.alias) {\n      sql += ' as ' + stmt.alias;\n    }\n\n    return sql;\n  }\n\n  // Compiles all `with` statements on the query.\n  with() {\n    if (!this.grouped.with || !this.grouped.with.length) {\n      return '';\n    }\n    const withs = this.grouped.with;\n    if (!withs) return;\n    const sql = [];\n    let i = -1;\n    let isRecursive = false;\n    while (++i < withs.length) {\n      const stmt = withs[i];\n      if (stmt.recursive) {\n        isRecursive = true;\n      }\n      const val = this[stmt.type](stmt);\n      sql.push(val);\n    }\n    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;\n  }\n\n  withWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    const columnList = statement.columnList\n      ? '(' +\n        columnize_(\n          statement.columnList,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        ) +\n        ')'\n      : '';\n    const materialized =\n      statement.materialized === undefined\n        ? ''\n        : statement.materialized\n        ? 'materialized '\n        : 'not materialized ';\n    return (\n      (val &&\n        columnize_(\n          statement.alias,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        ) +\n          columnList +\n          ' as ' +\n          materialized +\n          '(' +\n          val +\n          ')') ||\n      ''\n    );\n  }\n\n  // Determines whether to add a \"not\" prefix to the where clause.\n  _not(statement, str) {\n    if (statement.not) return `not ${str}`;\n    return str;\n  }\n\n  _prepInsert(data) {\n    const isRaw = rawOrFn_(\n      data,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    if (isRaw) return isRaw;\n    let columns = [];\n    const values = [];\n    if (!Array.isArray(data)) data = data ? [data] : [];\n    let i = -1;\n    while (++i < data.length) {\n      if (data[i] == null) break;\n      if (i === 0) columns = Object.keys(data[i]).sort();\n      const row = new Array(columns.length);\n      const keys = Object.keys(data[i]);\n      let j = -1;\n      while (++j < keys.length) {\n        const key = keys[j];\n        let idx = columns.indexOf(key);\n        if (idx === -1) {\n          columns = columns.concat(key).sort();\n          idx = columns.indexOf(key);\n          let k = -1;\n          while (++k < values.length) {\n            values[k].splice(idx, 0, undefined);\n          }\n          row.splice(idx, 0, undefined);\n        }\n        row[idx] = data[i][key];\n      }\n      values.push(row);\n    }\n    return {\n      columns,\n      values,\n    };\n  }\n\n  // \"Preps\" the update.\n  _prepUpdate(data = {}) {\n    const { counter = {} } = this.single;\n\n    for (const column of Object.keys(counter)) {\n      //Skip?\n      if (has(data, column)) {\n        //Needed?\n        this.client.logger.warn(\n          `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`\n        );\n        continue;\n      }\n\n      let value = counter[column];\n\n      const symbol = value < 0 ? '-' : '+';\n\n      if (symbol === '-') {\n        value = -value;\n      }\n\n      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);\n    }\n\n    data = omitBy(data, isUndefined);\n\n    const vals = [];\n    const columns = Object.keys(data);\n    let i = -1;\n\n    while (++i < columns.length) {\n      vals.push(\n        wrap_(\n          columns[i],\n          undefined,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        ) +\n          ' = ' +\n          this.client.parameter(\n            data[columns[i]],\n            this.builder,\n            this.bindingsHolder\n          )\n      );\n    }\n\n    if (isEmpty(vals)) {\n      throw new Error(\n        [\n          'Empty .update() call detected!',\n          'Update data does not contain any values to update.',\n          'This will result in a faulty query.',\n          this.single.table ? `Table: ${this.single.table}.` : '',\n          this.single.update\n            ? `Columns: ${Object.keys(this.single.update)}.`\n            : '',\n        ].join(' ')\n      );\n    }\n\n    return vals;\n  }\n\n  _formatGroupsItemValue(value, nulls) {\n    const { formatter } = this;\n    let nullOrder = '';\n    if (nulls === 'last') {\n      nullOrder = ' is null';\n    } else if (nulls === 'first') {\n      nullOrder = ' is not null';\n    }\n\n    let groupOrder;\n    if (value instanceof Raw) {\n      groupOrder = unwrapRaw_(\n        value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    } else if (value instanceof QueryBuilder || nulls) {\n      groupOrder = '(' + formatter.columnize(value) + nullOrder + ')';\n    } else {\n      groupOrder = formatter.columnize(value);\n    }\n    return groupOrder;\n  }\n\n  _basicGroupOrder(item, type) {\n    const column = this._formatGroupsItemValue(item.value, item.nulls);\n    const direction =\n      type === 'order' && item.type !== 'orderByRaw'\n        ? ` ${direction_(\n            item.direction,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )}`\n        : '';\n    return column + direction;\n  }\n\n  _groupOrder(item, type) {\n    return this._basicGroupOrder(item, type);\n  }\n\n  _groupOrderNulls(item, type) {\n    const column = this._formatGroupsItemValue(item.value);\n    const direction =\n      type === 'order' && item.type !== 'orderByRaw'\n        ? ` ${direction_(\n            item.direction,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )}`\n        : '';\n    if (item.nulls && !(item.value instanceof Raw)) {\n      return `${column}${direction ? direction : ''} nulls ${item.nulls}`;\n    }\n    return column + direction;\n  }\n\n  // Compiles the `order by` statements.\n  _groupsOrders(type) {\n    const items = this.grouped[type];\n    if (!items) return '';\n    const sql = items.map((item) => {\n      return this._groupOrder(item, type);\n    });\n    return sql.length ? type + ' by ' + sql.join(', ') : '';\n  }\n\n  // Get the table name, wrapping it if necessary.\n  // Implemented as a property to prevent ordering issues as described in #704.\n  get tableName() {\n    if (!this._tableName) {\n      // Only call this.formatter.wrap() the first time this property is accessed.\n      let tableName = this.single.table;\n      const schemaName = this.single.schema;\n\n      if (tableName && schemaName) {\n        const isQueryBuilder = tableName instanceof QueryBuilder;\n        const isRawQuery = tableName instanceof Raw;\n        const isFunction = typeof tableName === 'function';\n\n        if (!isQueryBuilder && !isRawQuery && !isFunction) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n      }\n\n      this._tableName = tableName\n        ? // Wrap subQuery with parenthesis, #3485\n          wrap_(\n            tableName,\n            tableName instanceof QueryBuilder,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )\n        : '';\n    }\n    return this._tableName;\n  }\n\n  _jsonPathWrap(extraction) {\n    return this.client.parameter(\n      extraction.path || extraction[1],\n      this.builder,\n      this.bindingsHolder\n    );\n  }\n\n  // Json common functions\n  _jsonExtract(nameFunction, params) {\n    let extractions;\n    if (Array.isArray(params.column)) {\n      extractions = params.column;\n    } else {\n      extractions = [params];\n    }\n    if (!Array.isArray(nameFunction)) {\n      nameFunction = [nameFunction];\n    }\n    return extractions\n      .map((extraction) => {\n        let jsonCol = `${columnize_(\n          extraction.column || extraction[0],\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )}, ${this._jsonPathWrap(extraction)}`;\n        nameFunction.forEach((f) => {\n          jsonCol = f + '(' + jsonCol + ')';\n        });\n        const alias = extraction.alias || extraction[2];\n        return alias\n          ? this.client.alias(jsonCol, this.formatter.wrap(alias))\n          : jsonCol;\n      })\n      .join(', ');\n  }\n\n  _jsonSet(nameFunction, params) {\n    const jsonSet = `${nameFunction}(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )}, ${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )}, ${this.client.parameter(\n      params.value,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n    return params.alias\n      ? this.client.alias(jsonSet, this.formatter.wrap(params.alias))\n      : jsonSet;\n  }\n\n  _whereJsonPath(nameFunction, statement) {\n    return `${nameFunction}(${this._columnClause(\n      statement\n    )}, ${this._jsonPathWrap({ path: statement.jsonPath })}) ${operator_(\n      statement.operator,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )} ${this._jsonValueClause(statement)}`;\n  }\n\n  _onJsonPathEquals(nameJoinFunction, clause) {\n    return (\n      nameJoinFunction +\n      '(' +\n      wrap_(\n        clause.columnFirst,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ', ' +\n      this.client.parameter(\n        clause.jsonPathFirst,\n        this.builder,\n        this.bindingsHolder\n      ) +\n      ') = ' +\n      nameJoinFunction +\n      '(' +\n      wrap_(\n        clause.columnSecond,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ', ' +\n      this.client.parameter(\n        clause.jsonPathSecond,\n        this.builder,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n}\n\nmodule.exports = QueryCompiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}