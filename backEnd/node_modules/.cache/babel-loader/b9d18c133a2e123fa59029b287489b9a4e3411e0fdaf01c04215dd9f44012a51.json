{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PendingOperation_1 = require(\"./PendingOperation\");\nconst Resource_1 = require(\"./Resource\");\nconst utils_1 = require(\"./utils\");\nconst events_1 = require(\"events\");\nconst timers_1 = require(\"timers\");\nclass Pool {\n  constructor(opt) {\n    this.destroyed = false;\n    this.emitter = new events_1.EventEmitter();\n    opt = opt || {};\n    if (!opt.create) {\n      throw new Error('Tarn: opt.create function most be provided');\n    }\n    if (!opt.destroy) {\n      throw new Error('Tarn: opt.destroy function most be provided');\n    }\n    if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n      throw new Error('Tarn: opt.min must be an integer >= 0');\n    }\n    if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n      throw new Error('Tarn: opt.max must be an integer > 0');\n    }\n    if (opt.min > opt.max) {\n      throw new Error('Tarn: opt.max is smaller than opt.min');\n    }\n    if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n    }\n    if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n    }\n    if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n    }\n    if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n    }\n    if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n    }\n    if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' + JSON.stringify(opt.createRetryIntervalMillis));\n    }\n    const allowedKeys = {\n      create: true,\n      validate: true,\n      destroy: true,\n      log: true,\n      min: true,\n      max: true,\n      acquireTimeoutMillis: true,\n      createTimeoutMillis: true,\n      destroyTimeoutMillis: true,\n      idleTimeoutMillis: true,\n      reapIntervalMillis: true,\n      createRetryIntervalMillis: true,\n      propagateCreateError: true\n    };\n    for (const key of Object.keys(opt)) {\n      if (!allowedKeys[key]) {\n        throw new Error(`Tarn: unsupported option opt.${key}`);\n      }\n    }\n    this.creator = opt.create;\n    this.destroyer = opt.destroy;\n    this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\n    this.log = opt.log || (() => {});\n    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n    this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n    this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n    this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n    this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n    this.propagateCreateError = !!opt.propagateCreateError;\n    this.min = opt.min;\n    this.max = opt.max;\n    // All the resources, which are either already acquired or which are\n    // considered for being passed to acquire in async validation phase.\n    this.used = [];\n    // All the resources, which are either just created and free or returned\n    // back to pool after using.\n    this.free = [];\n    this.pendingCreates = [];\n    this.pendingAcquires = [];\n    this.pendingDestroys = [];\n    // When acquire is pending, but also still in validation phase\n    this.pendingValidations = [];\n    this.destroyed = false;\n    this.interval = null;\n    this.eventId = 1;\n  }\n  numUsed() {\n    return this.used.length;\n  }\n  numFree() {\n    return this.free.length;\n  }\n  numPendingAcquires() {\n    return this.pendingAcquires.length;\n  }\n  numPendingValidations() {\n    return this.pendingValidations.length;\n  }\n  numPendingCreates() {\n    return this.pendingCreates.length;\n  }\n  acquire() {\n    const eventId = this.eventId++;\n    this._executeEventHandlers('acquireRequest', eventId);\n    const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n    this.pendingAcquires.push(pendingAcquire);\n    // If the acquire fails for whatever reason\n    // remove it from the pending queue.\n    pendingAcquire.promise = pendingAcquire.promise.then(resource => {\n      this._executeEventHandlers('acquireSuccess', eventId, resource);\n      return resource;\n    }).catch(err => {\n      this._executeEventHandlers('acquireFail', eventId, err);\n      remove(this.pendingAcquires, pendingAcquire);\n      return Promise.reject(err);\n    });\n    this._tryAcquireOrCreate();\n    return pendingAcquire;\n  }\n  release(resource) {\n    this._executeEventHandlers('release', resource);\n    for (let i = 0, l = this.used.length; i < l; ++i) {\n      const used = this.used[i];\n      if (used.resource === resource) {\n        this.used.splice(i, 1);\n        this.free.push(used.resolve());\n        this._tryAcquireOrCreate();\n        return true;\n      }\n    }\n    return false;\n  }\n  isEmpty() {\n    return [this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingValidations(), this.numPendingCreates()].reduce((total, value) => total + value) === 0;\n  }\n  /**\r\n   * Reaping cycle.\r\n   */\n  check() {\n    const timestamp = utils_1.now();\n    const newFree = [];\n    const minKeep = this.min - this.used.length;\n    const maxDestroy = this.free.length - minKeep;\n    let numDestroyed = 0;\n    this.free.forEach(free => {\n      if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {\n        numDestroyed++;\n        this._destroy(free.resource);\n      } else {\n        newFree.push(free);\n      }\n    });\n    this.free = newFree;\n    // Pool is completely empty, stop reaping.\n    // Next .acquire will start reaping interval again.\n    if (this.isEmpty()) {\n      this._stopReaping();\n    }\n  }\n  destroy() {\n    const eventId = this.eventId++;\n    this._executeEventHandlers('poolDestroyRequest', eventId);\n    this._stopReaping();\n    this.destroyed = true;\n    // First wait for all the pending creates get ready.\n    return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise))).then(() => {\n      // eslint-disable-next-line\n      return new Promise((resolve, reject) => {\n        // poll every 100ms and wait that all validations are ready\n        if (this.numPendingValidations() === 0) {\n          resolve();\n          return;\n        }\n        const interval = setInterval(() => {\n          if (this.numPendingValidations() === 0) {\n            timers_1.clearInterval(interval);\n            resolve();\n          }\n        }, 100);\n      });\n    }).then(() => {\n      // Wait for all the used resources to be freed.\n      return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\n    }).then(() => {\n      // Abort all pending acquires.\n      return Promise.all(this.pendingAcquires.map(acquire => {\n        acquire.abort();\n        return utils_1.reflect(acquire.promise);\n      }));\n    }).then(() => {\n      // Now we can destroy all the freed resources.\n      return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\n    }).then(() => {\n      // Also wait rest of the pending destroys to finish\n      return Promise.all(this.pendingDestroys.map(pd => pd.promise));\n    }).then(() => {\n      this.free = [];\n      this.pendingAcquires = [];\n    })).then(res => {\n      this._executeEventHandlers('poolDestroySuccess', eventId);\n      this.emitter.removeAllListeners();\n      return res;\n    });\n  }\n  on(event, listener) {\n    this.emitter.on(event, listener);\n  }\n  removeListener(event, listener) {\n    this.emitter.removeListener(event, listener);\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n  }\n  /**\r\n   * The most important method that is called always when resources\r\n   * are created / destroyed / acquired / released. In other words\r\n   * every time when resources are moved from used to free or vice\r\n   * versa.\r\n   *\r\n   * Either assigns free resources to pendingAcquires or creates new\r\n   * resources if there is room for it in the pool.\r\n   */\n  _tryAcquireOrCreate() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._hasFreeResources()) {\n      this._doAcquire();\n    } else if (this._shouldCreateMoreResources()) {\n      this._doCreate();\n    }\n  }\n  _hasFreeResources() {\n    return this.free.length > 0;\n  }\n  _doAcquire() {\n    // Acquire as many pending acquires as possible concurrently\n    while (this._canAcquire()) {\n      // To allow async validation, we actually need to move free resource\n      // and pending acquire temporary from their respective arrays and depending\n      // on validation result to either leave the free resource to used resources array\n      // or destroy the free resource if validation did fail.\n      const pendingAcquire = this.pendingAcquires.shift();\n      const free = this.free.pop();\n      if (free === undefined || pendingAcquire === undefined) {\n        const errMessage = 'this.free was empty while trying to acquire resource';\n        this.log(`Tarn: ${errMessage}`, 'warn');\n        throw new Error(`Internal error, should never happen. ${errMessage}`);\n      }\n      // Make sure that pendingAcquire that is being validated is not lost and\n      // can be freed when pool is destroyed.\n      this.pendingValidations.push(pendingAcquire);\n      // Must be added here pre-emptively to prevent logic that decides\n      // if new resources are created will keep on working correctly.\n      this.used.push(free);\n      // if acquire fails also pending validation, must be aborted so that pre reserved\n      // resource will be returned to free resources immediately\n      const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n      // eslint-disable-next-line\n      pendingAcquire.promise.catch(err => {\n        abortAbleValidation.abort();\n      });\n      abortAbleValidation.promise.catch(err => {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n        return false;\n      }).then(validationSuccess => {\n        try {\n          if (validationSuccess && !pendingAcquire.isRejected) {\n            // At least one active resource exist, start reaping.\n            this._startReaping();\n            pendingAcquire.resolve(free.resource);\n          } else {\n            remove(this.used, free);\n            // Only destroy the resource if the validation has failed\n            if (!validationSuccess) {\n              this._destroy(free.resource);\n              // Since we destroyed an invalid resource and were not able to fulfill\n              // all the pending acquires, we may need to create new ones or at\n              // least run this acquire loop again to verify it. But not immediately\n              // to prevent starving event loop.\n              setTimeout(() => {\n                this._tryAcquireOrCreate();\n              }, 0);\n            } else {\n              this.free.push(free);\n            }\n            // is acquire was canceled, failed or timed out already\n            // no need to return it to pending queries\n            if (!pendingAcquire.isRejected) {\n              this.pendingAcquires.unshift(pendingAcquire);\n            }\n          }\n        } finally {\n          remove(this.pendingValidations, pendingAcquire);\n        }\n      });\n      // try to validate\n      this._validateResource(free.resource).then(validationSuccess => {\n        abortAbleValidation.resolve(validationSuccess);\n      }).catch(err => {\n        abortAbleValidation.reject(err);\n      });\n    }\n  }\n  _canAcquire() {\n    return this.free.length > 0 && this.pendingAcquires.length > 0;\n  }\n  _validateResource(resource) {\n    try {\n      return Promise.resolve(this.validate(resource));\n    } catch (err) {\n      // prevent leaking of sync exception\n      return Promise.reject(err);\n    }\n  }\n  _shouldCreateMoreResources() {\n    return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;\n  }\n  _doCreate() {\n    const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n    const pendingCreate = this._create();\n    pendingCreate.promise.then(() => {\n      // Not returned on purpose.\n      this._tryAcquireOrCreate();\n      return null;\n    }).catch(err => {\n      if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\n        // If propagateCreateError is true, we don't retry the create\n        // but reject the first pending acquire immediately. Intentionally\n        // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n        // in case some acquires in pendingAcquiresBeforeCreate have already\n        // been resolved.\n        this.pendingAcquires[0].reject(err);\n      }\n      // Save the create error to all pending acquires so that we can use it\n      // as the error to reject the acquire if it times out.\n      pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\n        pendingAcquire.possibleTimeoutCause = err;\n      });\n      // Not returned on purpose.\n      utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\n    });\n  }\n  _create() {\n    const eventId = this.eventId++;\n    this._executeEventHandlers('createRequest', eventId);\n    const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\n    // If an error occurs (likely a create timeout) remove this creation from\n    // the list of pending creations so we try to create a new one.\n    pendingCreate.promise = pendingCreate.promise.catch(err => {\n      if (remove(this.pendingCreates, pendingCreate)) {\n        // TODO: figure out more consistent way for different error handlers in next rewrite\n        this._executeEventHandlers('createFail', eventId, err);\n      }\n      throw err;\n    });\n    this.pendingCreates.push(pendingCreate);\n    callbackOrPromise(this.creator).then(resource => {\n      if (pendingCreate.isRejected) {\n        this.destroyer(resource);\n        return null;\n      }\n      remove(this.pendingCreates, pendingCreate);\n      this.free.push(new Resource_1.Resource(resource));\n      // Not returned on purpose.\n      pendingCreate.resolve(resource);\n      this._executeEventHandlers('createSuccess', eventId, resource);\n      return null;\n    }).catch(err => {\n      if (pendingCreate.isRejected) {\n        return null;\n      }\n      if (remove(this.pendingCreates, pendingCreate)) {\n        this._executeEventHandlers('createFail', eventId, err);\n      }\n      // Not returned on purpose.\n      pendingCreate.reject(err);\n      return null;\n    });\n    return pendingCreate;\n  }\n  _destroy(resource) {\n    const eventId = this.eventId++;\n    this._executeEventHandlers('destroyRequest', eventId, resource);\n    // this.destroyer can be both synchronous and asynchronous.\n    // so we wrap it to promise to get all exceptions through same pipeline\n    const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n    const retVal = Promise.resolve().then(() => this.destroyer(resource));\n    retVal.then(() => {\n      pendingDestroy.resolve(resource);\n    }).catch(err => {\n      pendingDestroy.reject(err);\n    });\n    this.pendingDestroys.push(pendingDestroy);\n    // In case of an error there's nothing we can do here but log it.\n    return pendingDestroy.promise.then(res => {\n      this._executeEventHandlers('destroySuccess', eventId, resource);\n      return res;\n    }).catch(err => this._logDestroyerError(eventId, resource, err)).then(res => {\n      const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);\n      this.pendingDestroys.splice(index, 1);\n      return res;\n    });\n  }\n  _logDestroyerError(eventId, resource, err) {\n    this._executeEventHandlers('destroyFail', eventId, resource, err);\n    this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n  }\n  _startReaping() {\n    if (!this.interval) {\n      this._executeEventHandlers('startReaping');\n      this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\n    }\n  }\n  _stopReaping() {\n    if (this.interval !== null) {\n      this._executeEventHandlers('stopReaping');\n      timers_1.clearInterval(this.interval);\n    }\n    this.interval = null;\n  }\n  _executeEventHandlers(eventName, ...args) {\n    const listeners = this.emitter.listeners(eventName);\n    // just calling .emit() would stop running rest of the listeners if one them fails\n    listeners.forEach(listener => {\n      try {\n        listener(...args);\n      } catch (err) {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log(`Tarn: event handler \"${eventName}\" threw an exception ${err.stack}`, 'warn');\n      }\n    });\n  }\n}\nexports.Pool = Pool;\nfunction remove(arr, item) {\n  const idx = arr.indexOf(item);\n  if (idx === -1) {\n    return false;\n  } else {\n    arr.splice(idx, 1);\n    return true;\n  }\n}\nfunction callbackOrPromise(func) {\n  return new Promise((resolve, reject) => {\n    const callback = (err, resource) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(resource);\n      }\n    };\n    utils_1.tryPromise(() => func(callback)).then(res => {\n      // If the result is falsy, we assume that the callback will\n      // be called instead of interpreting the falsy value as a\n      // result value.\n      if (res) {\n        resolve(res);\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","PendingOperation_1","require","Resource_1","utils_1","events_1","timers_1","Pool","constructor","opt","destroyed","emitter","EventEmitter","create","Error","destroy","min","Math","round","max","checkOptionalTime","acquireTimeoutMillis","JSON","stringify","createTimeoutMillis","destroyTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","createRetryIntervalMillis","allowedKeys","validate","log","propagateCreateError","key","keys","creator","destroyer","used","free","pendingCreates","pendingAcquires","pendingDestroys","pendingValidations","interval","eventId","numUsed","length","numFree","numPendingAcquires","numPendingValidations","numPendingCreates","acquire","_executeEventHandlers","pendingAcquire","PendingOperation","push","promise","then","resource","catch","err","remove","Promise","reject","_tryAcquireOrCreate","release","i","l","splice","resolve","isEmpty","reduce","total","check","timestamp","now","newFree","minKeep","maxDestroy","numDestroyed","forEach","duration","_destroy","_stopReaping","reflect","all","map","setInterval","clearInterval","abort","pd","res","removeAllListeners","on","event","listener","removeListener","_hasFreeResources","_doAcquire","_shouldCreateMoreResources","_doCreate","_canAcquire","shift","pop","undefined","errMessage","abortAbleValidation","stack","validationSuccess","isRejected","_startReaping","setTimeout","unshift","_validateResource","pendingAcquiresBeforeCreate","slice","pendingCreate","_create","possibleTimeoutCause","delay","callbackOrPromise","Resource","pendingDestroy","retVal","_logDestroyerError","index","findIndex","eventName","args","listeners","arr","item","idx","indexOf","func","callback","tryPromise"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/tarn/dist/Pool.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst PendingOperation_1 = require(\"./PendingOperation\");\r\nconst Resource_1 = require(\"./Resource\");\r\nconst utils_1 = require(\"./utils\");\r\nconst events_1 = require(\"events\");\r\nconst timers_1 = require(\"timers\");\r\nclass Pool {\r\n    constructor(opt) {\r\n        this.destroyed = false;\r\n        this.emitter = new events_1.EventEmitter();\r\n        opt = opt || {};\r\n        if (!opt.create) {\r\n            throw new Error('Tarn: opt.create function most be provided');\r\n        }\r\n        if (!opt.destroy) {\r\n            throw new Error('Tarn: opt.destroy function most be provided');\r\n        }\r\n        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\r\n            throw new Error('Tarn: opt.min must be an integer >= 0');\r\n        }\r\n        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\r\n            throw new Error('Tarn: opt.max must be an integer > 0');\r\n        }\r\n        if (opt.min > opt.max) {\r\n            throw new Error('Tarn: opt.max is smaller than opt.min');\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\r\n            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\r\n            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +\r\n                JSON.stringify(opt.createRetryIntervalMillis));\r\n        }\r\n        const allowedKeys = {\r\n            create: true,\r\n            validate: true,\r\n            destroy: true,\r\n            log: true,\r\n            min: true,\r\n            max: true,\r\n            acquireTimeoutMillis: true,\r\n            createTimeoutMillis: true,\r\n            destroyTimeoutMillis: true,\r\n            idleTimeoutMillis: true,\r\n            reapIntervalMillis: true,\r\n            createRetryIntervalMillis: true,\r\n            propagateCreateError: true\r\n        };\r\n        for (const key of Object.keys(opt)) {\r\n            if (!allowedKeys[key]) {\r\n                throw new Error(`Tarn: unsupported option opt.${key}`);\r\n            }\r\n        }\r\n        this.creator = opt.create;\r\n        this.destroyer = opt.destroy;\r\n        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\r\n        this.log = opt.log || (() => { });\r\n        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\r\n        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\r\n        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\r\n        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\r\n        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\r\n        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\r\n        this.propagateCreateError = !!opt.propagateCreateError;\r\n        this.min = opt.min;\r\n        this.max = opt.max;\r\n        // All the resources, which are either already acquired or which are\r\n        // considered for being passed to acquire in async validation phase.\r\n        this.used = [];\r\n        // All the resources, which are either just created and free or returned\r\n        // back to pool after using.\r\n        this.free = [];\r\n        this.pendingCreates = [];\r\n        this.pendingAcquires = [];\r\n        this.pendingDestroys = [];\r\n        // When acquire is pending, but also still in validation phase\r\n        this.pendingValidations = [];\r\n        this.destroyed = false;\r\n        this.interval = null;\r\n        this.eventId = 1;\r\n    }\r\n    numUsed() {\r\n        return this.used.length;\r\n    }\r\n    numFree() {\r\n        return this.free.length;\r\n    }\r\n    numPendingAcquires() {\r\n        return this.pendingAcquires.length;\r\n    }\r\n    numPendingValidations() {\r\n        return this.pendingValidations.length;\r\n    }\r\n    numPendingCreates() {\r\n        return this.pendingCreates.length;\r\n    }\r\n    acquire() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('acquireRequest', eventId);\r\n        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\r\n        this.pendingAcquires.push(pendingAcquire);\r\n        // If the acquire fails for whatever reason\r\n        // remove it from the pending queue.\r\n        pendingAcquire.promise = pendingAcquire.promise\r\n            .then(resource => {\r\n            this._executeEventHandlers('acquireSuccess', eventId, resource);\r\n            return resource;\r\n        })\r\n            .catch(err => {\r\n            this._executeEventHandlers('acquireFail', eventId, err);\r\n            remove(this.pendingAcquires, pendingAcquire);\r\n            return Promise.reject(err);\r\n        });\r\n        this._tryAcquireOrCreate();\r\n        return pendingAcquire;\r\n    }\r\n    release(resource) {\r\n        this._executeEventHandlers('release', resource);\r\n        for (let i = 0, l = this.used.length; i < l; ++i) {\r\n            const used = this.used[i];\r\n            if (used.resource === resource) {\r\n                this.used.splice(i, 1);\r\n                this.free.push(used.resolve());\r\n                this._tryAcquireOrCreate();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isEmpty() {\r\n        return ([\r\n            this.numFree(),\r\n            this.numUsed(),\r\n            this.numPendingAcquires(),\r\n            this.numPendingValidations(),\r\n            this.numPendingCreates()\r\n        ].reduce((total, value) => total + value) === 0);\r\n    }\r\n    /**\r\n     * Reaping cycle.\r\n     */\r\n    check() {\r\n        const timestamp = utils_1.now();\r\n        const newFree = [];\r\n        const minKeep = this.min - this.used.length;\r\n        const maxDestroy = this.free.length - minKeep;\r\n        let numDestroyed = 0;\r\n        this.free.forEach(free => {\r\n            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&\r\n                numDestroyed < maxDestroy) {\r\n                numDestroyed++;\r\n                this._destroy(free.resource);\r\n            }\r\n            else {\r\n                newFree.push(free);\r\n            }\r\n        });\r\n        this.free = newFree;\r\n        // Pool is completely empty, stop reaping.\r\n        // Next .acquire will start reaping interval again.\r\n        if (this.isEmpty()) {\r\n            this._stopReaping();\r\n        }\r\n    }\r\n    destroy() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('poolDestroyRequest', eventId);\r\n        this._stopReaping();\r\n        this.destroyed = true;\r\n        // First wait for all the pending creates get ready.\r\n        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))\r\n            .then(() => {\r\n            // eslint-disable-next-line\r\n            return new Promise((resolve, reject) => {\r\n                // poll every 100ms and wait that all validations are ready\r\n                if (this.numPendingValidations() === 0) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const interval = setInterval(() => {\r\n                    if (this.numPendingValidations() === 0) {\r\n                        timers_1.clearInterval(interval);\r\n                        resolve();\r\n                    }\r\n                }, 100);\r\n            });\r\n        })\r\n            .then(() => {\r\n            // Wait for all the used resources to be freed.\r\n            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\r\n        })\r\n            .then(() => {\r\n            // Abort all pending acquires.\r\n            return Promise.all(this.pendingAcquires.map(acquire => {\r\n                acquire.abort();\r\n                return utils_1.reflect(acquire.promise);\r\n            }));\r\n        })\r\n            .then(() => {\r\n            // Now we can destroy all the freed resources.\r\n            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\r\n        })\r\n            .then(() => {\r\n            // Also wait rest of the pending destroys to finish\r\n            return Promise.all(this.pendingDestroys.map(pd => pd.promise));\r\n        })\r\n            .then(() => {\r\n            this.free = [];\r\n            this.pendingAcquires = [];\r\n        })).then(res => {\r\n            this._executeEventHandlers('poolDestroySuccess', eventId);\r\n            this.emitter.removeAllListeners();\r\n            return res;\r\n        });\r\n    }\r\n    on(event, listener) {\r\n        this.emitter.on(event, listener);\r\n    }\r\n    removeListener(event, listener) {\r\n        this.emitter.removeListener(event, listener);\r\n    }\r\n    removeAllListeners(event) {\r\n        this.emitter.removeAllListeners(event);\r\n    }\r\n    /**\r\n     * The most important method that is called always when resources\r\n     * are created / destroyed / acquired / released. In other words\r\n     * every time when resources are moved from used to free or vice\r\n     * versa.\r\n     *\r\n     * Either assigns free resources to pendingAcquires or creates new\r\n     * resources if there is room for it in the pool.\r\n     */\r\n    _tryAcquireOrCreate() {\r\n        if (this.destroyed) {\r\n            return;\r\n        }\r\n        if (this._hasFreeResources()) {\r\n            this._doAcquire();\r\n        }\r\n        else if (this._shouldCreateMoreResources()) {\r\n            this._doCreate();\r\n        }\r\n    }\r\n    _hasFreeResources() {\r\n        return this.free.length > 0;\r\n    }\r\n    _doAcquire() {\r\n        // Acquire as many pending acquires as possible concurrently\r\n        while (this._canAcquire()) {\r\n            // To allow async validation, we actually need to move free resource\r\n            // and pending acquire temporary from their respective arrays and depending\r\n            // on validation result to either leave the free resource to used resources array\r\n            // or destroy the free resource if validation did fail.\r\n            const pendingAcquire = this.pendingAcquires.shift();\r\n            const free = this.free.pop();\r\n            if (free === undefined || pendingAcquire === undefined) {\r\n                const errMessage = 'this.free was empty while trying to acquire resource';\r\n                this.log(`Tarn: ${errMessage}`, 'warn');\r\n                throw new Error(`Internal error, should never happen. ${errMessage}`);\r\n            }\r\n            // Make sure that pendingAcquire that is being validated is not lost and\r\n            // can be freed when pool is destroyed.\r\n            this.pendingValidations.push(pendingAcquire);\r\n            // Must be added here pre-emptively to prevent logic that decides\r\n            // if new resources are created will keep on working correctly.\r\n            this.used.push(free);\r\n            // if acquire fails also pending validation, must be aborted so that pre reserved\r\n            // resource will be returned to free resources immediately\r\n            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\r\n            // eslint-disable-next-line\r\n            pendingAcquire.promise.catch(err => {\r\n                abortAbleValidation.abort();\r\n            });\r\n            abortAbleValidation.promise\r\n                .catch(err => {\r\n                // There's nothing we can do here but log the error. This would otherwise\r\n                // leak out as an unhandled exception.\r\n                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\r\n                return false;\r\n            })\r\n                .then(validationSuccess => {\r\n                try {\r\n                    if (validationSuccess && !pendingAcquire.isRejected) {\r\n                        // At least one active resource exist, start reaping.\r\n                        this._startReaping();\r\n                        pendingAcquire.resolve(free.resource);\r\n                    }\r\n                    else {\r\n                        remove(this.used, free);\r\n                        // Only destroy the resource if the validation has failed\r\n                        if (!validationSuccess) {\r\n                            this._destroy(free.resource);\r\n                            // Since we destroyed an invalid resource and were not able to fulfill\r\n                            // all the pending acquires, we may need to create new ones or at\r\n                            // least run this acquire loop again to verify it. But not immediately\r\n                            // to prevent starving event loop.\r\n                            setTimeout(() => {\r\n                                this._tryAcquireOrCreate();\r\n                            }, 0);\r\n                        }\r\n                        else {\r\n                            this.free.push(free);\r\n                        }\r\n                        // is acquire was canceled, failed or timed out already\r\n                        // no need to return it to pending queries\r\n                        if (!pendingAcquire.isRejected) {\r\n                            this.pendingAcquires.unshift(pendingAcquire);\r\n                        }\r\n                    }\r\n                }\r\n                finally {\r\n                    remove(this.pendingValidations, pendingAcquire);\r\n                }\r\n            });\r\n            // try to validate\r\n            this._validateResource(free.resource)\r\n                .then(validationSuccess => {\r\n                abortAbleValidation.resolve(validationSuccess);\r\n            })\r\n                .catch(err => {\r\n                abortAbleValidation.reject(err);\r\n            });\r\n        }\r\n    }\r\n    _canAcquire() {\r\n        return this.free.length > 0 && this.pendingAcquires.length > 0;\r\n    }\r\n    _validateResource(resource) {\r\n        try {\r\n            return Promise.resolve(this.validate(resource));\r\n        }\r\n        catch (err) {\r\n            // prevent leaking of sync exception\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n    _shouldCreateMoreResources() {\r\n        return (this.used.length + this.pendingCreates.length < this.max &&\r\n            this.pendingCreates.length < this.pendingAcquires.length);\r\n    }\r\n    _doCreate() {\r\n        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\r\n        const pendingCreate = this._create();\r\n        pendingCreate.promise\r\n            .then(() => {\r\n            // Not returned on purpose.\r\n            this._tryAcquireOrCreate();\r\n            return null;\r\n        })\r\n            .catch(err => {\r\n            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\r\n                // If propagateCreateError is true, we don't retry the create\r\n                // but reject the first pending acquire immediately. Intentionally\r\n                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\r\n                // in case some acquires in pendingAcquiresBeforeCreate have already\r\n                // been resolved.\r\n                this.pendingAcquires[0].reject(err);\r\n            }\r\n            // Save the create error to all pending acquires so that we can use it\r\n            // as the error to reject the acquire if it times out.\r\n            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\r\n                pendingAcquire.possibleTimeoutCause = err;\r\n            });\r\n            // Not returned on purpose.\r\n            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\r\n        });\r\n    }\r\n    _create() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('createRequest', eventId);\r\n        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\r\n        // If an error occurs (likely a create timeout) remove this creation from\r\n        // the list of pending creations so we try to create a new one.\r\n        pendingCreate.promise = pendingCreate.promise.catch(err => {\r\n            if (remove(this.pendingCreates, pendingCreate)) {\r\n                // TODO: figure out more consistent way for different error handlers in next rewrite\r\n                this._executeEventHandlers('createFail', eventId, err);\r\n            }\r\n            throw err;\r\n        });\r\n        this.pendingCreates.push(pendingCreate);\r\n        callbackOrPromise(this.creator)\r\n            .then(resource => {\r\n            if (pendingCreate.isRejected) {\r\n                this.destroyer(resource);\r\n                return null;\r\n            }\r\n            remove(this.pendingCreates, pendingCreate);\r\n            this.free.push(new Resource_1.Resource(resource));\r\n            // Not returned on purpose.\r\n            pendingCreate.resolve(resource);\r\n            this._executeEventHandlers('createSuccess', eventId, resource);\r\n            return null;\r\n        })\r\n            .catch(err => {\r\n            if (pendingCreate.isRejected) {\r\n                return null;\r\n            }\r\n            if (remove(this.pendingCreates, pendingCreate)) {\r\n                this._executeEventHandlers('createFail', eventId, err);\r\n            }\r\n            // Not returned on purpose.\r\n            pendingCreate.reject(err);\r\n            return null;\r\n        });\r\n        return pendingCreate;\r\n    }\r\n    _destroy(resource) {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('destroyRequest', eventId, resource);\r\n        // this.destroyer can be both synchronous and asynchronous.\r\n        // so we wrap it to promise to get all exceptions through same pipeline\r\n        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\r\n        const retVal = Promise.resolve().then(() => this.destroyer(resource));\r\n        retVal\r\n            .then(() => {\r\n            pendingDestroy.resolve(resource);\r\n        })\r\n            .catch((err) => {\r\n            pendingDestroy.reject(err);\r\n        });\r\n        this.pendingDestroys.push(pendingDestroy);\r\n        // In case of an error there's nothing we can do here but log it.\r\n        return pendingDestroy.promise\r\n            .then(res => {\r\n            this._executeEventHandlers('destroySuccess', eventId, resource);\r\n            return res;\r\n        })\r\n            .catch(err => this._logDestroyerError(eventId, resource, err))\r\n            .then(res => {\r\n            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);\r\n            this.pendingDestroys.splice(index, 1);\r\n            return res;\r\n        });\r\n    }\r\n    _logDestroyerError(eventId, resource, err) {\r\n        this._executeEventHandlers('destroyFail', eventId, resource, err);\r\n        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\r\n    }\r\n    _startReaping() {\r\n        if (!this.interval) {\r\n            this._executeEventHandlers('startReaping');\r\n            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\r\n        }\r\n    }\r\n    _stopReaping() {\r\n        if (this.interval !== null) {\r\n            this._executeEventHandlers('stopReaping');\r\n            timers_1.clearInterval(this.interval);\r\n        }\r\n        this.interval = null;\r\n    }\r\n    _executeEventHandlers(eventName, ...args) {\r\n        const listeners = this.emitter.listeners(eventName);\r\n        // just calling .emit() would stop running rest of the listeners if one them fails\r\n        listeners.forEach(listener => {\r\n            try {\r\n                listener(...args);\r\n            }\r\n            catch (err) {\r\n                // There's nothing we can do here but log the error. This would otherwise\r\n                // leak out as an unhandled exception.\r\n                this.log(`Tarn: event handler \"${eventName}\" threw an exception ${err.stack}`, 'warn');\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.Pool = Pool;\r\nfunction remove(arr, item) {\r\n    const idx = arr.indexOf(item);\r\n    if (idx === -1) {\r\n        return false;\r\n    }\r\n    else {\r\n        arr.splice(idx, 1);\r\n        return true;\r\n    }\r\n}\r\nfunction callbackOrPromise(func) {\r\n    return new Promise((resolve, reject) => {\r\n        const callback = (err, resource) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve(resource);\r\n            }\r\n        };\r\n        utils_1.tryPromise(() => func(callback))\r\n            .then(res => {\r\n            // If the result is falsy, we assume that the callback will\r\n            // be called instead of interpreting the falsy value as a\r\n            // result value.\r\n            if (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n            .catch(err => {\r\n            reject(err);\r\n        });\r\n    });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}