{"ast":null,"code":"const filter = require('lodash/filter');\nconst values = require('lodash/values');\nconst identity = require('lodash/identity');\nconst {\n  isObject\n} = require('../../../util/is');\nconst TableCompiler = require('../../../schema/tablecompiler');\nconst {\n  formatDefault\n} = require('../../../formatter/formatterUtils');\nclass TableCompiler_SQLite3 extends TableCompiler {\n  constructor() {\n    super(...arguments);\n  }\n\n  // Create a new table.\n  createQuery(columns, ifNot, like) {\n    const createStatement = ifNot ? 'create table if not exists ' : 'create table ';\n    let sql = createStatement + this.tableName();\n    if (like && this.tableNameLike()) {\n      sql += ' as select * from ' + this.tableNameLike() + ' where 0=1';\n    } else {\n      // so we will need to check for a primary key commands and add the columns\n      // to the table's declaration here so they can be created on the tables.\n      sql += ' (' + columns.sql.join(', ');\n      sql += this.foreignKeys() || '';\n      sql += this.primaryKeys() || '';\n      sql += this._addChecks();\n      sql += ')';\n    }\n    this.pushQuery(sql);\n    if (like) {\n      this.addColumns(columns, this.addColumnsPrefix);\n    }\n  }\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      const compiler = this;\n      const columnsInfo = colCompilers.map(col => {\n        const name = this.client.customWrapIdentifier(col.getColumnName(), identity, col.columnBuilder.queryContext());\n        const type = col.getColumnType();\n        const defaultTo = col.modified['defaultTo'] ? formatDefault(col.modified['defaultTo'][0], col.type, this.client) : null;\n        const notNull = col.modified['nullable'] && col.modified['nullable'][0] === false;\n        return {\n          name,\n          type,\n          defaultTo,\n          notNull\n        };\n      });\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        statementsProducer(pragma, connection) {\n          return compiler.client.ddl(compiler, pragma, connection).alterColumn(columnsInfo);\n        }\n      });\n    } else {\n      for (let i = 0, l = columns.sql.length; i < l; i++) {\n        this.pushQuery({\n          sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,\n          bindings: columns.bindings[i]\n        });\n      }\n    }\n  }\n\n  // Compile a drop unique key command.\n  dropUnique(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a drop foreign key command.\n  dropForeign(columns, indexName) {\n    const compiler = this;\n    columns = Array.isArray(columns) ? columns : [columns];\n    columns = columns.map(column => this.client.customWrapIdentifier(column, identity));\n    indexName = this.client.customWrapIdentifier(indexName, identity);\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropForeign(columns, indexName);\n      }\n    });\n  }\n\n  // Compile a drop primary key command.\n  dropPrimary(constraintName) {\n    const compiler = this;\n    constraintName = this.client.customWrapIdentifier(constraintName, identity);\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropPrimary(constraintName);\n      }\n    });\n  }\n  dropIndex(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a unique key command.\n  unique(columns, indexName) {\n    let deferrable;\n    let predicate;\n    if (isObject(indexName)) {\n      ({\n        indexName,\n        deferrable,\n        predicate\n      } = indexName);\n    }\n    if (deferrable && deferrable !== 'not deferrable') {\n      this.client.logger.warn(`sqlite3: unique index \\`${indexName}\\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`);\n    }\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    const predicateQuery = predicate ? ' ' + this.client.queryCompiler(predicate).where() : '';\n    this.pushQuery(`create unique index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`);\n  }\n\n  // Compile a plain index key command.\n  index(columns, indexName, options) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    let predicate;\n    if (isObject(options)) {\n      ({\n        predicate\n      } = options);\n    }\n    const predicateQuery = predicate ? ' ' + this.client.queryCompiler(predicate).where() : '';\n    this.pushQuery(`create index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`);\n  }\n\n  /**\n   * Add a primary key to an existing table.\n   *\n   * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table\n   *       creation in this method\n   *\n   * @param {string | string[]} columns - Column name(s) to assign as primary keys\n   * @param {string} [constraintName] - Custom name for the PK constraint\n   */\n  primary(columns, constraintName) {\n    const compiler = this;\n    columns = Array.isArray(columns) ? columns : [columns];\n    columns = columns.map(column => this.client.customWrapIdentifier(column, identity));\n    let deferrable;\n    if (isObject(constraintName)) {\n      ({\n        constraintName,\n        deferrable\n      } = constraintName);\n    }\n    if (deferrable && deferrable !== 'not deferrable') {\n      this.client.logger.warn(`sqlite3: primary key constraint \\`${constraintName}\\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`);\n    }\n    constraintName = this.client.customWrapIdentifier(constraintName, identity);\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        output(pragma) {\n          return compiler.client.ddl(compiler, pragma, this.connection).primary(columns, constraintName);\n        }\n      });\n    }\n  }\n\n  /**\n   * Add a foreign key constraint to an existing table\n   *\n   * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do\n   *       anything regarding table creation in this method\n   *\n   * @param {object} foreignInfo - Information about the current column foreign setup\n   * @param {string | string[]} [foreignInfo.column] - Column in the current constraint\n   * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint\n   * @param {string | string[]} foreignInfo.references - What column it references in the other table\n   * @param {string} foreignInfo.inTable - What table is referenced in this constraint\n   * @param {string} [foreignInfo.onUpdate] - What to do on updates\n   * @param {string} [foreignInfo.onDelete] - What to do on deletions\n   */\n  foreign(foreignInfo) {\n    const compiler = this;\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      foreignInfo.column = Array.isArray(foreignInfo.column) ? foreignInfo.column : [foreignInfo.column];\n      foreignInfo.column = foreignInfo.column.map(column => this.client.customWrapIdentifier(column, identity));\n      foreignInfo.inTable = this.client.customWrapIdentifier(foreignInfo.inTable, identity);\n      foreignInfo.references = Array.isArray(foreignInfo.references) ? foreignInfo.references : [foreignInfo.references];\n      foreignInfo.references = foreignInfo.references.map(column => this.client.customWrapIdentifier(column, identity));\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        statementsProducer(pragma, connection) {\n          return compiler.client.ddl(compiler, pragma, connection).foreign(foreignInfo);\n        }\n      });\n    }\n  }\n  primaryKeys() {\n    const pks = filter(this.grouped.alterTable || [], {\n      method: 'primary'\n    });\n    if (pks.length > 0 && pks[0].args.length > 0) {\n      const columns = pks[0].args[0];\n      let constraintName = pks[0].args[1] || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      const needUniqueCols = this.grouped.columns.filter(t => t.builder._type === 'increments').length > 0;\n      // SQLite dont support autoincrement columns and composite primary keys (autoincrement is always primary key).\n      // You need to add unique index instead when you have autoincrement columns (https://stackoverflow.com/a/6154876/1535159)\n      return `,${constraintName} ${needUniqueCols ? 'unique' : 'primary key'} (${this.formatter.columnize(columns)})`;\n    }\n  }\n  foreignKeys() {\n    let sql = '';\n    const foreignKeys = filter(this.grouped.alterTable || [], {\n      method: 'foreign'\n    });\n    for (let i = 0, l = foreignKeys.length; i < l; i++) {\n      const foreign = foreignKeys[i].args[0];\n      const column = this.formatter.columnize(foreign.column);\n      const references = this.formatter.columnize(foreign.references);\n      const foreignTable = this.formatter.wrap(foreign.inTable);\n      let constraintName = foreign.keyName || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;\n      if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;\n      if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;\n    }\n    return sql;\n  }\n  createTableBlock() {\n    return this.getColumns().concat().join(',');\n  }\n  renameColumn(from, to) {\n    this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(from)} to ${this.formatter.wrap(to)}`\n    });\n  }\n  _setNullableState(column, isNullable) {\n    const compiler = this;\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      statementsProducer(pragma, connection) {\n        return compiler.client.ddl(compiler, pragma, connection).setNullable(column, isNullable);\n      }\n    });\n  }\n  dropColumn() {\n    const compiler = this;\n    const columns = values(arguments);\n    const columnsWrapped = columns.map(column => this.client.customWrapIdentifier(column, identity));\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(columnsWrapped);\n      }\n    });\n  }\n}\nmodule.exports = TableCompiler_SQLite3;","map":{"version":3,"names":["filter","require","values","identity","isObject","TableCompiler","formatDefault","TableCompiler_SQLite3","constructor","arguments","createQuery","columns","ifNot","like","createStatement","sql","tableName","tableNameLike","join","foreignKeys","primaryKeys","_addChecks","pushQuery","addColumns","addColumnsPrefix","prefix","colCompilers","alterColumnsPrefix","compiler","columnsInfo","map","col","name","client","customWrapIdentifier","getColumnName","columnBuilder","queryContext","type","getColumnType","defaultTo","modified","notNull","statementsProducer","pragma","connection","ddl","alterColumn","i","l","length","bindings","dropUnique","indexName","formatter","wrap","_indexCommand","tableNameRaw","dropForeign","Array","isArray","column","output","dropPrimary","constraintName","dropIndex","unique","deferrable","predicate","logger","warn","columnize","predicateQuery","queryCompiler","where","index","options","primary","method","foreign","foreignInfo","inTable","references","pks","grouped","alterTable","args","needUniqueCols","t","builder","_type","foreignTable","keyName","onDelete","onUpdate","createTableBlock","getColumns","concat","renameColumn","from","to","_setNullableState","isNullable","setNullable","dropColumn","columnsWrapped","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js"],"sourcesContent":["const filter = require('lodash/filter');\nconst values = require('lodash/values');\nconst identity = require('lodash/identity');\nconst { isObject } = require('../../../util/is');\n\nconst TableCompiler = require('../../../schema/tablecompiler');\nconst { formatDefault } = require('../../../formatter/formatterUtils');\n\nclass TableCompiler_SQLite3 extends TableCompiler {\n  constructor() {\n    super(...arguments);\n  }\n\n  // Create a new table.\n  createQuery(columns, ifNot, like) {\n    const createStatement = ifNot\n      ? 'create table if not exists '\n      : 'create table ';\n\n    let sql = createStatement + this.tableName();\n\n    if (like && this.tableNameLike()) {\n      sql += ' as select * from ' + this.tableNameLike() + ' where 0=1';\n    } else {\n      // so we will need to check for a primary key commands and add the columns\n      // to the table's declaration here so they can be created on the tables.\n      sql += ' (' + columns.sql.join(', ');\n      sql += this.foreignKeys() || '';\n      sql += this.primaryKeys() || '';\n      sql += this._addChecks();\n      sql += ')';\n    }\n    this.pushQuery(sql);\n\n    if (like) {\n      this.addColumns(columns, this.addColumnsPrefix);\n    }\n  }\n\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      const compiler = this;\n\n      const columnsInfo = colCompilers.map((col) => {\n        const name = this.client.customWrapIdentifier(\n          col.getColumnName(),\n          identity,\n          col.columnBuilder.queryContext()\n        );\n\n        const type = col.getColumnType();\n\n        const defaultTo = col.modified['defaultTo']\n          ? formatDefault(col.modified['defaultTo'][0], col.type, this.client)\n          : null;\n\n        const notNull =\n          col.modified['nullable'] && col.modified['nullable'][0] === false;\n\n        return { name, type, defaultTo, notNull };\n      });\n\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        statementsProducer(pragma, connection) {\n          return compiler.client\n            .ddl(compiler, pragma, connection)\n            .alterColumn(columnsInfo);\n        },\n      });\n    } else {\n      for (let i = 0, l = columns.sql.length; i < l; i++) {\n        this.pushQuery({\n          sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,\n          bindings: columns.bindings[i],\n        });\n      }\n    }\n  }\n\n  // Compile a drop unique key command.\n  dropUnique(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a drop foreign key command.\n  dropForeign(columns, indexName) {\n    const compiler = this;\n\n    columns = Array.isArray(columns) ? columns : [columns];\n    columns = columns.map((column) =>\n      this.client.customWrapIdentifier(column, identity)\n    );\n    indexName = this.client.customWrapIdentifier(indexName, identity);\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropForeign(columns, indexName);\n      },\n    });\n  }\n\n  // Compile a drop primary key command.\n  dropPrimary(constraintName) {\n    const compiler = this;\n\n    constraintName = this.client.customWrapIdentifier(constraintName, identity);\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropPrimary(constraintName);\n      },\n    });\n  }\n\n  dropIndex(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a unique key command.\n  unique(columns, indexName) {\n    let deferrable;\n    let predicate;\n    if (isObject(indexName)) {\n      ({ indexName, deferrable, predicate } = indexName);\n    }\n    if (deferrable && deferrable !== 'not deferrable') {\n      this.client.logger.warn(\n        `sqlite3: unique index \\`${indexName}\\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`\n      );\n    }\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n\n    const predicateQuery = predicate\n      ? ' ' + this.client.queryCompiler(predicate).where()\n      : '';\n\n    this.pushQuery(\n      `create unique index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`\n    );\n  }\n\n  // Compile a plain index key command.\n  index(columns, indexName, options) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n\n    let predicate;\n    if (isObject(options)) {\n      ({ predicate } = options);\n    }\n    const predicateQuery = predicate\n      ? ' ' + this.client.queryCompiler(predicate).where()\n      : '';\n    this.pushQuery(\n      `create index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`\n    );\n  }\n\n  /**\n   * Add a primary key to an existing table.\n   *\n   * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table\n   *       creation in this method\n   *\n   * @param {string | string[]} columns - Column name(s) to assign as primary keys\n   * @param {string} [constraintName] - Custom name for the PK constraint\n   */\n  primary(columns, constraintName) {\n    const compiler = this;\n\n    columns = Array.isArray(columns) ? columns : [columns];\n    columns = columns.map((column) =>\n      this.client.customWrapIdentifier(column, identity)\n    );\n\n    let deferrable;\n    if (isObject(constraintName)) {\n      ({ constraintName, deferrable } = constraintName);\n    }\n    if (deferrable && deferrable !== 'not deferrable') {\n      this.client.logger.warn(\n        `sqlite3: primary key constraint \\`${constraintName}\\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`\n      );\n    }\n    constraintName = this.client.customWrapIdentifier(constraintName, identity);\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        output(pragma) {\n          return compiler.client\n            .ddl(compiler, pragma, this.connection)\n            .primary(columns, constraintName);\n        },\n      });\n    }\n  }\n\n  /**\n   * Add a foreign key constraint to an existing table\n   *\n   * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do\n   *       anything regarding table creation in this method\n   *\n   * @param {object} foreignInfo - Information about the current column foreign setup\n   * @param {string | string[]} [foreignInfo.column] - Column in the current constraint\n   * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint\n   * @param {string | string[]} foreignInfo.references - What column it references in the other table\n   * @param {string} foreignInfo.inTable - What table is referenced in this constraint\n   * @param {string} [foreignInfo.onUpdate] - What to do on updates\n   * @param {string} [foreignInfo.onDelete] - What to do on deletions\n   */\n  foreign(foreignInfo) {\n    const compiler = this;\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      foreignInfo.column = Array.isArray(foreignInfo.column)\n        ? foreignInfo.column\n        : [foreignInfo.column];\n      foreignInfo.column = foreignInfo.column.map((column) =>\n        this.client.customWrapIdentifier(column, identity)\n      );\n      foreignInfo.inTable = this.client.customWrapIdentifier(\n        foreignInfo.inTable,\n        identity\n      );\n      foreignInfo.references = Array.isArray(foreignInfo.references)\n        ? foreignInfo.references\n        : [foreignInfo.references];\n      foreignInfo.references = foreignInfo.references.map((column) =>\n        this.client.customWrapIdentifier(column, identity)\n      );\n\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        statementsProducer(pragma, connection) {\n          return compiler.client\n            .ddl(compiler, pragma, connection)\n            .foreign(foreignInfo);\n        },\n      });\n    }\n  }\n\n  primaryKeys() {\n    const pks = filter(this.grouped.alterTable || [], { method: 'primary' });\n    if (pks.length > 0 && pks[0].args.length > 0) {\n      const columns = pks[0].args[0];\n      let constraintName = pks[0].args[1] || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      const needUniqueCols =\n        this.grouped.columns.filter((t) => t.builder._type === 'increments')\n          .length > 0;\n      // SQLite dont support autoincrement columns and composite primary keys (autoincrement is always primary key).\n      // You need to add unique index instead when you have autoincrement columns (https://stackoverflow.com/a/6154876/1535159)\n      return `,${constraintName} ${\n        needUniqueCols ? 'unique' : 'primary key'\n      } (${this.formatter.columnize(columns)})`;\n    }\n  }\n\n  foreignKeys() {\n    let sql = '';\n    const foreignKeys = filter(this.grouped.alterTable || [], {\n      method: 'foreign',\n    });\n    for (let i = 0, l = foreignKeys.length; i < l; i++) {\n      const foreign = foreignKeys[i].args[0];\n      const column = this.formatter.columnize(foreign.column);\n      const references = this.formatter.columnize(foreign.references);\n      const foreignTable = this.formatter.wrap(foreign.inTable);\n      let constraintName = foreign.keyName || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;\n      if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;\n      if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;\n    }\n    return sql;\n  }\n\n  createTableBlock() {\n    return this.getColumns().concat().join(',');\n  }\n\n  renameColumn(from, to) {\n    this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(\n        from\n      )} to ${this.formatter.wrap(to)}`,\n    });\n  }\n\n  _setNullableState(column, isNullable) {\n    const compiler = this;\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      statementsProducer(pragma, connection) {\n        return compiler.client\n          .ddl(compiler, pragma, connection)\n          .setNullable(column, isNullable);\n      },\n    });\n  }\n\n  dropColumn() {\n    const compiler = this;\n    const columns = values(arguments);\n\n    const columnsWrapped = columns.map((column) =>\n      this.client.customWrapIdentifier(column, identity)\n    );\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropColumn(columnsWrapped);\n      },\n    });\n  }\n}\n\nmodule.exports = TableCompiler_SQLite3;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}