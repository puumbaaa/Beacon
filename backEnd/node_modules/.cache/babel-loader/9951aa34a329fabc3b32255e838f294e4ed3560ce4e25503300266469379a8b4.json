{"ast":null,"code":"// SQLite3_DDL\n//\n// All of the SQLite3 specific DDL helpers for renaming/dropping\n// columns and changing datatypes.\n// -------\n\nconst identity = require('lodash/identity');\nconst {\n  nanonum\n} = require('../../../util/nanoid');\nconst {\n  copyData,\n  dropOriginal,\n  renameTable,\n  getTableSql,\n  isForeignCheckEnabled,\n  setForeignCheck,\n  executeForeignCheck\n} = require('./internal/sqlite-ddl-operations');\nconst {\n  parseCreateTable,\n  parseCreateIndex\n} = require('./internal/parser');\nconst {\n  compileCreateTable,\n  compileCreateIndex\n} = require('./internal/compiler');\nconst {\n  isEqualId,\n  includesId\n} = require('./internal/utils');\n\n// So altering the schema in SQLite3 is a major pain.\n// We have our own object to deal with the renaming and altering the types\n// for sqlite3 things.\nclass SQLite3_DDL {\n  constructor(client, tableCompiler, pragma, connection) {\n    this.client = client;\n    this.tableCompiler = tableCompiler;\n    this.pragma = pragma;\n    this.tableNameRaw = this.tableCompiler.tableNameRaw;\n    this.alteredName = `_knex_temp_alter${nanonum(3)}`;\n    this.connection = connection;\n    this.formatter = value => this.client.customWrapIdentifier(value, identity);\n    this.wrap = value => this.client.wrapIdentifierImpl(value);\n  }\n  tableName() {\n    return this.formatter(this.tableNameRaw);\n  }\n  getTableSql() {\n    const tableName = this.tableName();\n    return this.client.transaction(async trx => {\n      trx.disableProcessing();\n      const result = await trx.raw(getTableSql(tableName));\n      trx.enableProcessing();\n      return {\n        createTable: result.filter(create => create.type === 'table')[0].sql,\n        createIndices: result.filter(create => create.type === 'index').map(create => create.sql)\n      };\n    }, {\n      connection: this.connection\n    });\n  }\n  async isForeignCheckEnabled() {\n    const result = await this.client.raw(isForeignCheckEnabled()).connection(this.connection);\n    return result[0].foreign_keys === 1;\n  }\n  async setForeignCheck(enable) {\n    await this.client.raw(setForeignCheck(enable)).connection(this.connection);\n  }\n  renameTable(trx) {\n    return trx.raw(renameTable(this.alteredName, this.tableName()));\n  }\n  dropOriginal(trx) {\n    return trx.raw(dropOriginal(this.tableName()));\n  }\n  copyData(trx, columns) {\n    return trx.raw(copyData(this.tableName(), this.alteredName, columns));\n  }\n  async alterColumn(columns) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    parsedTable.columns = parsedTable.columns.map(column => {\n      const newColumnInfo = columns.find(c => isEqualId(c.name, column.name));\n      if (newColumnInfo) {\n        column.type = newColumnInfo.type;\n        column.constraints.default = newColumnInfo.defaultTo !== null ? {\n          name: null,\n          value: newColumnInfo.defaultTo,\n          expression: false\n        } : null;\n        column.constraints.notnull = newColumnInfo.notNull ? {\n          name: null,\n          conflict: null\n        } : null;\n        column.constraints.null = newColumnInfo.notNull ? null : column.constraints.null;\n      }\n      return column;\n    });\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n  async dropColumn(columns) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    parsedTable.columns = parsedTable.columns.filter(parsedColumn => parsedColumn.expression || !includesId(columns, parsedColumn.name));\n    if (parsedTable.columns.length === 0) {\n      throw new Error('Unable to drop last column from table');\n    }\n    parsedTable.constraints = parsedTable.constraints.filter(constraint => {\n      if (constraint.type === 'PRIMARY KEY' || constraint.type === 'UNIQUE') {\n        return constraint.columns.every(constraintColumn => constraintColumn.expression || !includesId(columns, constraintColumn.name));\n      } else if (constraint.type === 'FOREIGN KEY') {\n        return constraint.columns.every(constraintColumnName => !includesId(columns, constraintColumnName)) && (constraint.references.table !== parsedTable.table || constraint.references.columns.every(referenceColumnName => !includesId(columns, referenceColumnName)));\n      } else {\n        return true;\n      }\n    });\n    const newColumns = parsedTable.columns.map(column => column.name);\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    const newIndices = [];\n    for (const createIndex of createIndices) {\n      const parsedIndex = parseCreateIndex(createIndex);\n      parsedIndex.columns = parsedIndex.columns.filter(parsedColumn => parsedColumn.expression || !includesId(columns, parsedColumn.name));\n      if (parsedIndex.columns.length > 0) {\n        newIndices.push(compileCreateIndex(parsedIndex, this.wrap));\n      }\n    }\n    return this.alter(newTable, newIndices, newColumns);\n  }\n  async dropForeign(columns, foreignKeyName) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    if (!foreignKeyName) {\n      parsedTable.columns = parsedTable.columns.map(column => ({\n        ...column,\n        references: includesId(columns, column.name) ? null : column.references\n      }));\n    }\n    parsedTable.constraints = parsedTable.constraints.filter(constraint => {\n      if (constraint.type === 'FOREIGN KEY') {\n        if (foreignKeyName) {\n          return !constraint.name || !isEqualId(constraint.name, foreignKeyName);\n        }\n        return constraint.columns.every(constraintColumnName => !includesId(columns, constraintColumnName));\n      } else {\n        return true;\n      }\n    });\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.alter(newTable, createIndices);\n  }\n  async dropPrimary(constraintName) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    parsedTable.columns = parsedTable.columns.map(column => ({\n      ...column,\n      primary: null\n    }));\n    parsedTable.constraints = parsedTable.constraints.filter(constraint => {\n      if (constraint.type === 'PRIMARY KEY') {\n        if (constraintName) {\n          return !constraint.name || !isEqualId(constraint.name, constraintName);\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    });\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.alter(newTable, createIndices);\n  }\n  async primary(columns, constraintName) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    parsedTable.columns = parsedTable.columns.map(column => ({\n      ...column,\n      primary: null\n    }));\n    parsedTable.constraints = parsedTable.constraints.filter(constraint => constraint.type !== 'PRIMARY KEY');\n    parsedTable.constraints.push({\n      type: 'PRIMARY KEY',\n      name: constraintName || null,\n      columns: columns.map(column => ({\n        name: column,\n        expression: false,\n        collation: null,\n        order: null\n      })),\n      conflict: null\n    });\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.alter(newTable, createIndices);\n  }\n  async foreign(foreignInfo) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    parsedTable.constraints.push({\n      type: 'FOREIGN KEY',\n      name: foreignInfo.keyName || null,\n      columns: foreignInfo.column,\n      references: {\n        table: foreignInfo.inTable,\n        columns: foreignInfo.references,\n        delete: foreignInfo.onDelete || null,\n        update: foreignInfo.onUpdate || null,\n        match: null,\n        deferrable: null\n      }\n    });\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n  async setNullable(column, isNullable) {\n    const {\n      createTable,\n      createIndices\n    } = await this.getTableSql();\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n    const parsedColumn = parsedTable.columns.find(c => isEqualId(column, c.name));\n    if (!parsedColumn) {\n      throw new Error(`.setNullable: Column ${column} does not exist in table ${this.tableName()}.`);\n    }\n    parsedColumn.constraints.notnull = isNullable ? null : {\n      name: null,\n      conflict: null\n    };\n    parsedColumn.constraints.null = isNullable ? parsedColumn.constraints.null : null;\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n  async alter(newSql, createIndices, columns) {\n    const wasForeignCheckEnabled = await this.isForeignCheckEnabled();\n    if (wasForeignCheckEnabled) {\n      await this.setForeignCheck(false);\n    }\n    try {\n      await this.client.transaction(async trx => {\n        await trx.raw(newSql);\n        await this.copyData(trx, columns);\n        await this.dropOriginal(trx);\n        await this.renameTable(trx);\n        for (const createIndex of createIndices) {\n          await trx.raw(createIndex);\n        }\n        if (wasForeignCheckEnabled) {\n          const foreignViolations = await trx.raw(executeForeignCheck());\n          if (foreignViolations.length > 0) {\n            throw new Error('FOREIGN KEY constraint failed');\n          }\n        }\n      }, {\n        connection: this.connection\n      });\n    } finally {\n      if (wasForeignCheckEnabled) {\n        await this.setForeignCheck(true);\n      }\n    }\n  }\n  async generateAlterCommands(newSql, createIndices, columns) {\n    const sql = [];\n    const pre = [];\n    const post = [];\n    let check = null;\n    sql.push(newSql);\n    sql.push(copyData(this.tableName(), this.alteredName, columns));\n    sql.push(dropOriginal(this.tableName()));\n    sql.push(renameTable(this.alteredName, this.tableName()));\n    for (const createIndex of createIndices) {\n      sql.push(createIndex);\n    }\n    const isForeignCheckEnabled = await this.isForeignCheckEnabled();\n    if (isForeignCheckEnabled) {\n      pre.push(setForeignCheck(false));\n      post.push(setForeignCheck(true));\n      check = executeForeignCheck();\n    }\n    return {\n      pre,\n      sql,\n      check,\n      post\n    };\n  }\n}\nmodule.exports = SQLite3_DDL;","map":{"version":3,"names":["identity","require","nanonum","copyData","dropOriginal","renameTable","getTableSql","isForeignCheckEnabled","setForeignCheck","executeForeignCheck","parseCreateTable","parseCreateIndex","compileCreateTable","compileCreateIndex","isEqualId","includesId","SQLite3_DDL","constructor","client","tableCompiler","pragma","connection","tableNameRaw","alteredName","formatter","value","customWrapIdentifier","wrap","wrapIdentifierImpl","tableName","transaction","trx","disableProcessing","result","raw","enableProcessing","createTable","filter","create","type","sql","createIndices","map","foreign_keys","enable","columns","alterColumn","parsedTable","table","column","newColumnInfo","find","c","name","constraints","default","defaultTo","expression","notnull","notNull","conflict","null","newTable","generateAlterCommands","dropColumn","parsedColumn","length","Error","constraint","every","constraintColumn","constraintColumnName","references","referenceColumnName","newColumns","newIndices","createIndex","parsedIndex","push","alter","dropForeign","foreignKeyName","dropPrimary","constraintName","primary","collation","order","foreign","foreignInfo","keyName","inTable","delete","onDelete","update","onUpdate","match","deferrable","setNullable","isNullable","newSql","wasForeignCheckEnabled","foreignViolations","pre","post","check","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/sqlite3/schema/ddl.js"],"sourcesContent":["// SQLite3_DDL\n//\n// All of the SQLite3 specific DDL helpers for renaming/dropping\n// columns and changing datatypes.\n// -------\n\nconst identity = require('lodash/identity');\nconst { nanonum } = require('../../../util/nanoid');\nconst {\n  copyData,\n  dropOriginal,\n  renameTable,\n  getTableSql,\n  isForeignCheckEnabled,\n  setForeignCheck,\n  executeForeignCheck,\n} = require('./internal/sqlite-ddl-operations');\nconst { parseCreateTable, parseCreateIndex } = require('./internal/parser');\nconst {\n  compileCreateTable,\n  compileCreateIndex,\n} = require('./internal/compiler');\nconst { isEqualId, includesId } = require('./internal/utils');\n\n// So altering the schema in SQLite3 is a major pain.\n// We have our own object to deal with the renaming and altering the types\n// for sqlite3 things.\nclass SQLite3_DDL {\n  constructor(client, tableCompiler, pragma, connection) {\n    this.client = client;\n    this.tableCompiler = tableCompiler;\n    this.pragma = pragma;\n    this.tableNameRaw = this.tableCompiler.tableNameRaw;\n    this.alteredName = `_knex_temp_alter${nanonum(3)}`;\n    this.connection = connection;\n    this.formatter = (value) =>\n      this.client.customWrapIdentifier(value, identity);\n    this.wrap = (value) => this.client.wrapIdentifierImpl(value);\n  }\n\n  tableName() {\n    return this.formatter(this.tableNameRaw);\n  }\n\n  getTableSql() {\n    const tableName = this.tableName();\n\n    return this.client.transaction(\n      async (trx) => {\n        trx.disableProcessing();\n        const result = await trx.raw(getTableSql(tableName));\n        trx.enableProcessing();\n\n        return {\n          createTable: result.filter((create) => create.type === 'table')[0]\n            .sql,\n          createIndices: result\n            .filter((create) => create.type === 'index')\n            .map((create) => create.sql),\n        };\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async isForeignCheckEnabled() {\n    const result = await this.client\n      .raw(isForeignCheckEnabled())\n      .connection(this.connection);\n\n    return result[0].foreign_keys === 1;\n  }\n\n  async setForeignCheck(enable) {\n    await this.client.raw(setForeignCheck(enable)).connection(this.connection);\n  }\n\n  renameTable(trx) {\n    return trx.raw(renameTable(this.alteredName, this.tableName()));\n  }\n\n  dropOriginal(trx) {\n    return trx.raw(dropOriginal(this.tableName()));\n  }\n\n  copyData(trx, columns) {\n    return trx.raw(copyData(this.tableName(), this.alteredName, columns));\n  }\n\n  async alterColumn(columns) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    parsedTable.columns = parsedTable.columns.map((column) => {\n      const newColumnInfo = columns.find((c) => isEqualId(c.name, column.name));\n\n      if (newColumnInfo) {\n        column.type = newColumnInfo.type;\n\n        column.constraints.default =\n          newColumnInfo.defaultTo !== null\n            ? {\n                name: null,\n                value: newColumnInfo.defaultTo,\n                expression: false,\n              }\n            : null;\n\n        column.constraints.notnull = newColumnInfo.notNull\n          ? { name: null, conflict: null }\n          : null;\n\n        column.constraints.null = newColumnInfo.notNull\n          ? null\n          : column.constraints.null;\n      }\n\n      return column;\n    });\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n\n  async dropColumn(columns) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    parsedTable.columns = parsedTable.columns.filter(\n      (parsedColumn) =>\n        parsedColumn.expression || !includesId(columns, parsedColumn.name)\n    );\n\n    if (parsedTable.columns.length === 0) {\n      throw new Error('Unable to drop last column from table');\n    }\n\n    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {\n      if (constraint.type === 'PRIMARY KEY' || constraint.type === 'UNIQUE') {\n        return constraint.columns.every(\n          (constraintColumn) =>\n            constraintColumn.expression ||\n            !includesId(columns, constraintColumn.name)\n        );\n      } else if (constraint.type === 'FOREIGN KEY') {\n        return (\n          constraint.columns.every(\n            (constraintColumnName) => !includesId(columns, constraintColumnName)\n          ) &&\n          (constraint.references.table !== parsedTable.table ||\n            constraint.references.columns.every(\n              (referenceColumnName) => !includesId(columns, referenceColumnName)\n            ))\n        );\n      } else {\n        return true;\n      }\n    });\n\n    const newColumns = parsedTable.columns.map((column) => column.name);\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    const newIndices = [];\n    for (const createIndex of createIndices) {\n      const parsedIndex = parseCreateIndex(createIndex);\n\n      parsedIndex.columns = parsedIndex.columns.filter(\n        (parsedColumn) =>\n          parsedColumn.expression || !includesId(columns, parsedColumn.name)\n      );\n\n      if (parsedIndex.columns.length > 0) {\n        newIndices.push(compileCreateIndex(parsedIndex, this.wrap));\n      }\n    }\n\n    return this.alter(newTable, newIndices, newColumns);\n  }\n\n  async dropForeign(columns, foreignKeyName) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    if (!foreignKeyName) {\n      parsedTable.columns = parsedTable.columns.map((column) => ({\n        ...column,\n        references: includesId(columns, column.name) ? null : column.references,\n      }));\n    }\n\n    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {\n      if (constraint.type === 'FOREIGN KEY') {\n        if (foreignKeyName) {\n          return (\n            !constraint.name || !isEqualId(constraint.name, foreignKeyName)\n          );\n        }\n\n        return constraint.columns.every(\n          (constraintColumnName) => !includesId(columns, constraintColumnName)\n        );\n      } else {\n        return true;\n      }\n    });\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.alter(newTable, createIndices);\n  }\n\n  async dropPrimary(constraintName) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    parsedTable.columns = parsedTable.columns.map((column) => ({\n      ...column,\n      primary: null,\n    }));\n\n    parsedTable.constraints = parsedTable.constraints.filter((constraint) => {\n      if (constraint.type === 'PRIMARY KEY') {\n        if (constraintName) {\n          return (\n            !constraint.name || !isEqualId(constraint.name, constraintName)\n          );\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    });\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.alter(newTable, createIndices);\n  }\n\n  async primary(columns, constraintName) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    parsedTable.columns = parsedTable.columns.map((column) => ({\n      ...column,\n      primary: null,\n    }));\n\n    parsedTable.constraints = parsedTable.constraints.filter(\n      (constraint) => constraint.type !== 'PRIMARY KEY'\n    );\n\n    parsedTable.constraints.push({\n      type: 'PRIMARY KEY',\n      name: constraintName || null,\n      columns: columns.map((column) => ({\n        name: column,\n        expression: false,\n        collation: null,\n        order: null,\n      })),\n      conflict: null,\n    });\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.alter(newTable, createIndices);\n  }\n\n  async foreign(foreignInfo) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    parsedTable.constraints.push({\n      type: 'FOREIGN KEY',\n      name: foreignInfo.keyName || null,\n      columns: foreignInfo.column,\n      references: {\n        table: foreignInfo.inTable,\n        columns: foreignInfo.references,\n        delete: foreignInfo.onDelete || null,\n        update: foreignInfo.onUpdate || null,\n        match: null,\n        deferrable: null,\n      },\n    });\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n\n  async setNullable(column, isNullable) {\n    const { createTable, createIndices } = await this.getTableSql();\n\n    const parsedTable = parseCreateTable(createTable);\n    parsedTable.table = this.alteredName;\n\n    const parsedColumn = parsedTable.columns.find((c) =>\n      isEqualId(column, c.name)\n    );\n\n    if (!parsedColumn) {\n      throw new Error(\n        `.setNullable: Column ${column} does not exist in table ${this.tableName()}.`\n      );\n    }\n\n    parsedColumn.constraints.notnull = isNullable\n      ? null\n      : { name: null, conflict: null };\n\n    parsedColumn.constraints.null = isNullable\n      ? parsedColumn.constraints.null\n      : null;\n\n    const newTable = compileCreateTable(parsedTable, this.wrap);\n\n    return this.generateAlterCommands(newTable, createIndices);\n  }\n\n  async alter(newSql, createIndices, columns) {\n    const wasForeignCheckEnabled = await this.isForeignCheckEnabled();\n\n    if (wasForeignCheckEnabled) {\n      await this.setForeignCheck(false);\n    }\n\n    try {\n      await this.client.transaction(\n        async (trx) => {\n          await trx.raw(newSql);\n          await this.copyData(trx, columns);\n          await this.dropOriginal(trx);\n          await this.renameTable(trx);\n\n          for (const createIndex of createIndices) {\n            await trx.raw(createIndex);\n          }\n\n          if (wasForeignCheckEnabled) {\n            const foreignViolations = await trx.raw(executeForeignCheck());\n\n            if (foreignViolations.length > 0) {\n              throw new Error('FOREIGN KEY constraint failed');\n            }\n          }\n        },\n        { connection: this.connection }\n      );\n    } finally {\n      if (wasForeignCheckEnabled) {\n        await this.setForeignCheck(true);\n      }\n    }\n  }\n\n  async generateAlterCommands(newSql, createIndices, columns) {\n    const sql = [];\n    const pre = [];\n    const post = [];\n    let check = null;\n\n    sql.push(newSql);\n    sql.push(copyData(this.tableName(), this.alteredName, columns));\n    sql.push(dropOriginal(this.tableName()));\n    sql.push(renameTable(this.alteredName, this.tableName()));\n\n    for (const createIndex of createIndices) {\n      sql.push(createIndex);\n    }\n\n    const isForeignCheckEnabled = await this.isForeignCheckEnabled();\n\n    if (isForeignCheckEnabled) {\n      pre.push(setForeignCheck(false));\n      post.push(setForeignCheck(true));\n\n      check = executeForeignCheck();\n    }\n\n    return { pre, sql, check, post };\n  }\n}\n\nmodule.exports = SQLite3_DDL;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}