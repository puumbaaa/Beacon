{"ast":null,"code":"const {\n  KnexTimeoutError\n} = require('../util/timeout');\nconst {\n  timeout\n} = require('../util/timeout');\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback\n} = require('./internal/ensure-connection-callback');\nlet Transform;\n\n// The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = [];\n\n    // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n    this.connection = undefined;\n  }\n\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  async run() {\n    const runner = this;\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback);\n\n      // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n      runner.builder.emit('end');\n      return res;\n\n      // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n      throw err;\n    }\n  }\n\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler = typeof optionsOrHandler === 'function' && arguments.length === 1;\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;\n\n    // Determines whether we emit an error or throw here.\n    const hasHandler = typeof handler === 'function';\n\n    // Lazy-load the \"Transform\" dependency.\n    Transform = Transform || require('stream').Transform;\n    const queryContext = this.builder.queryContext();\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      }\n    });\n    stream.on('close', () => {\n      this.client.releaseConnection(this.connection);\n    });\n\n    // If the stream is manually destroyed, the close event is not\n    // propagated to the top of the pipe chain. We need to manually verify\n    // that the source stream is closed and if not, manually destroy it.\n    stream.on('pipe', sourceStream => {\n      const cleanSourceStream = () => {\n        if (!sourceStream.closed) {\n          sourceStream.destroy();\n        }\n      };\n\n      // Stream already closed, cleanup immediately\n      if (stream.closed) {\n        cleanSourceStream();\n      } else {\n        stream.on('close', cleanSourceStream);\n      }\n    });\n    const connectionAcquirePromise = this.ensureConnection(ensureConnectionStreamCallback, {\n      options,\n      hasHandler,\n      stream\n    })\n    // Emit errors on the stream if the error occurred before a connection\n    // could be acquired.\n    // If the connection was acquired, assume the error occurred in the client\n    // code and has already been emitted on the stream. Don't emit it twice.\n    .catch(err => {\n      if (!this.connection) {\n        stream.emit('error', err);\n      }\n    });\n\n    // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n    return stream;\n  }\n\n  // Allow you to pipe the stream to a writable stream.\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  }\n\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  async query(obj) {\n    const {\n      __knexUid,\n      __knexTxId\n    } = this.connection;\n    this.builder.emit('query', Object.assign({\n      __knexUid,\n      __knexTxId\n    }, obj));\n    const runner = this;\n    const queryContext = this.builder.queryContext();\n    // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n    let queryPromise = this.client.query(this.connection, obj);\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    }\n\n    // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n    return queryPromise.then(resp => this.client.processResponse(resp, runner)).then(processedResponse => {\n      const postProcessedResponse = this.client.postProcessResponse(processedResponse, queryContext);\n      this.builder.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      this.client.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      return postProcessedResponse;\n    }).catch(error => {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      const {\n        timeout,\n        sql,\n        bindings\n      } = obj;\n      let cancelQuery;\n      if (obj.cancelOnTimeout) {\n        cancelQuery = this.client.cancelQuery(this.connection);\n      } else {\n        // If we don't cancel the query, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error;\n        cancelQuery = Promise.resolve();\n      }\n      return cancelQuery.catch(cancelError => {\n        // If the cancellation failed, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error;\n\n        // cancellation failed\n        throw Object.assign(cancelError, {\n          message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n          sql,\n          bindings,\n          timeout\n        });\n      }).then(() => {\n        // cancellation succeeded, rethrow timeout error\n        throw Object.assign(error, {\n          message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n          sql,\n          bindings,\n          timeout\n        });\n      });\n    }).catch(error => {\n      this.builder.emit('query-error', error, Object.assign({\n        __knexUid,\n        __knexTxId,\n        queryContext\n      }, obj));\n      throw error;\n    });\n  }\n\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n      const statements = await query.statementsProducer(undefined, this.connection);\n      const sqlQueryObjects = statements.sql.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      const preQueryObjects = statements.pre.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      const postQueryObjects = statements.post.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      let results = [];\n      await this.queryArray(preQueryObjects);\n      try {\n        await this.client.transaction(async trx => {\n          const transactionRunner = new Runner(trx.client, this.builder);\n          transactionRunner.connection = this.connection;\n          results = await transactionRunner.queryArray(sqlQueryObjects);\n          if (statements.check) {\n            const foreignViolations = await trx.raw(statements.check);\n            if (foreignViolations.length > 0) {\n              throw new Error('FOREIGN KEY constraint failed');\n            }\n          }\n        }, {\n          connection: this.connection\n        });\n      } finally {\n        await this.queryArray(postQueryObjects);\n      }\n      return results;\n    }\n    const results = [];\n    for (const query of queries) {\n      results.push(await this.queryArray([query]));\n    }\n    return results;\n  }\n\n  // Check whether there's a transaction flag, and that it has a connection.\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n    let acquiredConnection;\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n      throw error;\n    }\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n}\nmodule.exports = Runner;","map":{"version":3,"names":["KnexTimeoutError","require","timeout","ensureConnectionCallback","ensureConnectionStreamCallback","Transform","Runner","constructor","client","builder","queries","connection","undefined","run","runner","res","ensureConnection","emit","err","_events","error","stream","optionsOrHandler","handlerOrNil","firstOptionIsHandler","arguments","length","options","handler","hasHandler","queryContext","objectMode","transform","chunk","_","callback","postProcessResponse","on","releaseConnection","sourceStream","cleanSourceStream","closed","destroy","connectionAcquirePromise","catch","pipe","writable","query","obj","__knexUid","__knexTxId","Object","assign","queryPromise","then","resp","processResponse","processedResponse","postProcessedResponse","Promise","reject","sql","bindings","cancelQuery","cancelOnTimeout","__knex__disposed","resolve","cancelError","message","queryArray","statementsProducer","statements","sqlQueryObjects","map","statement","preQueryObjects","pre","postQueryObjects","post","results","transaction","trx","transactionRunner","check","foreignViolations","raw","Error","push","cb","cbParams","_connection","acquiredConnection","acquireConnection","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/execution/runner.js"],"sourcesContent":["const { KnexTimeoutError } = require('../util/timeout');\nconst { timeout } = require('../util/timeout');\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback,\n} = require('./internal/ensure-connection-callback');\n\nlet Transform;\n\n// The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = [];\n\n    // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n    this.connection = undefined;\n  }\n\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  async run() {\n    const runner = this;\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback);\n\n      // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n      runner.builder.emit('end');\n      return res;\n\n      // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n      throw err;\n    }\n  }\n\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler =\n      typeof optionsOrHandler === 'function' && arguments.length === 1;\n\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;\n\n    // Determines whether we emit an error or throw here.\n    const hasHandler = typeof handler === 'function';\n\n    // Lazy-load the \"Transform\" dependency.\n    Transform = Transform || require('stream').Transform;\n\n    const queryContext = this.builder.queryContext();\n\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      },\n    });\n    stream.on('close', () => {\n      this.client.releaseConnection(this.connection);\n    });\n\n    // If the stream is manually destroyed, the close event is not\n    // propagated to the top of the pipe chain. We need to manually verify\n    // that the source stream is closed and if not, manually destroy it.\n    stream.on('pipe', (sourceStream) => {\n      const cleanSourceStream = () => {\n        if (!sourceStream.closed) {\n          sourceStream.destroy();\n        }\n      };\n\n      // Stream already closed, cleanup immediately\n      if (stream.closed) {\n        cleanSourceStream();\n      } else {\n        stream.on('close', cleanSourceStream);\n      }\n    });\n\n    const connectionAcquirePromise = this.ensureConnection(\n      ensureConnectionStreamCallback,\n      {\n        options,\n        hasHandler,\n        stream,\n      }\n    )\n      // Emit errors on the stream if the error occurred before a connection\n      // could be acquired.\n      // If the connection was acquired, assume the error occurred in the client\n      // code and has already been emitted on the stream. Don't emit it twice.\n      .catch((err) => {\n        if (!this.connection) {\n          stream.emit('error', err);\n        }\n      });\n\n    // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n    return stream;\n  }\n\n  // Allow you to pipe the stream to a writable stream.\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  }\n\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  async query(obj) {\n    const { __knexUid, __knexTxId } = this.connection;\n\n    this.builder.emit('query', Object.assign({ __knexUid, __knexTxId }, obj));\n\n    const runner = this;\n    const queryContext = this.builder.queryContext();\n    // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n    let queryPromise = this.client.query(this.connection, obj);\n\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    }\n\n    // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n    return queryPromise\n      .then((resp) => this.client.processResponse(resp, runner))\n      .then((processedResponse) => {\n        const postProcessedResponse = this.client.postProcessResponse(\n          processedResponse,\n          queryContext\n        );\n\n        this.builder.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        this.client.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        return postProcessedResponse;\n      })\n      .catch((error) => {\n        if (!(error instanceof KnexTimeoutError)) {\n          return Promise.reject(error);\n        }\n        const { timeout, sql, bindings } = obj;\n\n        let cancelQuery;\n        if (obj.cancelOnTimeout) {\n          cancelQuery = this.client.cancelQuery(this.connection);\n        } else {\n          // If we don't cancel the query, we need to mark the connection as disposed so that\n          // it gets destroyed by the pool and is never used again. If we don't do this and\n          // return the connection to the pool, it will be useless until the current operation\n          // that timed out, finally finishes.\n          this.connection.__knex__disposed = error;\n          cancelQuery = Promise.resolve();\n        }\n\n        return cancelQuery\n          .catch((cancelError) => {\n            // If the cancellation failed, we need to mark the connection as disposed so that\n            // it gets destroyed by the pool and is never used again. If we don't do this and\n            // return the connection to the pool, it will be useless until the current operation\n            // that timed out, finally finishes.\n            this.connection.__knex__disposed = error;\n\n            // cancellation failed\n            throw Object.assign(cancelError, {\n              message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          })\n          .then(() => {\n            // cancellation succeeded, rethrow timeout error\n            throw Object.assign(error, {\n              message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          });\n      })\n      .catch((error) => {\n        this.builder.emit(\n          'query-error',\n          error,\n          Object.assign({ __knexUid, __knexTxId, queryContext }, obj)\n        );\n        throw error;\n      });\n  }\n\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n\n      const statements = await query.statementsProducer(\n        undefined,\n        this.connection\n      );\n\n      const sqlQueryObjects = statements.sql.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n      const preQueryObjects = statements.pre.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n      const postQueryObjects = statements.post.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n\n      let results = [];\n\n      await this.queryArray(preQueryObjects);\n\n      try {\n        await this.client.transaction(\n          async (trx) => {\n            const transactionRunner = new Runner(trx.client, this.builder);\n            transactionRunner.connection = this.connection;\n\n            results = await transactionRunner.queryArray(sqlQueryObjects);\n\n            if (statements.check) {\n              const foreignViolations = await trx.raw(statements.check);\n\n              if (foreignViolations.length > 0) {\n                throw new Error('FOREIGN KEY constraint failed');\n              }\n            }\n          },\n          { connection: this.connection }\n        );\n      } finally {\n        await this.queryArray(postQueryObjects);\n      }\n\n      return results;\n    }\n\n    const results = [];\n    for (const query of queries) {\n      results.push(await this.queryArray([query]));\n    }\n    return results;\n  }\n\n  // Check whether there's a transaction flag, and that it has a connection.\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n\n    let acquiredConnection;\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n      throw error;\n    }\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n}\n\nmodule.exports = Runner;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}