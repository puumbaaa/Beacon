{"ast":null,"code":"// Transaction\n// -------\nconst {\n  EventEmitter\n} = require('events');\nconst Debug = require('debug');\nconst uniqueId = require('lodash/uniqueId');\nconst {\n  callbackify\n} = require('util');\nconst makeKnex = require('../knex-builder/make-knex');\nconst {\n  timeout,\n  KnexTimeoutError\n} = require('../util/timeout');\nconst finallyMixin = require('../util/finally-mixin');\nconst debug = Debug('knex:tx');\n\n// FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true\n  };\n}\n// These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\nconst validIsolationLevels = [\n// Doesn't really work in postgres, it treats it as read committed\n'read uncommitted', 'read committed', 'snapshot',\n// snapshot and repeatable read are basically the same, most \"repeatable\n// read\" implementations are actually \"snapshot\" also known as Multi Version\n// Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n// repeated reads for inserts as it uses a pessimistic locking system so\n// you should probably use 'snapshot' to stop read skew.\n'repeatable read',\n// mysql pretends to have serializable, but it is not\n'serializable'];\n\n// Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\nclass Transaction extends EventEmitter {\n  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n    const txid = this.txid = uniqueId('trx');\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n    this.readOnly = config.readOnly;\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n    debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level');\n\n    // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n    this._lastChild = Promise.resolve();\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();\n\n    // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n    const basePromise = _previousSibling.then(() => this._evaluateContainer(config, container));\n\n    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n    this._promise = basePromise.then(x => x);\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n  isCompleted() {\n    return this._completed || this.outerTx && this.outerTx.isCompleted() || false;\n  }\n  begin(conn) {\n    const trxMode = [this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : '', this.readOnly ? 'READ ONLY' : ''].join(' ').trim();\n    if (trxMode.length === 0) {\n      return this.query(conn, 'BEGIN;');\n    }\n    return this.query(conn, `SET TRANSACTION ${trxMode};`).then(() => this.query(conn, 'BEGIN;'));\n  }\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(`Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(validIsolationLevels)}`);\n    }\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n  rollbackTo(conn, error) {\n    return timeout(this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n  query(conn, sql, status, value) {\n    const q = this.trxClient.query(conn, sql).catch(err => {\n      status = 2;\n      value = err;\n      this._completed = true;\n      debug('%s error running transaction query', this.txid);\n    }).then(res => {\n      if (status === 1) {\n        this._resolver(value);\n      }\n      if (status === 2) {\n        if (value === undefined) {\n          if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n            this._resolver();\n            return;\n          }\n          value = new Error(`Transaction rejected with non-error: ${value}`);\n        }\n        this._rejecter(value);\n      }\n      return res;\n    });\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n    return q;\n  }\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, connection => {\n      const trxClient = this.trxClient = makeTxClient(this, this.client, connection);\n      const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n      init.then(() => {\n        return makeTransactor(this, connection, trxClient);\n      }).then(transactor => {\n        this.transactor = transactor;\n        if (this.outerTx) {\n          transactor.parentTransaction = this.outerTx.transactor;\n        }\n        transactor.executionPromise = executionPromise;\n\n        // If we've returned a \"thenable\" from the transaction container, assume\n        // the rollback and commit are chained to this object's success / failure.\n        // Directly thrown errors are treated as automatic rollbacks.\n        let result;\n        try {\n          result = container(transactor);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n        if (result && result.then && typeof result.then === 'function') {\n          result.then(val => {\n            return transactor.commit(val);\n          }).catch(err => {\n            return transactor.rollback(err);\n          });\n        }\n        return null;\n      }).catch(e => {\n        return this._rejecter(e);\n      });\n      return executionPromise;\n    });\n  }\n\n  // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection = configConnection || (await this.client.acquireConnection());\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n  catch(...args) {\n    return this._promise.catch(...args);\n  }\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n}\nfinallyMixin(Transaction.prototype);\n\n// The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n  transactor.context.withUserParams = () => {\n    throw new Error('Cannot set user params on a transaction - it can only inherit params from main knex instance');\n  };\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = {\n        doNotRejectOnRollback: true\n      };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n    return this._transaction(container, options, trx);\n  };\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n  if (trx.client.transacting) {\n    transactor.commit = value => trx.release(connection, value);\n    transactor.rollback = error => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = value => trx.commit(connection, value);\n    transactor.rollback = error => trx.rollback(connection, error);\n  }\n  transactor.isCompleted = () => trx.isCompleted();\n  return transactor;\n}\n\n// We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n  const _query = trxClient.query;\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  const _stream = trxClient.stream;\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n  return trxClient;\n}\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');\n}\nmodule.exports = Transaction;","map":{"version":3,"names":["EventEmitter","require","Debug","uniqueId","callbackify","makeKnex","timeout","KnexTimeoutError","finallyMixin","debug","DEFAULT_CONFIG","userParams","doNotRejectOnRollback","validIsolationLevels","Transaction","constructor","client","container","config","outerTx","txid","logger","trxClient","undefined","_completed","_debug","readOnly","isolationLevel","setIsolationLevel","_lastChild","Promise","resolve","_previousSibling","basePromise","then","_evaluateContainer","_promise","x","catch","isCompleted","begin","conn","trxMode","join","trim","length","query","savepoint","commit","value","release","includes","Error","JSON","stringify","rollback","error","err","reject","_rejecter","rollbackTo","sql","status","q","res","_resolver","test","enabled","arguments","acquireConnection","connection","makeTxClient","init","transacting","executionPromise","resolver","rejecter","makeTransactor","transactor","parentTransaction","result","val","e","cb","configConnection","__knexTxId","releaseConnection","onResolve","onReject","args","asCallback","prototype","trx","context","withUserParams","isTransaction","transaction","options","_transaction","Object","create","version","driver","connectionSettings","valueForUndefined","on","arg","emit","obj","response","builder","_query","completed","completedError","call","_stream","stream","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/execution/transaction.js"],"sourcesContent":["// Transaction\n// -------\nconst { EventEmitter } = require('events');\nconst Debug = require('debug');\nconst uniqueId = require('lodash/uniqueId');\nconst { callbackify } = require('util');\n\nconst makeKnex = require('../knex-builder/make-knex');\nconst { timeout, KnexTimeoutError } = require('../util/timeout');\nconst finallyMixin = require('../util/finally-mixin');\n\nconst debug = Debug('knex:tx');\n\n// FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true,\n  };\n}\n// These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\nconst validIsolationLevels = [\n  // Doesn't really work in postgres, it treats it as read committed\n  'read uncommitted',\n  'read committed',\n  'snapshot',\n  // snapshot and repeatable read are basically the same, most \"repeatable\n  // read\" implementations are actually \"snapshot\" also known as Multi Version\n  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n  // repeated reads for inserts as it uses a pessimistic locking system so\n  // you should probably use 'snapshot' to stop read skew.\n  'repeatable read',\n  // mysql pretends to have serializable, but it is not\n  'serializable',\n];\n\n// Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\nclass Transaction extends EventEmitter {\n  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n\n    const txid = (this.txid = uniqueId('trx'));\n\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n\n    this.readOnly = config.readOnly;\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n\n    debug(\n      '%s: Starting %s transaction',\n      txid,\n      outerTx ? 'nested' : 'top level'\n    );\n\n    // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n    this._lastChild = Promise.resolve();\n\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();\n\n    // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n    const basePromise = _previousSibling.then(() =>\n      this._evaluateContainer(config, container)\n    );\n\n    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n    this._promise = basePromise.then((x) => x);\n\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n\n  isCompleted() {\n    return (\n      this._completed || (this.outerTx && this.outerTx.isCompleted()) || false\n    );\n  }\n\n  begin(conn) {\n    const trxMode = [\n      this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : '',\n      this.readOnly ? 'READ ONLY' : '',\n    ]\n      .join(' ')\n      .trim();\n\n    if (trxMode.length === 0) {\n      return this.query(conn, 'BEGIN;');\n    }\n\n    return this.query(conn, `SET TRANSACTION ${trxMode};`).then(() =>\n      this.query(conn, 'BEGIN;')\n    );\n  }\n\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(\n        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(\n          validIsolationLevels\n        )}`\n      );\n    }\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(\n      (err) => {\n        if (!(err instanceof KnexTimeoutError)) {\n          return Promise.reject(err);\n        }\n        this._rejecter(error);\n      }\n    );\n  }\n\n  rollbackTo(conn, error) {\n    return timeout(\n      this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),\n      5000\n    ).catch((err) => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n\n  query(conn, sql, status, value) {\n    const q = this.trxClient\n      .query(conn, sql)\n      .catch((err) => {\n        status = 2;\n        value = err;\n        this._completed = true;\n        debug('%s error running transaction query', this.txid);\n      })\n      .then((res) => {\n        if (status === 1) {\n          this._resolver(value);\n        }\n        if (status === 2) {\n          if (value === undefined) {\n            if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n              this._resolver();\n              return;\n            }\n\n            value = new Error(`Transaction rejected with non-error: ${value}`);\n          }\n          this._rejecter(value);\n        }\n        return res;\n      });\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n    return q;\n  }\n\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, (connection) => {\n      const trxClient = (this.trxClient = makeTxClient(\n        this,\n        this.client,\n        connection\n      ));\n      const init = this.client.transacting\n        ? this.savepoint(connection)\n        : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n\n      init\n        .then(() => {\n          return makeTransactor(this, connection, trxClient);\n        })\n        .then((transactor) => {\n          this.transactor = transactor;\n          if (this.outerTx) {\n            transactor.parentTransaction = this.outerTx.transactor;\n          }\n          transactor.executionPromise = executionPromise;\n\n          // If we've returned a \"thenable\" from the transaction container, assume\n          // the rollback and commit are chained to this object's success / failure.\n          // Directly thrown errors are treated as automatic rollbacks.\n          let result;\n          try {\n            result = container(transactor);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          if (result && result.then && typeof result.then === 'function') {\n            result\n              .then((val) => {\n                return transactor.commit(val);\n              })\n              .catch((err) => {\n                return transactor.rollback(err);\n              });\n          }\n          return null;\n        })\n        .catch((e) => {\n          return this._rejecter(e);\n        });\n\n      return executionPromise;\n    });\n  }\n\n  // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection =\n      configConnection || (await this.client.acquireConnection());\n\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n\n  catch(...args) {\n    return this._promise.catch(...args);\n  }\n\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n}\nfinallyMixin(Transaction.prototype);\n\n// The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n\n  transactor.context.withUserParams = () => {\n    throw new Error(\n      'Cannot set user params on a transaction - it can only inherit params from main knex instance'\n    );\n  };\n\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = { doNotRejectOnRollback: true };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n\n    return this._transaction(container, options, trx);\n  };\n\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n\n  if (trx.client.transacting) {\n    transactor.commit = (value) => trx.release(connection, value);\n    transactor.rollback = (error) => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = (value) => trx.commit(connection, value);\n    transactor.rollback = (error) => trx.rollback(connection, error);\n  }\n\n  transactor.isCompleted = () => trx.isCompleted();\n\n  return transactor;\n}\n\n// We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n\n  const _query = trxClient.query;\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  const _stream = trxClient.stream;\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n\n  return trxClient;\n}\n\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error(\n    'Transaction query already complete, run with DEBUG=knex:tx for more info'\n  );\n}\n\nmodule.exports = Transaction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}