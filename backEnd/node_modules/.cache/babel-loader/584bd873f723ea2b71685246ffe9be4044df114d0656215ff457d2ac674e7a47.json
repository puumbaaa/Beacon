{"ast":null,"code":"// Builder\n// -------\nconst assert = require('assert');\nconst {\n  EventEmitter\n} = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\nconst {\n  addQueryContext,\n  normalizeArr\n} = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction\n} = require('../util/is');\nconst {\n  lockMode,\n  waitMode\n} = require('./constants');\nconst {\n  augmentWithBuilderInterface\n} = require('../builder-interface-augmenter');\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set(['with', 'select', 'columns', 'hintComments', 'where', 'union', 'join', 'group', 'order', 'having', 'limit', 'offset', 'counter', 'counters']);\nconst LOCK_MODES = new Set([lockMode.forShare, lockMode.forUpdate, lockMode.forNoKeyUpdate, lockMode.forKeyShare]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._comments = [];\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._comments = clone(this._comments);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n    return cloned;\n  }\n  timeout(ms, {\n    cancel\n  } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return typeof statement === 'function' || statement instanceof Builder || statement && statement.isRawInstance;\n  }\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList = Array.isArray(columnList) && columnList.length > 0 && columnList.every(it => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(`${method}() second argument must be a statement or non-empty column name list.`);\n    }\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(`${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`);\n  }\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'with');\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Adds a comment to the query\n  comment(txt) {\n    if (!isString(txt)) {\n      throw new Error('Comment must be a string');\n    }\n    const forbiddenChars = ['/*', '*/', '?'];\n    if (forbiddenChars.some(chars => txt.includes(chars))) {\n      throw new Error(`Cannot include ${forbiddenChars.join(', ')} in comment`);\n    }\n    this._comments.push({\n      comment: txt\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some(hint => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some(hint => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some(hint => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true\n    });\n    return this;\n  }\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first, ...args) {\n    let join;\n    const schema = table instanceof Builder || typeof table === 'function' ? undefined : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n  using(tables) {\n    throw new Error(\"'using' function is only available in PostgreSQL dialect with Delete statements.\");\n  }\n\n  // JOIN blocks:\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance) return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1) return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(column, value);\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    return this.where(column, ...args);\n  }\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column, ...args) {\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn('whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.');\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to whereBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the whereBetween clause');\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction, nulls = '') {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls']\n        });\n      } else if (isString(columnInfo) || isNumber(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw\n    });\n    return this;\n  }\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union(...args) {\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll(...args) {\n    return this._union('union all', args);\n  }\n  intersect(...args) {\n    return this._union('intersect', args);\n  }\n  except(...args) {\n    return this._union('except', args);\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHaving(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n  havingBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to havingBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the havingBetween clause');\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct(...columns) {\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n    return this._aggregate('count', columns, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement)) throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate(...tables) {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare(...tables) {\n    this._single.lock = lockMode.forKeyShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.skipLocked() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.noWait() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n  upsert(values, returning, options) {\n    throw new Error(`Upsert is not yet supported for dialect ${this.client.dialect}`);\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params\n    });\n    return this;\n  }\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (arguments.length === 2 && Array.isArray(arguments[0]) && isBoolean(arguments[1])) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const {\n      schema\n    } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n    assert(typeof second === 'function' || second.isRawInstance || Array.isArray(second) || typeof second === 'string' || typeof second === 'object', `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`);\n    if (third) {\n      assert(Array.isArray(third) || typeof third === 'string' || typeof third === 'object', 'The third argument to an analytic function must be either a string, an array of string or object or an object.');\n    }\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n    this._method = 'update';\n    this._single.counter = this._single.counter || {};\n    this._single.counter[column] = amount;\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, {\n        grouping\n      });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereNotJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(`Can't extend QueryBuilder with existing method ('${methodName}').`);\n  }\n  assign(Builder.prototype, {\n    [methodName]: fn\n  });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = {\n      updates\n    };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error('Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()');\n  }\n}\nmodule.exports = Builder;","map":{"version":3,"names":["assert","require","EventEmitter","assign","clone","each","isEmpty","isPlainObject","last","reject","tail","toArray","addQueryContext","normalizeArr","JoinClause","Analytic","saveAsyncStack","isBoolean","isNumber","isObject","isString","isFunction","lockMode","waitMode","augmentWithBuilderInterface","SELECT_COMMANDS","Set","CLEARABLE_STATEMENTS","LOCK_MODES","forShare","forUpdate","forNoKeyUpdate","forKeyShare","Builder","constructor","client","and","_single","_comments","_statements","_method","config","_debug","debug","_joinFlag","_boolFlag","_notFlag","_asColumnFlag","toString","toQuery","toSQL","method","tz","queryCompiler","cloned","_options","undefined","_queryContext","_connection","timeout","ms","cancel","_timeout","assertCanCancelQuery","_cancelOnTimeout","isValidStatementArg","statement","isRawInstance","_validateWithArgs","alias","statementOrColumnList","nothingOrStatement","query","columnList","Error","isNonEmptyNameList","Array","isArray","length","every","it","with","withWrapped","withMaterialized","withNotMaterialized","materialized","grouping","type","value","push","withRecursive","withRecursiveWrapped","recursive","columns","column","arguments","comment","txt","forbiddenChars","some","chars","includes","join","as","hintComment","hints","hint","withSchema","schemaName","schema","table","tableName","options","only","distinct","args","distinctOn","first","joinType","_joinType","call","raw","on","using","tables","innerJoin","leftJoin","leftOuterJoin","rightJoin","rightOuterJoin","outerJoin","fullOuterJoin","crossJoin","joinRaw","or","_bool","not","_not","where","operator","argsLength","whereWrapped","_objectWhere","whereRaw","whereNull","checkOperator","toLowerCase","trim","whereIn","whereBetween","bool","asColumn","whereColumn","orWhere","obj","key","andWhere","orWhereColumn","andWhereColumn","whereNot","logger","warn","whereNotColumn","orWhereNot","orWhereNotColumn","boolVal","notVal","sql","bindings","orWhereRaw","callback","whereExists","orWhereExists","whereNotExists","orWhereNotExists","values","orWhereIn","whereNotIn","orWhereNotIn","orWhereNull","whereNotNull","orWhereNotNull","whereNotBetween","orWhereBetween","orWhereNotBetween","_whereLike","whereLike","orWhereLike","whereILike","orWhereILike","groupBy","item","groupByRaw","apply","orderBy","direction","nulls","_orderByArray","columnDefs","i","columnInfo","orderByRaw","_union","clause","callbacks","wrap","l","slice","union","unionAll","intersect","except","having","havingRaw","havingWrapped","orHaving","andHaving","havingNull","orHavingNull","havingNotNull","orHavingNotNull","havingExists","orHavingExists","havingNotExists","orHavingNotExists","havingBetween","orHavingBetween","havingNotBetween","orHavingNotBetween","havingIn","orHavingIn","havingNotIn","orHavingNotIn","orHavingRaw","_setSkipBinding","attribute","skipBinding","offset","val","parseInt","isNaN","limit","count","_aggregate","min","max","sum","avg","countDistinct","splice","sumDistinct","avgDistinct","increment","amount","_counter","decrement","clearCounters","counter","select","connection","processPassedConnection","pluck","clearSelect","_clearGrouping","clearWhere","clearGroup","clearOrder","clearHaving","clear","has","startsWith","insert","returning","update","ret","JSON","stringify","keys","Object","onConflict","OnConflictBuilder","delete","truncate","lock","lockTables","skipLocked","_isSelectQuery","_hasLockMode","noWait","fromJS","fromRaw","from","modify","concat","upsert","dialect","_json","nameFunction","params","jsonExtract","path","singleValue","jsonSet","jsonInsert","jsonRemove","_isJsonObject","jsonValue","_whereJsonWrappedValue","whereJsonClause","jsonPath","whereJsonObject","orWhereJsonObject","whereNotJsonObject","orWhereNotJsonObject","whereJsonPath","orWhereJsonPath","whereJsonSupersetOf","whereJsonNotSupersetOf","orWhereJsonSupersetOf","orWhereJsonNotSupersetOf","whereJsonSubsetOf","whereJsonNotSubsetOf","orWhereJsonSubsetOf","orWhereJsonNotSubsetOf","whereJsonHasNone","whereJsonHasAll","_analytic","second","third","analytic","_analyticMethod","order","partitions","rank","denseRank","rowNumber","parseFloat","_analyticFlag","aggregateDistinct","prototype","andWhereNot","andWhereNotColumn","andWhereRaw","andWhereBetween","andWhereNotBetween","andWhereJsonObject","andWhereNotJsonObject","andWhereJsonPath","andWhereLike","andWhereILike","andHavingIn","andHavingNotIn","andHavingNull","andHavingNotNull","andHavingExists","andHavingNotExists","andHavingBetween","andHavingNotBetween","into","del","extend","methodName","fn","hasOwnProperty","builder","_columns","ignore","merge","updates","then","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/query/querybuilder.js"],"sourcesContent":["// Builder\n// -------\nconst assert = require('assert');\nconst { EventEmitter } = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\n\nconst { addQueryContext, normalizeArr } = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction,\n} = require('../util/is');\n\nconst { lockMode, waitMode } = require('./constants');\nconst {\n  augmentWithBuilderInterface,\n} = require('../builder-interface-augmenter');\n\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set([\n  'with',\n  'select',\n  'columns',\n  'hintComments',\n  'where',\n  'union',\n  'join',\n  'group',\n  'order',\n  'having',\n  'limit',\n  'offset',\n  'counter',\n  'counters',\n]);\nconst LOCK_MODES = new Set([\n  lockMode.forShare,\n  lockMode.forUpdate,\n  lockMode.forNoKeyUpdate,\n  lockMode.forKeyShare,\n]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._comments = [];\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._comments = clone(this._comments);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  }\n\n  timeout(ms, { cancel } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return (\n      typeof statement === 'function' ||\n      statement instanceof Builder ||\n      (statement && statement.isRawInstance)\n    );\n  }\n\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList =\n      Array.isArray(columnList) &&\n      columnList.length > 0 &&\n      columnList.every((it) => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(\n        `${method}() second argument must be a statement or non-empty column name list.`\n      );\n    }\n\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(\n      `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`\n    );\n  }\n\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'with'\n    );\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query,\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'withRecursive'\n    );\n    return this.withRecursiveWrapped(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement\n    );\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a comment to the query\n  comment(txt) {\n    if (!isString(txt)) {\n      throw new Error('Comment must be a string');\n    }\n    const forbiddenChars = ['/*', '*/', '?'];\n    if (forbiddenChars.some((chars) => txt.includes(chars))) {\n      throw new Error(`Cannot include ${forbiddenChars.join(', ')} in comment`);\n    }\n    this._comments.push({\n      comment: txt,\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some((hint) => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some((hint) => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints,\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true,\n    });\n    return this;\n  }\n\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true,\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first, ...args) {\n    let join;\n    const schema =\n      table instanceof Builder || typeof table === 'function'\n        ? undefined\n        : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n\n  using(tables) {\n    throw new Error(\n      \"'using' function is only available in PostgreSQL dialect with Delete statements.\"\n    );\n  }\n\n  // JOIN blocks:\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance)\n      return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1)\n      return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(\n          column,\n          value\n        );\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    return this.where(column, ...args);\n  }\n\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column, ...args) {\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn(\n          'whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.'\n        );\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to whereBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the whereBetween clause'\n    );\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction, nulls = '') {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls,\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls'],\n        });\n      } else if (isString(columnInfo) || isNumber(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo,\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union(...args) {\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll(...args) {\n    return this._union('union all', args);\n  }\n\n  intersect(...args) {\n    return this._union('intersect', args);\n  }\n\n  except(...args) {\n    return this._union('except', args);\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHaving(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n\n  havingBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to havingBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the havingBetween clause'\n    );\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct(...columns) {\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, { ...options, distinct: true });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, { ...options, distinct: true });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, { ...options, distinct: true });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column,\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement))\n      throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate(...tables) {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare(...tables) {\n    this._single.lock = lockMode.forKeyShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n\n  upsert(values, returning, options) {\n    throw new Error(\n      `Upsert is not yet supported for dialect ${this.client.dialect}`\n    );\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params,\n    });\n    return this;\n  }\n\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (\n      arguments.length === 2 &&\n      Array.isArray(arguments[0]) &&\n      isBoolean(arguments[1])\n    ) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue, // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias,\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const { schema } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n\n    assert(\n      typeof second === 'function' ||\n        second.isRawInstance ||\n        Array.isArray(second) ||\n        typeof second === 'string' ||\n        typeof second === 'object',\n      `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`\n    );\n\n    if (third) {\n      assert(\n        Array.isArray(third) ||\n          typeof third === 'string' ||\n          typeof third === 'object',\n        'The third argument to an analytic function must be either a string, an array of string or object or an object.'\n      );\n    }\n\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias,\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions,\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n\n    this._method = 'update';\n\n    this._single.counter = this._single.counter || {};\n\n    this._single.counter[column] = amount;\n\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as,\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, { grouping });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\n\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereNotJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\n\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(\n      `Can't extend QueryBuilder with existing method ('${methodName}').`\n    );\n  }\n\n  assign(Builder.prototype, { [methodName]: fn });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = { updates };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error(\n      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'\n    );\n  }\n}\n\nmodule.exports = Builder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}