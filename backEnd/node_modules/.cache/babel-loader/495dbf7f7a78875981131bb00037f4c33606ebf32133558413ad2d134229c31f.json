{"ast":null,"code":"const transform = require('lodash/transform');\nconst QueryBuilder = require('../query/querybuilder');\nconst {\n  compileCallback,\n  wrapAsIdentifier\n} = require('./formatterUtils');\n\n// Valid values for the `order by` clause generation.\nconst orderBys = ['asc', 'desc'];\n\n// Turn this into a lookup map\nconst operators = transform(['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'not like', 'between', 'not between', 'ilike', 'not ilike', 'exists', 'not exist', 'rlike', 'not rlike', 'regexp', 'not regexp', 'match', '&', '|', '^', '<<', '>>', '~', '~=', '~*', '!~', '!~*', '#', '&&', '@>', '<@', '||', '&<', '&>', '-|-', '@@', '!!', ['?', '\\\\?'], ['?|', '\\\\?|'], ['?&', '\\\\?&']], (result, key) => {\n  if (Array.isArray(key)) {\n    result[key[0]] = key[1];\n  } else {\n    result[key] = key;\n  }\n}, {});\n\n// Accepts a string or array of columns to wrap as appropriate. Column can be raw\nfunction columnize(target, builder, client, bindingHolder) {\n  const columns = Array.isArray(target) ? target : [target];\n  let str = '',\n    i = -1;\n  while (++i < columns.length) {\n    if (i > 0) str += ', ';\n    str += wrap(columns[i], undefined, builder, client, bindingHolder);\n  }\n  return str;\n}\n\n// Puts the appropriate wrapper around a value depending on the database\n// engine, unless it's a knex.raw value, in which case it's left alone.\nfunction wrap(value, isParameter, builder, client, bindingHolder) {\n  const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);\n  if (raw) return raw;\n  switch (typeof value) {\n    case 'function':\n      return outputQuery(compileCallback(value, undefined, client, bindingHolder), true, builder, client);\n    case 'object':\n      return parseObject(value, builder, client, bindingHolder);\n    case 'number':\n      return value;\n    default:\n      return wrapString(value + '', builder, client);\n  }\n}\nfunction unwrapRaw(value, isParameter, builder, client, bindingsHolder) {\n  let query;\n  if (value instanceof QueryBuilder) {\n    query = client.queryCompiler(value).toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return outputQuery(query, isParameter, builder, client);\n  }\n  if (value && value.isRawInstance) {\n    value.client = client;\n    if (builder._queryContext) {\n      value.queryContext = () => {\n        return builder._queryContext;\n      };\n    }\n    query = value.toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return query.sql;\n  }\n  if (isParameter) {\n    bindingsHolder.bindings.push(value);\n  }\n}\nfunction operator(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  const operator = operators[(value || '').toLowerCase()];\n  if (!operator) {\n    throw new TypeError(`The operator \"${value}\" is not permitted`);\n  }\n  return operator;\n}\n\n// Coerce to string to prevent strange errors when it's not a string.\nfunction wrapString(value, builder, client) {\n  const asIndex = value.toLowerCase().indexOf(' as ');\n  if (asIndex !== -1) {\n    const first = value.slice(0, asIndex);\n    const second = value.slice(asIndex + 4);\n    return client.alias(wrapString(first, builder, client), wrapAsIdentifier(second, builder, client));\n  }\n  const wrapped = [];\n  let i = -1;\n  const segments = value.split('.');\n  while (++i < segments.length) {\n    value = segments[i];\n    if (i === 0 && segments.length > 1) {\n      wrapped.push(wrapString((value || '').trim(), builder, client));\n    } else {\n      wrapped.push(wrapAsIdentifier(value, builder, client));\n    }\n  }\n  return wrapped.join('.');\n}\n\n// Key-value notation for alias\nfunction parseObject(obj, builder, client, formatter) {\n  const ret = [];\n  for (const alias in obj) {\n    const queryOrIdentifier = obj[alias];\n    // Avoids double aliasing for subqueries\n    if (typeof queryOrIdentifier === 'function') {\n      const compiled = compileCallback(queryOrIdentifier, undefined, client, formatter);\n      compiled.as = alias; // enforces the object's alias\n      ret.push(outputQuery(compiled, true, builder, client));\n    } else if (queryOrIdentifier instanceof QueryBuilder) {\n      ret.push(client.alias(`(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`, wrapAsIdentifier(alias, builder, client)));\n    } else {\n      ret.push(client.alias(wrap(queryOrIdentifier, undefined, builder, client, formatter), wrapAsIdentifier(alias, builder, client)));\n    }\n  }\n  return ret.join(', ');\n}\n\n// Ensures the query is aliased if necessary.\nfunction outputQuery(compiled, isParameter, builder, client) {\n  let sql = compiled.sql || '';\n  if (sql) {\n    if ((compiled.method === 'select' || compiled.method === 'first') && (isParameter || compiled.as)) {\n      sql = `(${sql})`;\n      if (compiled.as) return client.alias(sql, wrapString(compiled.as, builder, client));\n    }\n  }\n  return sql;\n}\n\n/**\n * Creates SQL for a parameter, which might be passed to where() or .with() or\n * pretty much anywhere in API.\n *\n * @param value\n * @param method Optional at least 'select' or 'update' are valid\n * @param builder\n * @param client\n * @param bindingHolder\n */\nfunction rawOrFn(value, method, builder, client, bindingHolder) {\n  if (typeof value === 'function') {\n    return outputQuery(compileCallback(value, method, client, bindingHolder), undefined, builder, client);\n  }\n  return unwrapRaw(value, undefined, builder, client, bindingHolder) || '';\n}\n\n// Specify the direction of the ordering.\nfunction direction(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';\n}\nmodule.exports = {\n  columnize,\n  direction,\n  operator,\n  outputQuery,\n  rawOrFn,\n  unwrapRaw,\n  wrap,\n  wrapString\n};","map":{"version":3,"names":["transform","require","QueryBuilder","compileCallback","wrapAsIdentifier","orderBys","operators","result","key","Array","isArray","columnize","target","builder","client","bindingHolder","columns","str","i","length","wrap","undefined","value","isParameter","raw","unwrapRaw","outputQuery","parseObject","wrapString","bindingsHolder","query","queryCompiler","toSQL","bindings","push","isRawInstance","_queryContext","queryContext","sql","operator","toLowerCase","TypeError","asIndex","indexOf","first","slice","second","alias","wrapped","segments","split","trim","join","obj","formatter","ret","queryOrIdentifier","compiled","as","method","rawOrFn","direction","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/formatter/wrappingFormatter.js"],"sourcesContent":["const transform = require('lodash/transform');\nconst QueryBuilder = require('../query/querybuilder');\nconst { compileCallback, wrapAsIdentifier } = require('./formatterUtils');\n\n// Valid values for the `order by` clause generation.\nconst orderBys = ['asc', 'desc'];\n\n// Turn this into a lookup map\nconst operators = transform(\n  [\n    '=',\n    '<',\n    '>',\n    '<=',\n    '>=',\n    '<>',\n    '!=',\n    'like',\n    'not like',\n    'between',\n    'not between',\n    'ilike',\n    'not ilike',\n    'exists',\n    'not exist',\n    'rlike',\n    'not rlike',\n    'regexp',\n    'not regexp',\n    'match',\n    '&',\n    '|',\n    '^',\n    '<<',\n    '>>',\n    '~',\n    '~=',\n    '~*',\n    '!~',\n    '!~*',\n    '#',\n    '&&',\n    '@>',\n    '<@',\n    '||',\n    '&<',\n    '&>',\n    '-|-',\n    '@@',\n    '!!',\n    ['?', '\\\\?'],\n    ['?|', '\\\\?|'],\n    ['?&', '\\\\?&'],\n  ],\n  (result, key) => {\n    if (Array.isArray(key)) {\n      result[key[0]] = key[1];\n    } else {\n      result[key] = key;\n    }\n  },\n  {}\n);\n\n// Accepts a string or array of columns to wrap as appropriate. Column can be raw\nfunction columnize(target, builder, client, bindingHolder) {\n  const columns = Array.isArray(target) ? target : [target];\n  let str = '',\n    i = -1;\n  while (++i < columns.length) {\n    if (i > 0) str += ', ';\n    str += wrap(columns[i], undefined, builder, client, bindingHolder);\n  }\n  return str;\n}\n\n// Puts the appropriate wrapper around a value depending on the database\n// engine, unless it's a knex.raw value, in which case it's left alone.\nfunction wrap(value, isParameter, builder, client, bindingHolder) {\n  const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);\n  if (raw) return raw;\n  switch (typeof value) {\n    case 'function':\n      return outputQuery(\n        compileCallback(value, undefined, client, bindingHolder),\n        true,\n        builder,\n        client\n      );\n    case 'object':\n      return parseObject(value, builder, client, bindingHolder);\n    case 'number':\n      return value;\n    default:\n      return wrapString(value + '', builder, client);\n  }\n}\n\nfunction unwrapRaw(value, isParameter, builder, client, bindingsHolder) {\n  let query;\n  if (value instanceof QueryBuilder) {\n    query = client.queryCompiler(value).toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return outputQuery(query, isParameter, builder, client);\n  }\n  if (value && value.isRawInstance) {\n    value.client = client;\n    if (builder._queryContext) {\n      value.queryContext = () => {\n        return builder._queryContext;\n      };\n    }\n\n    query = value.toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return query.sql;\n  }\n  if (isParameter) {\n    bindingsHolder.bindings.push(value);\n  }\n}\n\nfunction operator(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  const operator = operators[(value || '').toLowerCase()];\n  if (!operator) {\n    throw new TypeError(`The operator \"${value}\" is not permitted`);\n  }\n  return operator;\n}\n\n// Coerce to string to prevent strange errors when it's not a string.\nfunction wrapString(value, builder, client) {\n  const asIndex = value.toLowerCase().indexOf(' as ');\n  if (asIndex !== -1) {\n    const first = value.slice(0, asIndex);\n    const second = value.slice(asIndex + 4);\n    return client.alias(\n      wrapString(first, builder, client),\n      wrapAsIdentifier(second, builder, client)\n    );\n  }\n  const wrapped = [];\n  let i = -1;\n  const segments = value.split('.');\n  while (++i < segments.length) {\n    value = segments[i];\n    if (i === 0 && segments.length > 1) {\n      wrapped.push(wrapString((value || '').trim(), builder, client));\n    } else {\n      wrapped.push(wrapAsIdentifier(value, builder, client));\n    }\n  }\n  return wrapped.join('.');\n}\n\n// Key-value notation for alias\nfunction parseObject(obj, builder, client, formatter) {\n  const ret = [];\n  for (const alias in obj) {\n    const queryOrIdentifier = obj[alias];\n    // Avoids double aliasing for subqueries\n    if (typeof queryOrIdentifier === 'function') {\n      const compiled = compileCallback(\n        queryOrIdentifier,\n        undefined,\n        client,\n        formatter\n      );\n      compiled.as = alias; // enforces the object's alias\n      ret.push(outputQuery(compiled, true, builder, client));\n    } else if (queryOrIdentifier instanceof QueryBuilder) {\n      ret.push(\n        client.alias(\n          `(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`,\n          wrapAsIdentifier(alias, builder, client)\n        )\n      );\n    } else {\n      ret.push(\n        client.alias(\n          wrap(queryOrIdentifier, undefined, builder, client, formatter),\n          wrapAsIdentifier(alias, builder, client)\n        )\n      );\n    }\n  }\n  return ret.join(', ');\n}\n\n// Ensures the query is aliased if necessary.\nfunction outputQuery(compiled, isParameter, builder, client) {\n  let sql = compiled.sql || '';\n  if (sql) {\n    if (\n      (compiled.method === 'select' || compiled.method === 'first') &&\n      (isParameter || compiled.as)\n    ) {\n      sql = `(${sql})`;\n      if (compiled.as)\n        return client.alias(sql, wrapString(compiled.as, builder, client));\n    }\n  }\n  return sql;\n}\n\n/**\n * Creates SQL for a parameter, which might be passed to where() or .with() or\n * pretty much anywhere in API.\n *\n * @param value\n * @param method Optional at least 'select' or 'update' are valid\n * @param builder\n * @param client\n * @param bindingHolder\n */\nfunction rawOrFn(value, method, builder, client, bindingHolder) {\n  if (typeof value === 'function') {\n    return outputQuery(\n      compileCallback(value, method, client, bindingHolder),\n      undefined,\n      builder,\n      client\n    );\n  }\n  return unwrapRaw(value, undefined, builder, client, bindingHolder) || '';\n}\n\n// Specify the direction of the ordering.\nfunction direction(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';\n}\n\nmodule.exports = {\n  columnize,\n  direction,\n  operator,\n  outputQuery,\n  rawOrFn,\n  unwrapRaw,\n  wrap,\n  wrapString,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}