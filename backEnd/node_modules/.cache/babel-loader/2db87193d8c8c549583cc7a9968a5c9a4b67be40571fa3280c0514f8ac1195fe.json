{"ast":null,"code":"const Utils = require('../oracle/utils');\nconst {\n  promisify\n} = require('util');\nconst stream = require('stream');\nfunction BlobHelper(columnName, value) {\n  this.columnName = columnName;\n  this.value = value;\n  this.returning = false;\n}\nBlobHelper.prototype.toString = function () {\n  return '[object BlobHelper:' + this.columnName + ']';\n};\n\n/**\n * @param stream\n * @param {'string' | 'buffer'} type\n */\nfunction readStream(stream, type) {\n  return new Promise((resolve, reject) => {\n    let data = type === 'string' ? '' : Buffer.alloc(0);\n    stream.on('error', function (err) {\n      reject(err);\n    });\n    stream.on('data', function (chunk) {\n      if (type === 'string') {\n        data += chunk;\n      } else {\n        data = Buffer.concat([data, chunk]);\n      }\n    });\n    stream.on('end', function () {\n      resolve(data);\n    });\n  });\n}\nconst lobProcessing = function (stream) {\n  const oracledb = require('oracledb');\n\n  /**\n   * @type 'string' | 'buffer'\n   */\n  let type;\n  if (stream.type) {\n    // v1.2-v4\n    if (stream.type === oracledb.BLOB) {\n      type = 'buffer';\n    } else if (stream.type === oracledb.CLOB) {\n      type = 'string';\n    }\n  } else if (stream.iLob) {\n    // v1\n    if (stream.iLob.type === oracledb.CLOB) {\n      type = 'string';\n    } else if (stream.iLob.type === oracledb.BLOB) {\n      type = 'buffer';\n    }\n  } else {\n    throw new Error('Unrecognized oracledb lob stream type');\n  }\n  if (type === 'string') {\n    stream.setEncoding('utf-8');\n  }\n  return readStream(stream, type);\n};\nfunction monkeyPatchConnection(connection, client) {\n  // Connection is already monkey-patched\n  if (connection.executeAsync) {\n    return;\n  }\n  connection.commitAsync = function () {\n    return new Promise((commitResolve, commitReject) => {\n      this.commit(function (err) {\n        if (err) {\n          return commitReject(err);\n        }\n        commitResolve();\n      });\n    });\n  };\n  connection.rollbackAsync = function () {\n    return new Promise((rollbackResolve, rollbackReject) => {\n      this.rollback(function (err) {\n        if (err) {\n          return rollbackReject(err);\n        }\n        rollbackResolve();\n      });\n    });\n  };\n  const fetchAsync = promisify(function (sql, bindParams, options, cb) {\n    options = options || {};\n    options.outFormat = client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;\n    if (!options.outFormat) {\n      throw new Error('not found oracledb.outFormat constants');\n    }\n    if (options.resultSet) {\n      connection.execute(sql, bindParams || [], options, function (err, result) {\n        if (err) {\n          if (Utils.isConnectionError(err)) {\n            connection.close().catch(function (err) {});\n            connection.__knex__disposed = err;\n          }\n          return cb(err);\n        }\n        const fetchResult = {\n          rows: [],\n          resultSet: result.resultSet\n        };\n        const numRows = 100;\n        const fetchRowsFromRS = function (connection, resultSet, numRows) {\n          resultSet.getRows(numRows, function (err, rows) {\n            if (err) {\n              if (Utils.isConnectionError(err)) {\n                connection.close().catch(function (err) {});\n                connection.__knex__disposed = err;\n              }\n              resultSet.close(function () {\n                return cb(err);\n              });\n            } else if (rows.length === 0) {\n              return cb(null, fetchResult);\n            } else if (rows.length > 0) {\n              if (rows.length === numRows) {\n                fetchResult.rows = fetchResult.rows.concat(rows);\n                fetchRowsFromRS(connection, resultSet, numRows);\n              } else {\n                fetchResult.rows = fetchResult.rows.concat(rows);\n                return cb(null, fetchResult);\n              }\n            }\n          });\n        };\n        fetchRowsFromRS(connection, result.resultSet, numRows);\n      });\n    } else {\n      connection.execute(sql, bindParams || [], options, function (err, result) {\n        if (err) {\n          // dispose the connection on connection error\n          if (Utils.isConnectionError(err)) {\n            connection.close().catch(function (err) {});\n            connection.__knex__disposed = err;\n          }\n          return cb(err);\n        }\n        return cb(null, result);\n      });\n    }\n  });\n  connection.executeAsync = function (sql, bindParams, options) {\n    // Read all lob\n    return fetchAsync(sql, bindParams, options).then(async results => {\n      const closeResultSet = () => {\n        return results.resultSet ? promisify(results.resultSet.close).call(results.resultSet) : Promise.resolve();\n      };\n\n      // Collect LOBs to read\n      const lobs = [];\n      if (results.rows) {\n        if (Array.isArray(results.rows)) {\n          for (let i = 0; i < results.rows.length; i++) {\n            // Iterate through the rows\n            const row = results.rows[i];\n            for (const column in row) {\n              if (row[column] instanceof stream.Readable) {\n                lobs.push({\n                  index: i,\n                  key: column,\n                  stream: row[column]\n                });\n              }\n            }\n          }\n        }\n      }\n      try {\n        for (const lob of lobs) {\n          // todo should be fetchAsString/fetchAsBuffer polyfill only\n          results.rows[lob.index][lob.key] = await lobProcessing(lob.stream);\n        }\n      } catch (e) {\n        await closeResultSet().catch(() => {});\n        throw e;\n      }\n      await closeResultSet();\n      return results;\n    });\n  };\n}\nUtils.BlobHelper = BlobHelper;\nUtils.monkeyPatchConnection = monkeyPatchConnection;\nmodule.exports = Utils;","map":{"version":3,"names":["Utils","require","promisify","stream","BlobHelper","columnName","value","returning","prototype","toString","readStream","type","Promise","resolve","reject","data","Buffer","alloc","on","err","chunk","concat","lobProcessing","oracledb","BLOB","CLOB","iLob","Error","setEncoding","monkeyPatchConnection","connection","client","executeAsync","commitAsync","commitResolve","commitReject","commit","rollbackAsync","rollbackResolve","rollbackReject","rollback","fetchAsync","sql","bindParams","options","cb","outFormat","driver","OUT_FORMAT_OBJECT","OBJECT","resultSet","execute","result","isConnectionError","close","catch","__knex__disposed","fetchResult","rows","numRows","fetchRowsFromRS","getRows","length","then","results","closeResultSet","call","lobs","Array","isArray","i","row","column","Readable","push","index","key","lob","e","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/oracledb/utils.js"],"sourcesContent":["const Utils = require('../oracle/utils');\nconst { promisify } = require('util');\nconst stream = require('stream');\n\nfunction BlobHelper(columnName, value) {\n  this.columnName = columnName;\n  this.value = value;\n  this.returning = false;\n}\n\nBlobHelper.prototype.toString = function () {\n  return '[object BlobHelper:' + this.columnName + ']';\n};\n\n/**\n * @param stream\n * @param {'string' | 'buffer'} type\n */\nfunction readStream(stream, type) {\n  return new Promise((resolve, reject) => {\n    let data = type === 'string' ? '' : Buffer.alloc(0);\n\n    stream.on('error', function (err) {\n      reject(err);\n    });\n    stream.on('data', function (chunk) {\n      if (type === 'string') {\n        data += chunk;\n      } else {\n        data = Buffer.concat([data, chunk]);\n      }\n    });\n    stream.on('end', function () {\n      resolve(data);\n    });\n  });\n}\n\nconst lobProcessing = function (stream) {\n  const oracledb = require('oracledb');\n\n  /**\n   * @type 'string' | 'buffer'\n   */\n  let type;\n\n  if (stream.type) {\n    // v1.2-v4\n    if (stream.type === oracledb.BLOB) {\n      type = 'buffer';\n    } else if (stream.type === oracledb.CLOB) {\n      type = 'string';\n    }\n  } else if (stream.iLob) {\n    // v1\n    if (stream.iLob.type === oracledb.CLOB) {\n      type = 'string';\n    } else if (stream.iLob.type === oracledb.BLOB) {\n      type = 'buffer';\n    }\n  } else {\n    throw new Error('Unrecognized oracledb lob stream type');\n  }\n  if (type === 'string') {\n    stream.setEncoding('utf-8');\n  }\n  return readStream(stream, type);\n};\n\nfunction monkeyPatchConnection(connection, client) {\n  // Connection is already monkey-patched\n  if (connection.executeAsync) {\n    return;\n  }\n\n  connection.commitAsync = function () {\n    return new Promise((commitResolve, commitReject) => {\n      this.commit(function (err) {\n        if (err) {\n          return commitReject(err);\n        }\n        commitResolve();\n      });\n    });\n  };\n  connection.rollbackAsync = function () {\n    return new Promise((rollbackResolve, rollbackReject) => {\n      this.rollback(function (err) {\n        if (err) {\n          return rollbackReject(err);\n        }\n        rollbackResolve();\n      });\n    });\n  };\n  const fetchAsync = promisify(function (sql, bindParams, options, cb) {\n    options = options || {};\n    options.outFormat = client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;\n    if (!options.outFormat) {\n      throw new Error('not found oracledb.outFormat constants');\n    }\n    if (options.resultSet) {\n      connection.execute(\n        sql,\n        bindParams || [],\n        options,\n        function (err, result) {\n          if (err) {\n            if (Utils.isConnectionError(err)) {\n              connection.close().catch(function (err) {});\n              connection.__knex__disposed = err;\n            }\n            return cb(err);\n          }\n          const fetchResult = { rows: [], resultSet: result.resultSet };\n          const numRows = 100;\n          const fetchRowsFromRS = function (connection, resultSet, numRows) {\n            resultSet.getRows(numRows, function (err, rows) {\n              if (err) {\n                if (Utils.isConnectionError(err)) {\n                  connection.close().catch(function (err) {});\n                  connection.__knex__disposed = err;\n                }\n                resultSet.close(function () {\n                  return cb(err);\n                });\n              } else if (rows.length === 0) {\n                return cb(null, fetchResult);\n              } else if (rows.length > 0) {\n                if (rows.length === numRows) {\n                  fetchResult.rows = fetchResult.rows.concat(rows);\n                  fetchRowsFromRS(connection, resultSet, numRows);\n                } else {\n                  fetchResult.rows = fetchResult.rows.concat(rows);\n                  return cb(null, fetchResult);\n                }\n              }\n            });\n          };\n          fetchRowsFromRS(connection, result.resultSet, numRows);\n        }\n      );\n    } else {\n      connection.execute(\n        sql,\n        bindParams || [],\n        options,\n        function (err, result) {\n          if (err) {\n            // dispose the connection on connection error\n            if (Utils.isConnectionError(err)) {\n              connection.close().catch(function (err) {});\n              connection.__knex__disposed = err;\n            }\n            return cb(err);\n          }\n\n          return cb(null, result);\n        }\n      );\n    }\n  });\n  connection.executeAsync = function (sql, bindParams, options) {\n    // Read all lob\n    return fetchAsync(sql, bindParams, options).then(async (results) => {\n      const closeResultSet = () => {\n        return results.resultSet\n          ? promisify(results.resultSet.close).call(results.resultSet)\n          : Promise.resolve();\n      };\n\n      // Collect LOBs to read\n      const lobs = [];\n      if (results.rows) {\n        if (Array.isArray(results.rows)) {\n          for (let i = 0; i < results.rows.length; i++) {\n            // Iterate through the rows\n            const row = results.rows[i];\n            for (const column in row) {\n              if (row[column] instanceof stream.Readable) {\n                lobs.push({ index: i, key: column, stream: row[column] });\n              }\n            }\n          }\n        }\n      }\n\n      try {\n        for (const lob of lobs) {\n          // todo should be fetchAsString/fetchAsBuffer polyfill only\n          results.rows[lob.index][lob.key] = await lobProcessing(lob.stream);\n        }\n      } catch (e) {\n        await closeResultSet().catch(() => {});\n\n        throw e;\n      }\n\n      await closeResultSet();\n\n      return results;\n    });\n  };\n}\n\nUtils.BlobHelper = BlobHelper;\nUtils.monkeyPatchConnection = monkeyPatchConnection;\nmodule.exports = Utils;\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AACxC,MAAM;EAAEC;AAAU,CAAC,GAAGD,OAAO,CAAC,MAAM,CAAC;AACrC,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAEhC,SAASG,UAAUA,CAACC,UAAU,EAAEC,KAAK,EAAE;EACrC,IAAI,CAACD,UAAU,GAAGA,UAAU;EAC5B,IAAI,CAACC,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,SAAS,GAAG,KAAK;AACxB;AAEAH,UAAU,CAACI,SAAS,CAACC,QAAQ,GAAG,YAAY;EAC1C,OAAO,qBAAqB,GAAG,IAAI,CAACJ,UAAU,GAAG,GAAG;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA,SAASK,UAAUA,CAACP,MAAM,EAAEQ,IAAI,EAAE;EAChC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAIC,IAAI,GAAGJ,IAAI,KAAK,QAAQ,GAAG,EAAE,GAAGK,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAEnDd,MAAM,CAACe,EAAE,CAAC,OAAO,EAAE,UAAUC,GAAG,EAAE;MAChCL,MAAM,CAACK,GAAG,CAAC;IACb,CAAC,CAAC;IACFhB,MAAM,CAACe,EAAE,CAAC,MAAM,EAAE,UAAUE,KAAK,EAAE;MACjC,IAAIT,IAAI,KAAK,QAAQ,EAAE;QACrBI,IAAI,IAAIK,KAAK;MACf,CAAC,MAAM;QACLL,IAAI,GAAGC,MAAM,CAACK,MAAM,CAAC,CAACN,IAAI,EAAEK,KAAK,CAAC,CAAC;MACrC;IACF,CAAC,CAAC;IACFjB,MAAM,CAACe,EAAE,CAAC,KAAK,EAAE,YAAY;MAC3BL,OAAO,CAACE,IAAI,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,MAAMO,aAAa,GAAG,SAAAA,CAAUnB,MAAM,EAAE;EACtC,MAAMoB,QAAQ,GAAGtB,OAAO,CAAC,UAAU,CAAC;;EAEpC;AACF;AACA;EACE,IAAIU,IAAI;EAER,IAAIR,MAAM,CAACQ,IAAI,EAAE;IACf;IACA,IAAIR,MAAM,CAACQ,IAAI,KAAKY,QAAQ,CAACC,IAAI,EAAE;MACjCb,IAAI,GAAG,QAAQ;IACjB,CAAC,MAAM,IAAIR,MAAM,CAACQ,IAAI,KAAKY,QAAQ,CAACE,IAAI,EAAE;MACxCd,IAAI,GAAG,QAAQ;IACjB;EACF,CAAC,MAAM,IAAIR,MAAM,CAACuB,IAAI,EAAE;IACtB;IACA,IAAIvB,MAAM,CAACuB,IAAI,CAACf,IAAI,KAAKY,QAAQ,CAACE,IAAI,EAAE;MACtCd,IAAI,GAAG,QAAQ;IACjB,CAAC,MAAM,IAAIR,MAAM,CAACuB,IAAI,CAACf,IAAI,KAAKY,QAAQ,CAACC,IAAI,EAAE;MAC7Cb,IAAI,GAAG,QAAQ;IACjB;EACF,CAAC,MAAM;IACL,MAAM,IAAIgB,KAAK,CAAC,uCAAuC,CAAC;EAC1D;EACA,IAAIhB,IAAI,KAAK,QAAQ,EAAE;IACrBR,MAAM,CAACyB,WAAW,CAAC,OAAO,CAAC;EAC7B;EACA,OAAOlB,UAAU,CAACP,MAAM,EAAEQ,IAAI,CAAC;AACjC,CAAC;AAED,SAASkB,qBAAqBA,CAACC,UAAU,EAAEC,MAAM,EAAE;EACjD;EACA,IAAID,UAAU,CAACE,YAAY,EAAE;IAC3B;EACF;EAEAF,UAAU,CAACG,WAAW,GAAG,YAAY;IACnC,OAAO,IAAIrB,OAAO,CAAC,CAACsB,aAAa,EAAEC,YAAY,KAAK;MAClD,IAAI,CAACC,MAAM,CAAC,UAAUjB,GAAG,EAAE;QACzB,IAAIA,GAAG,EAAE;UACP,OAAOgB,YAAY,CAAChB,GAAG,CAAC;QAC1B;QACAe,aAAa,CAAC,CAAC;MACjB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;EACDJ,UAAU,CAACO,aAAa,GAAG,YAAY;IACrC,OAAO,IAAIzB,OAAO,CAAC,CAAC0B,eAAe,EAAEC,cAAc,KAAK;MACtD,IAAI,CAACC,QAAQ,CAAC,UAAUrB,GAAG,EAAE;QAC3B,IAAIA,GAAG,EAAE;UACP,OAAOoB,cAAc,CAACpB,GAAG,CAAC;QAC5B;QACAmB,eAAe,CAAC,CAAC;MACnB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;EACD,MAAMG,UAAU,GAAGvC,SAAS,CAAC,UAAUwC,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAEC,EAAE,EAAE;IACnED,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvBA,OAAO,CAACE,SAAS,GAAGf,MAAM,CAACgB,MAAM,CAACC,iBAAiB,IAAIjB,MAAM,CAACgB,MAAM,CAACE,MAAM;IAC3E,IAAI,CAACL,OAAO,CAACE,SAAS,EAAE;MACtB,MAAM,IAAInB,KAAK,CAAC,wCAAwC,CAAC;IAC3D;IACA,IAAIiB,OAAO,CAACM,SAAS,EAAE;MACrBpB,UAAU,CAACqB,OAAO,CAChBT,GAAG,EACHC,UAAU,IAAI,EAAE,EAChBC,OAAO,EACP,UAAUzB,GAAG,EAAEiC,MAAM,EAAE;QACrB,IAAIjC,GAAG,EAAE;UACP,IAAInB,KAAK,CAACqD,iBAAiB,CAAClC,GAAG,CAAC,EAAE;YAChCW,UAAU,CAACwB,KAAK,CAAC,CAAC,CAACC,KAAK,CAAC,UAAUpC,GAAG,EAAE,CAAC,CAAC,CAAC;YAC3CW,UAAU,CAAC0B,gBAAgB,GAAGrC,GAAG;UACnC;UACA,OAAO0B,EAAE,CAAC1B,GAAG,CAAC;QAChB;QACA,MAAMsC,WAAW,GAAG;UAAEC,IAAI,EAAE,EAAE;UAAER,SAAS,EAAEE,MAAM,CAACF;QAAU,CAAC;QAC7D,MAAMS,OAAO,GAAG,GAAG;QACnB,MAAMC,eAAe,GAAG,SAAAA,CAAU9B,UAAU,EAAEoB,SAAS,EAAES,OAAO,EAAE;UAChET,SAAS,CAACW,OAAO,CAACF,OAAO,EAAE,UAAUxC,GAAG,EAAEuC,IAAI,EAAE;YAC9C,IAAIvC,GAAG,EAAE;cACP,IAAInB,KAAK,CAACqD,iBAAiB,CAAClC,GAAG,CAAC,EAAE;gBAChCW,UAAU,CAACwB,KAAK,CAAC,CAAC,CAACC,KAAK,CAAC,UAAUpC,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC3CW,UAAU,CAAC0B,gBAAgB,GAAGrC,GAAG;cACnC;cACA+B,SAAS,CAACI,KAAK,CAAC,YAAY;gBAC1B,OAAOT,EAAE,CAAC1B,GAAG,CAAC;cAChB,CAAC,CAAC;YACJ,CAAC,MAAM,IAAIuC,IAAI,CAACI,MAAM,KAAK,CAAC,EAAE;cAC5B,OAAOjB,EAAE,CAAC,IAAI,EAAEY,WAAW,CAAC;YAC9B,CAAC,MAAM,IAAIC,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;cAC1B,IAAIJ,IAAI,CAACI,MAAM,KAAKH,OAAO,EAAE;gBAC3BF,WAAW,CAACC,IAAI,GAAGD,WAAW,CAACC,IAAI,CAACrC,MAAM,CAACqC,IAAI,CAAC;gBAChDE,eAAe,CAAC9B,UAAU,EAAEoB,SAAS,EAAES,OAAO,CAAC;cACjD,CAAC,MAAM;gBACLF,WAAW,CAACC,IAAI,GAAGD,WAAW,CAACC,IAAI,CAACrC,MAAM,CAACqC,IAAI,CAAC;gBAChD,OAAOb,EAAE,CAAC,IAAI,EAAEY,WAAW,CAAC;cAC9B;YACF;UACF,CAAC,CAAC;QACJ,CAAC;QACDG,eAAe,CAAC9B,UAAU,EAAEsB,MAAM,CAACF,SAAS,EAAES,OAAO,CAAC;MACxD,CACF,CAAC;IACH,CAAC,MAAM;MACL7B,UAAU,CAACqB,OAAO,CAChBT,GAAG,EACHC,UAAU,IAAI,EAAE,EAChBC,OAAO,EACP,UAAUzB,GAAG,EAAEiC,MAAM,EAAE;QACrB,IAAIjC,GAAG,EAAE;UACP;UACA,IAAInB,KAAK,CAACqD,iBAAiB,CAAClC,GAAG,CAAC,EAAE;YAChCW,UAAU,CAACwB,KAAK,CAAC,CAAC,CAACC,KAAK,CAAC,UAAUpC,GAAG,EAAE,CAAC,CAAC,CAAC;YAC3CW,UAAU,CAAC0B,gBAAgB,GAAGrC,GAAG;UACnC;UACA,OAAO0B,EAAE,CAAC1B,GAAG,CAAC;QAChB;QAEA,OAAO0B,EAAE,CAAC,IAAI,EAAEO,MAAM,CAAC;MACzB,CACF,CAAC;IACH;EACF,CAAC,CAAC;EACFtB,UAAU,CAACE,YAAY,GAAG,UAAUU,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAE;IAC5D;IACA,OAAOH,UAAU,CAACC,GAAG,EAAEC,UAAU,EAAEC,OAAO,CAAC,CAACmB,IAAI,CAAC,MAAOC,OAAO,IAAK;MAClE,MAAMC,cAAc,GAAGA,CAAA,KAAM;QAC3B,OAAOD,OAAO,CAACd,SAAS,GACpBhD,SAAS,CAAC8D,OAAO,CAACd,SAAS,CAACI,KAAK,CAAC,CAACY,IAAI,CAACF,OAAO,CAACd,SAAS,CAAC,GAC1DtC,OAAO,CAACC,OAAO,CAAC,CAAC;MACvB,CAAC;;MAED;MACA,MAAMsD,IAAI,GAAG,EAAE;MACf,IAAIH,OAAO,CAACN,IAAI,EAAE;QAChB,IAAIU,KAAK,CAACC,OAAO,CAACL,OAAO,CAACN,IAAI,CAAC,EAAE;UAC/B,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,OAAO,CAACN,IAAI,CAACI,MAAM,EAAEQ,CAAC,EAAE,EAAE;YAC5C;YACA,MAAMC,GAAG,GAAGP,OAAO,CAACN,IAAI,CAACY,CAAC,CAAC;YAC3B,KAAK,MAAME,MAAM,IAAID,GAAG,EAAE;cACxB,IAAIA,GAAG,CAACC,MAAM,CAAC,YAAYrE,MAAM,CAACsE,QAAQ,EAAE;gBAC1CN,IAAI,CAACO,IAAI,CAAC;kBAAEC,KAAK,EAAEL,CAAC;kBAAEM,GAAG,EAAEJ,MAAM;kBAAErE,MAAM,EAAEoE,GAAG,CAACC,MAAM;gBAAE,CAAC,CAAC;cAC3D;YACF;UACF;QACF;MACF;MAEA,IAAI;QACF,KAAK,MAAMK,GAAG,IAAIV,IAAI,EAAE;UACtB;UACAH,OAAO,CAACN,IAAI,CAACmB,GAAG,CAACF,KAAK,CAAC,CAACE,GAAG,CAACD,GAAG,CAAC,GAAG,MAAMtD,aAAa,CAACuD,GAAG,CAAC1E,MAAM,CAAC;QACpE;MACF,CAAC,CAAC,OAAO2E,CAAC,EAAE;QACV,MAAMb,cAAc,CAAC,CAAC,CAACV,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QAEtC,MAAMuB,CAAC;MACT;MAEA,MAAMb,cAAc,CAAC,CAAC;MAEtB,OAAOD,OAAO;IAChB,CAAC,CAAC;EACJ,CAAC;AACH;AAEAhE,KAAK,CAACI,UAAU,GAAGA,UAAU;AAC7BJ,KAAK,CAAC6B,qBAAqB,GAAGA,qBAAqB;AACnDkD,MAAM,CAACC,OAAO,GAAGhF,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}