{"ast":null,"code":"const clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst Oracle_Compiler = require('../../oracle/query/oracle-querycompiler');\nconst ReturningHelper = require('../utils').ReturningHelper;\nconst BlobHelper = require('../utils').BlobHelper;\nconst {\n  isString\n} = require('../../../util/is');\nconst {\n  columnize: columnize_\n} = require('../../../formatter/wrappingFormatter');\nclass Oracledb_Compiler extends Oracle_Compiler {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const self = this;\n    const outBindPrep = this._prepOutbindings(this.single.insert, this.single.returning);\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n    const insertValues = outBindPrep.values;\n    if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {\n      const returningFragment = this.single.returning ? ' (' + this.formatter.wrap(this.single.returning) + ')' : '';\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + returningFragment + ' values (default)', outBinding[0], this.tableName, returning);\n    }\n    if (isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n    const insertData = this._prepInsert(insertValues);\n    const sql = {};\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' ' + insertData, outBinding[0], this.tableName, returning);\n    }\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.columnize(insertData.columns) + ') values (' + this.client.parameterize(insertData.values[0], undefined, this.builder, this.bindingsHolder) + ')', outBinding[0], this.tableName, returning);\n    }\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.returning = returning;\n    sql.sql = 'begin ' + insertData.values.map(function (value, index) {\n      const parameterizedValues = !insertDefaultsOnly ? self.client.parameterize(value, self.client.valueForUndefined, self.builder, self.bindingsHolder) : '';\n      let subSql = 'insert into ' + self.tableName;\n      if (insertDefaultsOnly) {\n        // No columns given so only the default value\n        subSql += ' (' + self.formatter.wrap(self.single.returning) + ') values (default)';\n      } else {\n        subSql += ' (' + self.formatter.columnize(insertData.columns) + ') values (' + parameterizedValues + ')';\n      }\n      let returningClause = '';\n      let intoClause = '';\n      // ToDo review if this code is still needed or could be dropped\n      // eslint-disable-next-line no-unused-vars\n      let usingClause = '';\n      let outClause = '';\n      each(value, function (val) {\n        if (!(val instanceof BlobHelper)) {\n          usingClause += ' ?,';\n        }\n      });\n      // eslint-disable-next-line no-unused-vars\n      usingClause = usingClause.slice(0, -1);\n\n      // Build returning and into clauses\n      outBinding[index].forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n        outClause += ' out ?,';\n\n        // Add Helpers to bindings\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n\n      // Strip last comma\n      returningClause = returningClause.slice(0, -1);\n      intoClause = intoClause.slice(0, -1);\n      outClause = outClause.slice(0, -1);\n      if (returningClause && intoClause) {\n        subSql += ' returning ' + returningClause + ' into' + intoClause;\n      }\n\n      // Pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n      subSql = self.formatter.client.positionBindings(subSql);\n      const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues.replace(/DEFAULT, /g, '').replace(/, DEFAULT/g, '').replace('EMPTY_BLOB(), ', '').replace(', EMPTY_BLOB()', '');\n      return \"execute immediate '\" + subSql.replace(/'/g, \"''\") + (parameterizedValuesWithoutDefaultAndBlob || value ? \"' using \" : '') + parameterizedValuesWithoutDefaultAndBlob + (parameterizedValuesWithoutDefaultAndBlob && outClause ? ',' : '') + outClause + ';';\n    }).join(' ') + 'end;';\n    sql.outBinding = outBinding;\n    if (returning[0] === '*') {\n      // Generate select statement with special order by\n      // to keep the order because 'in (..)' may change the order\n      sql.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID in (' + this.outBinding.map(function (v, i) {\n          return ':' + (i + 1);\n        }).join(', ') + ')' + ' order by case ROWID ' + this.outBinding.map(function (v, i) {\n          return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;\n        }).join(' ') + ' end';\n      };\n    }\n    return sql;\n  }\n  with() {\n    // WITH RECURSIVE is a syntax error in Oracle SQL.\n    // So mark all statements as non-recursive, generate the SQL, then restore.\n    // This approach ensures any changes in base class with() get propagated here.\n    const undoList = [];\n    if (this.grouped.with) {\n      for (const stmt of this.grouped.with) {\n        if (stmt.recursive) {\n          undoList.push(stmt);\n          stmt.recursive = false;\n        }\n      }\n    }\n    const result = super.with();\n\n    // Restore the recursive markings, in case this same query gets cloned and passed to other drivers.\n    for (const stmt of undoList) {\n      stmt.recursive = true;\n    }\n    return result;\n  }\n  _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {\n    const self = this;\n    const res = {\n      sql: sql\n    };\n    if (!outBinding) {\n      return res;\n    }\n    const returningValues = Array.isArray(outBinding) ? outBinding : [outBinding];\n    let returningClause = '';\n    let intoClause = '';\n    // Build returning and into clauses\n    returningValues.forEach(function (ret) {\n      const columnName = ret.columnName || ret;\n      returningClause += self.formatter.wrap(columnName) + ',';\n      intoClause += '?,';\n\n      // Add Helpers to bindings\n      if (ret instanceof BlobHelper) {\n        return self.formatter.bindings.push(ret);\n      }\n      self.formatter.bindings.push(new ReturningHelper(columnName));\n    });\n    res.sql = sql;\n\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    if (returningClause && intoClause) {\n      res.sql += ' returning ' + returningClause + ' into ' + intoClause;\n    }\n    res.outBinding = [outBinding];\n    if (returning[0] === '*') {\n      res.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID = :1';\n      };\n    }\n    res.returning = returning;\n    return res;\n  }\n  _prepOutbindings(paramValues, paramReturning) {\n    const result = {};\n    let params = paramValues || [];\n    let returning = paramReturning || [];\n    if (!Array.isArray(params) && isPlainObject(paramValues)) {\n      params = [params];\n    }\n    // Always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n    const outBinding = [];\n    // Handle Buffer value as Blob\n    each(params, function (values, index) {\n      if (returning[0] === '*') {\n        outBinding[index] = ['ROWID'];\n      } else {\n        outBinding[index] = clone(returning);\n      }\n      each(values, function (value, key) {\n        if (value instanceof Buffer) {\n          values[key] = new BlobHelper(key, value);\n\n          // Delete blob duplicate in returning\n          const blobIndex = outBinding[index].indexOf(key);\n          if (blobIndex >= 0) {\n            outBinding[index].splice(blobIndex, 1);\n            values[key].returning = true;\n          }\n          outBinding[index].push(values[key]);\n        }\n        if (value === undefined) {\n          delete params[index][key];\n        }\n      });\n    });\n    result.returning = returning;\n    result.outBinding = outBinding;\n    result.values = params;\n    return result;\n  }\n  _groupOrder(item, type) {\n    return super._groupOrderNulls(item, type);\n  }\n  update() {\n    const self = this;\n    const sql = {};\n    const outBindPrep = this._prepOutbindings(this.single.update || this.single.counter, this.single.returning);\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    let returningClause = '';\n    let intoClause = '';\n    if (isEmpty(updates) && typeof this.single.update !== 'function') {\n      return '';\n    }\n\n    // Build returning and into clauses\n    outBinding.forEach(function (out) {\n      out.forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n\n        // Add Helpers to bindings\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n    });\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    sql.outBinding = outBinding;\n    sql.returning = returning;\n    sql.sql = 'update ' + this.tableName + ' set ' + updates.join(', ') + (where ? ' ' + where : '');\n    if (outBinding.length && !isEmpty(outBinding[0])) {\n      sql.sql += ' returning ' + returningClause + ' into' + intoClause;\n    }\n    if (returning[0] === '*') {\n      sql.returningSql = function () {\n        let sql = 'select * from ' + self.tableName;\n        const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;\n        let returningSqlIn = ' where ROWID in (';\n        let returningSqlOrderBy = ') order by case ROWID ';\n\n        // Needs special order by because in(...) change result order\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          if (this.returning[0] === '*') {\n            returningSqlIn += ':' + (i + 1) + ', ';\n            returningSqlOrderBy += 'when CHARTOROWID(:' + (i + 1) + ') then ' + i + ' ';\n          }\n        }\n        if (this.returning[0] === '*') {\n          this.returning = this.returning.slice(0, -1);\n          returningSqlIn = returningSqlIn.slice(0, -2);\n          returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);\n        }\n        return sql += returningSqlIn + returningSqlOrderBy + ' end';\n      };\n    }\n    return sql;\n  }\n  _jsonPathWrap(extraction) {\n    return `'${extraction.path || extraction[1]}'`;\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract(params.singleValue ? 'json_value' : 'json_query', params);\n  }\n  jsonSet(params) {\n    return `json_transform(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)}, set ${this.client.parameter(params.path, this.builder, this.bindingsHolder)} = ${this.client.parameter(params.value, this.builder, this.bindingsHolder)})`;\n  }\n  jsonInsert(params) {\n    return `json_transform(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)}, insert ${this.client.parameter(params.path, this.builder, this.bindingsHolder)} = ${this.client.parameter(params.value, this.builder, this.bindingsHolder)})`;\n  }\n  jsonRemove(params) {\n    const jsonCol = `json_transform(${columnize_(params.column, this.builder, this.client, this.bindingsHolder)}, remove ${this.client.parameter(params.path, this.builder, this.bindingsHolder)})`;\n    return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;\n  }\n  whereJsonPath(statement) {\n    return this._whereJsonPath('json_value', statement);\n  }\n  whereJsonSupersetOf(statement) {\n    throw new Error('Json superset where clause not actually supported by Oracle');\n  }\n  whereJsonSubsetOf(statement) {\n    throw new Error('Json subset where clause not actually supported by Oracle');\n  }\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_value', clause);\n  }\n}\nmodule.exports = Oracledb_Compiler;","map":{"version":3,"names":["clone","require","each","isEmpty","isPlainObject","Oracle_Compiler","ReturningHelper","BlobHelper","isString","columnize","columnize_","Oracledb_Compiler","insert","self","outBindPrep","_prepOutbindings","single","returning","outBinding","insertValues","values","Array","isArray","length","returningFragment","formatter","wrap","_addReturningToSqlAndConvert","tableName","insertData","_prepInsert","sql","columns","client","parameterize","undefined","builder","bindingsHolder","insertDefaultsOnly","map","value","index","parameterizedValues","valueForUndefined","subSql","returningClause","intoClause","usingClause","outClause","val","slice","forEach","ret","columnName","bindings","push","positionBindings","parameterizedValuesWithoutDefaultAndBlob","replace","join","returningSql","v","i","with","undoList","grouped","stmt","recursive","result","res","returningValues","paramValues","paramReturning","params","key","Buffer","blobIndex","indexOf","splice","_groupOrder","item","type","_groupOrderNulls","update","counter","updates","_prepUpdate","where","out","modifiedRowsCount","rowsAffected","returningSqlIn","returningSqlOrderBy","_jsonPathWrap","extraction","path","jsonExtract","_jsonExtract","singleValue","jsonSet","column","parameter","jsonInsert","jsonRemove","jsonCol","alias","whereJsonPath","statement","_whereJsonPath","whereJsonSupersetOf","Error","whereJsonSubsetOf","onJsonPathEquals","clause","_onJsonPathEquals","module","exports"],"sources":["C:/Users/momo1/Documents/@DevPerso/Beacon/node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js"],"sourcesContent":["const clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst Oracle_Compiler = require('../../oracle/query/oracle-querycompiler');\nconst ReturningHelper = require('../utils').ReturningHelper;\nconst BlobHelper = require('../utils').BlobHelper;\nconst { isString } = require('../../../util/is');\nconst {\n  columnize: columnize_,\n} = require('../../../formatter/wrappingFormatter');\n\nclass Oracledb_Compiler extends Oracle_Compiler {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const self = this;\n    const outBindPrep = this._prepOutbindings(\n      this.single.insert,\n      this.single.returning\n    );\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n    const insertValues = outBindPrep.values;\n\n    if (\n      Array.isArray(insertValues) &&\n      insertValues.length === 1 &&\n      isEmpty(insertValues[0])\n    ) {\n      const returningFragment = this.single.returning\n        ? ' (' + this.formatter.wrap(this.single.returning) + ')'\n        : '';\n\n      return this._addReturningToSqlAndConvert(\n        'insert into ' +\n          this.tableName +\n          returningFragment +\n          ' values (default)',\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    if (\n      isEmpty(this.single.insert) &&\n      typeof this.single.insert !== 'function'\n    ) {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(\n        'insert into ' + this.tableName + ' ' + insertData,\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(\n        'insert into ' +\n          this.tableName +\n          ' (' +\n          this.formatter.columnize(insertData.columns) +\n          ') values (' +\n          this.client.parameterize(\n            insertData.values[0],\n            undefined,\n            this.builder,\n            this.bindingsHolder\n          ) +\n          ')',\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.returning = returning;\n    sql.sql =\n      'begin ' +\n      insertData.values\n        .map(function (value, index) {\n          const parameterizedValues = !insertDefaultsOnly\n            ? self.client.parameterize(\n                value,\n                self.client.valueForUndefined,\n                self.builder,\n                self.bindingsHolder\n              )\n            : '';\n          let subSql = 'insert into ' + self.tableName;\n\n          if (insertDefaultsOnly) {\n            // No columns given so only the default value\n            subSql +=\n              ' (' +\n              self.formatter.wrap(self.single.returning) +\n              ') values (default)';\n          } else {\n            subSql +=\n              ' (' +\n              self.formatter.columnize(insertData.columns) +\n              ') values (' +\n              parameterizedValues +\n              ')';\n          }\n\n          let returningClause = '';\n          let intoClause = '';\n          // ToDo review if this code is still needed or could be dropped\n          // eslint-disable-next-line no-unused-vars\n          let usingClause = '';\n          let outClause = '';\n\n          each(value, function (val) {\n            if (!(val instanceof BlobHelper)) {\n              usingClause += ' ?,';\n            }\n          });\n          // eslint-disable-next-line no-unused-vars\n          usingClause = usingClause.slice(0, -1);\n\n          // Build returning and into clauses\n          outBinding[index].forEach(function (ret) {\n            const columnName = ret.columnName || ret;\n            returningClause += self.formatter.wrap(columnName) + ',';\n            intoClause += ' ?,';\n            outClause += ' out ?,';\n\n            // Add Helpers to bindings\n            if (ret instanceof BlobHelper) {\n              return self.formatter.bindings.push(ret);\n            }\n            self.formatter.bindings.push(new ReturningHelper(columnName));\n          });\n\n          // Strip last comma\n          returningClause = returningClause.slice(0, -1);\n          intoClause = intoClause.slice(0, -1);\n          outClause = outClause.slice(0, -1);\n\n          if (returningClause && intoClause) {\n            subSql += ' returning ' + returningClause + ' into' + intoClause;\n          }\n\n          // Pre bind position because subSql is an execute immediate parameter\n          // later position binding will only convert the ? params\n          subSql = self.formatter.client.positionBindings(subSql);\n          const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues\n            .replace(/DEFAULT, /g, '')\n            .replace(/, DEFAULT/g, '')\n            .replace('EMPTY_BLOB(), ', '')\n            .replace(', EMPTY_BLOB()', '');\n          return (\n            \"execute immediate '\" +\n            subSql.replace(/'/g, \"''\") +\n            (parameterizedValuesWithoutDefaultAndBlob || value\n              ? \"' using \"\n              : '') +\n            parameterizedValuesWithoutDefaultAndBlob +\n            (parameterizedValuesWithoutDefaultAndBlob && outClause ? ',' : '') +\n            outClause +\n            ';'\n          );\n        })\n        .join(' ') +\n      'end;';\n\n    sql.outBinding = outBinding;\n    if (returning[0] === '*') {\n      // Generate select statement with special order by\n      // to keep the order because 'in (..)' may change the order\n      sql.returningSql = function () {\n        return (\n          'select * from ' +\n          self.tableName +\n          ' where ROWID in (' +\n          this.outBinding\n            .map(function (v, i) {\n              return ':' + (i + 1);\n            })\n            .join(', ') +\n          ')' +\n          ' order by case ROWID ' +\n          this.outBinding\n            .map(function (v, i) {\n              return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;\n            })\n            .join(' ') +\n          ' end'\n        );\n      };\n    }\n\n    return sql;\n  }\n\n  with() {\n    // WITH RECURSIVE is a syntax error in Oracle SQL.\n    // So mark all statements as non-recursive, generate the SQL, then restore.\n    // This approach ensures any changes in base class with() get propagated here.\n    const undoList = [];\n    if (this.grouped.with) {\n      for (const stmt of this.grouped.with) {\n        if (stmt.recursive) {\n          undoList.push(stmt);\n          stmt.recursive = false;\n        }\n      }\n    }\n\n    const result = super.with();\n\n    // Restore the recursive markings, in case this same query gets cloned and passed to other drivers.\n    for (const stmt of undoList) {\n      stmt.recursive = true;\n    }\n    return result;\n  }\n\n  _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {\n    const self = this;\n    const res = {\n      sql: sql,\n    };\n\n    if (!outBinding) {\n      return res;\n    }\n    const returningValues = Array.isArray(outBinding)\n      ? outBinding\n      : [outBinding];\n    let returningClause = '';\n    let intoClause = '';\n    // Build returning and into clauses\n    returningValues.forEach(function (ret) {\n      const columnName = ret.columnName || ret;\n      returningClause += self.formatter.wrap(columnName) + ',';\n      intoClause += '?,';\n\n      // Add Helpers to bindings\n      if (ret instanceof BlobHelper) {\n        return self.formatter.bindings.push(ret);\n      }\n      self.formatter.bindings.push(new ReturningHelper(columnName));\n    });\n    res.sql = sql;\n\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    if (returningClause && intoClause) {\n      res.sql += ' returning ' + returningClause + ' into ' + intoClause;\n    }\n    res.outBinding = [outBinding];\n    if (returning[0] === '*') {\n      res.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID = :1';\n      };\n    }\n    res.returning = returning;\n\n    return res;\n  }\n\n  _prepOutbindings(paramValues, paramReturning) {\n    const result = {};\n    let params = paramValues || [];\n    let returning = paramReturning || [];\n    if (!Array.isArray(params) && isPlainObject(paramValues)) {\n      params = [params];\n    }\n    // Always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    const outBinding = [];\n    // Handle Buffer value as Blob\n    each(params, function (values, index) {\n      if (returning[0] === '*') {\n        outBinding[index] = ['ROWID'];\n      } else {\n        outBinding[index] = clone(returning);\n      }\n      each(values, function (value, key) {\n        if (value instanceof Buffer) {\n          values[key] = new BlobHelper(key, value);\n\n          // Delete blob duplicate in returning\n          const blobIndex = outBinding[index].indexOf(key);\n          if (blobIndex >= 0) {\n            outBinding[index].splice(blobIndex, 1);\n            values[key].returning = true;\n          }\n          outBinding[index].push(values[key]);\n        }\n        if (value === undefined) {\n          delete params[index][key];\n        }\n      });\n    });\n    result.returning = returning;\n    result.outBinding = outBinding;\n    result.values = params;\n    return result;\n  }\n\n  _groupOrder(item, type) {\n    return super._groupOrderNulls(item, type);\n  }\n\n  update() {\n    const self = this;\n    const sql = {};\n    const outBindPrep = this._prepOutbindings(\n      this.single.update || this.single.counter,\n      this.single.returning\n    );\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n\n    let returningClause = '';\n    let intoClause = '';\n\n    if (isEmpty(updates) && typeof this.single.update !== 'function') {\n      return '';\n    }\n\n    // Build returning and into clauses\n    outBinding.forEach(function (out) {\n      out.forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n\n        // Add Helpers to bindings\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n    });\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n\n    sql.outBinding = outBinding;\n    sql.returning = returning;\n    sql.sql =\n      'update ' +\n      this.tableName +\n      ' set ' +\n      updates.join(', ') +\n      (where ? ' ' + where : '');\n    if (outBinding.length && !isEmpty(outBinding[0])) {\n      sql.sql += ' returning ' + returningClause + ' into' + intoClause;\n    }\n    if (returning[0] === '*') {\n      sql.returningSql = function () {\n        let sql = 'select * from ' + self.tableName;\n        const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;\n        let returningSqlIn = ' where ROWID in (';\n        let returningSqlOrderBy = ') order by case ROWID ';\n\n        // Needs special order by because in(...) change result order\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          if (this.returning[0] === '*') {\n            returningSqlIn += ':' + (i + 1) + ', ';\n            returningSqlOrderBy +=\n              'when CHARTOROWID(:' + (i + 1) + ') then ' + i + ' ';\n          }\n        }\n        if (this.returning[0] === '*') {\n          this.returning = this.returning.slice(0, -1);\n          returningSqlIn = returningSqlIn.slice(0, -2);\n          returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);\n        }\n        return (sql += returningSqlIn + returningSqlOrderBy + ' end');\n      };\n    }\n\n    return sql;\n  }\n\n  _jsonPathWrap(extraction) {\n    return `'${extraction.path || extraction[1]}'`;\n  }\n\n  // Json functions\n  jsonExtract(params) {\n    return this._jsonExtract(\n      params.singleValue ? 'json_value' : 'json_query',\n      params\n    );\n  }\n\n  jsonSet(params) {\n    return `json_transform(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )}, set ${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )} = ${this.client.parameter(\n      params.value,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n  }\n\n  jsonInsert(params) {\n    return `json_transform(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )}, insert ${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )} = ${this.client.parameter(\n      params.value,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n  }\n\n  jsonRemove(params) {\n    const jsonCol = `json_transform(${columnize_(\n      params.column,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    )}, remove ${this.client.parameter(\n      params.path,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n    return params.alias\n      ? this.client.alias(jsonCol, this.formatter.wrap(params.alias))\n      : jsonCol;\n  }\n\n  whereJsonPath(statement) {\n    return this._whereJsonPath('json_value', statement);\n  }\n\n  whereJsonSupersetOf(statement) {\n    throw new Error(\n      'Json superset where clause not actually supported by Oracle'\n    );\n  }\n\n  whereJsonSubsetOf(statement) {\n    throw new Error(\n      'Json subset where clause not actually supported by Oracle'\n    );\n  }\n\n  onJsonPathEquals(clause) {\n    return this._onJsonPathEquals('json_value', clause);\n  }\n}\n\nmodule.exports = Oracledb_Compiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}